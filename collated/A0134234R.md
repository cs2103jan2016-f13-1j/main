# A0134234R
###### /src/main/logic/AddCommand.java
``` java

package main.logic;

import java.util.ArrayList;

import main.data.Task;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class AddCommand implements Command {
    Receiver receiver;
    Task task;
    
    public AddCommand(Receiver receiver, Task task) {
        this.receiver = receiver;
        this.task = task;
    }
    
    /**
     * This method allows you to add a {@code Task} to the 
     * {@code ArrayList} of {@code Task} in memory.
     */   
    public void execute() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        allTasks.add(task);
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
    
    public void undo() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        allTasks.remove(task);
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
}
```
###### /src/main/logic/Command.java
``` java

package main.logic;
/** This interface represents a Command that the program logic can
 * execute or undo.
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public interface Command {
	public void execute();
	public void undo();
}
```
###### /src/main/logic/CustomComparator.java
``` java

/** 
 * This class acts as a container to store custom comparators
 * used to sort tasks by different conditions
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */

package main.logic;
import java.util.Comparator;

import main.data.Task;

/**
 * This comparator sorts tasks by a few rules:
 * 1. If both are floating tasks,
 *       - return earlier created first
 * 2. If only one has a date,
 *       - return the floating task
 * 3. If both have dates,
 *       - if both have single date, return earlier date first
 *       - if one have single date and the other is ranged, return earlier date first
 *       - if both are ranged,
 *          - if both started, return earlier created first
 *          - if only one started, return the task that already started
 *          - if both have not started, return earlier end date first
 */
class CustomTaskComparator implements Comparator<Task> {
    public int compare(Task t1, Task t2) {
        if (!t1.hasDate() && !t2.hasDate()) {
            //If both are floating tasks
            if (t1.getPriority() == t2.getPriority()) {
                //If equal priority, compare the created date
                return t1.getCreatedDate().compareTo(t2.getCreatedDate());
            } else {
                //Return higher priority first
                return t2.getPriority() - t1.getPriority();
            }
        } else if (!t1.hasDate() && t2.hasDate()) {
            //If one is floating and the other is dated, return the floating task
            return 1;
        } else if (t1.hasDate() && !t2.hasDate()) {
            //If one is dated and the other is floating, return the floating task
            return -1;
        } else {
            //Both tasks has date
            if (t1.hasSingleDate() && t2.hasSingleDate()) {
                //If both only has one date
                return t1.getSingleDate().compareTo(t2.getSingleDate());
            } else if (t1.hasSingleDate() && t2.hasDateRange()) {
                //If one has single date and the other is ranged
                if (t1.hasStarted()) {
                    //t1 have stared
                    return t1.getSingleDate().compareTo(t2.getEndDate());
                } else {
                    //t1 have not started
                    if (t1.getSingleDate().compareTo(t2.getStartDate()) == 0) {
                        return -1;
                    } else {
                        return t1.getSingleDate().compareTo(t2.getStartDate());
                    }
                }
            } else if (t1.hasDateRange() && t2.hasSingleDate()) {
                //If one is ranged and the other has single date
                if (t1.hasStarted()) {
                    //t1 have stared
                    return t1.getEndDate().compareTo(t2.getSingleDate());
                } else {
                    //t1 have not started
                    if (t1.getStartDate().compareTo(t2.getSingleDate()) == 0) {
                        return 1;
                    } else {
                        return t1.getStartDate().compareTo(t2.getSingleDate());
                    }
                }
            } else {
                //Both tasks are ranged dates
                if (t1.hasStarted() && t2.hasStarted()) {
                    //If both tasks already started
                    if (t1.getEndDate().compareTo(t2.getEndDate()) == 0) {
                        //If both tasks has same end date
                        if (t1.getPriority() == t2.getPriority()) {
                            //If equal priority, compare the created date
                            return t1.getCreatedDate().compareTo(t2.getCreatedDate());
                        } else {
                            //Return higher priority first
                            return t2.getPriority() - t1.getPriority();
                        }
                    } else {
                        //If both tasks has different end date, return earlier deadline first
                        return t1.getEndDate().compareTo(t2.getEndDate());
                    }
                } else if (t1.hasStarted() && !t2.hasStarted()) {
                    //t1 has started but not t2
                    return -1;
                } else if (!t1.hasStarted() && t2.hasStarted()) {
                    //t2 has started but not t1
                    return 1;
                } else {
                    //If both have not started yet
                    if (t1.getStartDate().compareTo(t2.getStartDate()) == 0) {
                        //If both have the same start date
                        if (t1.getPriority() == t2.getPriority()) {
                            //If equal priority, compare the created date
                            return t1.getCreatedDate().compareTo(t2.getCreatedDate());
                        } else {
                            //Return higher priority first
                            return t2.getPriority() - t1.getPriority();
                        }
                    } else {
                        //Return earlier start date first
                        return t1.getStartDate().compareTo(t2.getStartDate());
                    }
                }
            }
        }
    }
}
```
###### /src/main/logic/DeleteCommand.java
``` java

package main.logic;
import java.util.ArrayList;

import main.data.Task;
import main.data.TaskHeader;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class DeleteCommand implements Command {
    Receiver receiver;
    Task task;
    ArrayList<Task> tasks;
    
    public DeleteCommand(Receiver receiver, Task task) {
        this.receiver = receiver;
        this.task = task;
    }
    
    public DeleteCommand(Receiver receiver, ArrayList<Task> tasks) {
        this.receiver = receiver;
        this.tasks = new ArrayList<Task>();
        this.tasks.addAll(tasks);
    }
    
    /**
     * This method allows you to delete a single or multiple {@code Task} from the 
     * {@code ArrayList} of {@code Task}.
     */
    public void execute() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        if (task != null) {
            allTasks.remove(task);      
        } else if (tasks != null){
            for (Task task : tasks) {
                allTasks.remove(task);
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
    
    public void undo() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        if (task != null) {
            allTasks.add(task);
        } else if (tasks != null){
            for (Task task : tasks) {
                allTasks.add(task);
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
}
```
###### /src/main/logic/DoneCommand.java
``` java

package main.logic;
import java.util.ArrayList;

import main.data.Task;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class DoneCommand implements Command {
    Receiver receiver;
    Task task;
    ArrayList<Task> tasks;
    
    public DoneCommand(Receiver receiver, Task task) {
        this.receiver = receiver;
        this.task = task;
    }
    
    public DoneCommand(Receiver receiver, ArrayList<Task> tasks) {
        this.receiver = receiver;
        this.tasks = new ArrayList<Task>();
        this.tasks.addAll(tasks);
    }
    
    /**
     * This method allows you to mark a single or multiple {@code Task} from the 
     * {@code ArrayList} of {@code Task} in memory as completed.
     */
    public void execute() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        if (task != null) {
            for (Task t : allTasks) {
                if (t.equals(task)) {
                    t.setIsCompleted();
                    break;
                }
            }
        } else if (tasks != null){
            for (Task t1 : allTasks) {
                for (Task t2 : tasks) {
                    if (t1.equals(t2)) {
                        t1.setIsCompleted();
                    }
                }
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
    
    public void undo() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        if (task != null) {
            for (Task t : allTasks) {
                if (t.equals(task)) {
                    t.setNotCompleted();
                }
            }
        } else if (tasks != null){
            for (Task t1 : allTasks) {
                for (Task t2 : tasks) {
                    if (t1.equals(t2)) {
                        t1.setNotCompleted();
                    }
                }
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
}
```
###### /src/main/logic/EditCommand.java
``` java

package main.logic;

import java.util.ArrayList;

import main.data.Task;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class EditCommand implements Command {
    Receiver receiver;
    Task oldTask;
    Task newTask;
    
    public EditCommand(Receiver receiver, Task oldTask, Task newTask) {
        this.receiver = receiver;
        this.oldTask = oldTask;
        this.newTask = newTask;
    }
    
    public void execute() {
        edit(oldTask, newTask);
    }
    
    public void undo() {
        edit(newTask, oldTask);
    }
    
    /**
     * This method allows you to edit a {@code Task} to a new {@code Task} 
     * in the {@code ArrayList} of {@code Task} in memory.
     * 
     * @param   oldTask
     *          {@code Task} to be replaced remove
     * @param   newTask
     *          {@code Task} new task to be added
     */
    private void edit(Task oldTask, Task newTask) {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        allTasks.remove(oldTask);
        allTasks.add(newTask);
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
}
```
###### /src/main/logic/Invoker.java
``` java

package main.logic;
import java.util.EmptyStackException;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

/** 
 * @author Bevin Seetoh Jia Jin
 *
 */
public class Invoker {
	
    private static final Logger logger = Logger.getLogger(Invoker.class.getName());
    
	private Stack<Command> undoHistory = new Stack<Command>();
	private Stack<Command> redoHistory = new Stack<Command>();
	
	/** Executes a Command and adds it to the undo history
	 * 
	 * @param command An instance of the Command interface
	 */
	public void execute(Command command) {
		if (!(command instanceof SearchCommand)) {
    		undoHistory.push(command);
    		redoHistory.clear();
		}
		
		command.execute();
	}

	/** Returns true if there is at least one undoable Command
	 * available on the undo history.
	 * 
	 * @return   true if undo stack is not empty
	 */
	public boolean isUndoAvailable() {
		return !undoHistory.empty();
	}

	/** 
	 * Undo the next available command.
	 */
	public Command undo() throws EmptyStackException {
	    Command command;
	    try {
	        logger.log(Level.INFO, "Executing undo command");
    		command = undoHistory.pop();
    		redoHistory.push(command);
    		command.undo();
	    } catch (Exception e) {
	        logger.log(Level.WARNING, "Stack is empty, check if undo is available before calling");
	        throw new EmptyStackException();
	    }
	    return command;
	}

	/** 
	 * Returns true if there is at least one redoable Command
	 * available on the redo history.
	 * 
	 * @return   true if redo stack is not empty
	 */
	public boolean isRedoAvailable() {
		return !redoHistory.empty();
	}

	/** 
	 * Redo the next available command.
	 */
	public Command redo() throws EmptyStackException {
	    Command command;
	    try {
	        logger.log(Level.INFO, "Executing redo command");
    		command = redoHistory.pop();
    		undoHistory.push(command);
    		command.execute();
	    } catch (Exception e) {
	        logger.log(Level.WARNING, "Stack is empty, check if redo is available before calling");
	        throw new EmptyStackException();
	    }
	    return command;
	}
}
```
###### /src/main/logic/PriorityCommand.java
``` java

package main.logic;

import java.util.ArrayList;

import main.data.Task;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class PriorityCommand implements Command {
    Receiver receiver;
    Task task;
    
    public PriorityCommand(Receiver receiver, Task task) {
        this.receiver = receiver;
        this.task = task;
    }
    
    public void execute() {
        priority(task, true);
    }
    
    public void undo() {
        priority(task, false);
    }
    
    /**
     * This method cycles the priority of the task. The priority increases/decreases
     * respectively according to the true/false boolean {@code increase}.
     * @param   task
     *          The {@code Task} to have its priority modified.
     * @param   increase
     *          The {@code boolean} to indicate an increase or decrease in priority.
     */
    private void priority(Task task, boolean increase) {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        for (Task t : allTasks) {
            if (t.equals(task)) {
                t.togglePriority(increase);
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
}
```
###### /src/main/logic/Receiver.java
``` java

package main.logic;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Observable;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.data.Task;
import main.storage.Storage;

/**
 * This is a singleton class
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class Receiver extends Observable {

    private static final Logger logger = Logger.getLogger(Receiver.class.getName());

    private static Receiver receiver;

    private Storage storage;
    private ArrayList<Task> allTasks;
    private ArrayList<Task> todoTasks;
    private ArrayList<Task> completedTasks;

    private ScheduleManager scheduler;

    private Receiver() {
        storage = Storage.getInstance();
        scheduler = new ScheduleManager();
        assert(storage != null);

        initialize();
        assert(todoTasks != null);
        assert(completedTasks != null);

        loadFromStorage();
    }

    /**
     * A static method to initialize an instance of the {@code Receiver} class.
     *
     * @return   An instance of the {@code Receiver} class
     */
    public static synchronized Receiver getInstance() {
        if (receiver == null) {
            receiver = new Receiver();
        }
        assert(receiver != null);
        return receiver;
    }

    /**
     * Prevents attempts to clone this singleton class.
     */
    public Object clone() throws CloneNotSupportedException {
        logger.log(Level.WARNING, "Clone not supported. This is a singleton class.");
        throw new CloneNotSupportedException();
    }

    /**
     * Use to retrieve all tasks
     *
     * @return  all tasks
     */
    public ArrayList<Task> getAllTasks() {
        return allTasks;
    }

    /**
     * Use to set {@code allTasks} with a new {@code ArrayList}
     * @param   tasks
     *          The new list of all Tasks
     */
    public void setAllTasks(ArrayList<Task> tasks) {
        allTasks = tasks;
    }

    /**
     * Use to retrieve ToDo tasks
     *
     * @return  todo tasks
     */
    public ArrayList<Task> getTodoTasks() {
        return todoTasks;
    }

    /**
     * Use to set {@code todoTasks} with a new {@code ArrayList}
     * @param   tasks
     *          The new list of todo Tasks
     */
    public void setTodoTasks(ArrayList<Task> tasks) {
        todoTasks = tasks;
    }

    /**
     * Use to retrieve completed tasks
     *
     * @return  completed tasks
     */
    public ArrayList<Task> getCompletedTasks() {
        return completedTasks;
    }

    /**
     * Use to set {@code completedTasks} with a new {@code ArrayList}
     * @param   tasks
     *          The new list of completed Tasks
     */
    public void setCompletedTasks(ArrayList<Task> tasks) {
        completedTasks = tasks;
    }

    public Storage getStorage() {
        return storage;
    }

    /**
     * This method returns the current path of the output file.
     *
     * @return   A {@code String} indicating the file path
     */
    public String getFilePath() {
        return storage.getFilePath();
    }

    /**
     * This method returns the current directory of the output file.
     *
     * @return   A {@code String} indicating the file directory
     */
    public String getFileDir() {
        return storage.getFileDir();
    }

    /**
     * This method updates the storage file path with the given {@code path},
     * then loads tasks from the file into the program and notifies observers
     *
     * @param   path
     *          The new {@code path} to set to
     */

    public void setFilePath(String path) {
        storage.setFileLocation(path);
        loadFromStorage();
        updateObservers();
    }

    private void initialize() {
        todoTasks = new ArrayList<Task>();
        completedTasks = new ArrayList<Task>();
    }

    public void initiateSave() {
        categorizeTasks(allTasks);
        sortTasks();
        updateCollision();
        saveToStorage();
        updateObservers();
    }

    public void updateObservers() {
        logger.log(Level.INFO, "Updating observers");
        setChanged();
        notifyObservers();
    }

    private void loadFromStorage() {
        allTasks = storage.readTasks();
        assert(allTasks != null);

        categorizeTasks(allTasks);
        sortTasks();
        updateCollision();
    }

    private void categorizeTasks(ArrayList<Task> tasks) {
        todoTasks.clear();
        completedTasks.clear();

        for (Task task : tasks) {
            if (task.isDone()) {
                completedTasks.add(task);
            } else {
                todoTasks.add(task);
            }
        }
    }

    private void sortTasks() {
        logger.log(Level.INFO, "Sorting tasks");
        Collections.sort(todoTasks, new CustomTaskComparator());
        Collections.sort(completedTasks, new CustomTaskComparator());
    }

    private void updateCollision() {
        logger.log(Level.INFO, "Updating tasks collision variables");
        scheduler.updateTodoCollision(todoTasks);
        scheduler.updateCompletedCollision(completedTasks);
    }

    private void saveToStorage() {
        logger.log(Level.INFO, "Saving tasks: " + allTasks);
        storage.writeTasks(allTasks);
    }
}
```
###### /src/main/logic/ScheduleManager.java
``` java

package main.logic;

import java.util.ArrayList;

import main.data.Task;

public class ScheduleManager {
    
    public void updateTodoCollision(ArrayList<Task> todoTasks) {
        Task previousTask;
        Task currentTask;
        Task nextTask;
        
        for (int i = 0; i < todoTasks.size(); i++) {
            currentTask = todoTasks.get(i);
            previousTask = null;
            nextTask = null;
            
            if (todoTasks.size() > 1) {
                if (i == 0) {
                    nextTask = todoTasks.get(i + 1);
                } else if (i == (todoTasks.size() - 1)) {
                    previousTask = todoTasks.get(i - 1);
                } else {
                    previousTask = todoTasks.get(i - 1);
                    nextTask = todoTasks.get(i + 1);
                }
            }
            updateCollision(previousTask, currentTask, nextTask);
        }
    }
    
    public void updateCompletedCollision(ArrayList<Task> completedTasks) {
        for (Task task : completedTasks) {
            task.setCollideWithPrev(false);
            task.setCollideWithNext(false);
        }
    }
    
    private void updateCollision(Task prev, Task curr, Task next) {
        if (curr.hasDate()) {
            if (curr.hasSingleDate() && curr.hasStartDate()) {
                //current only have a start date
                if (prev != null && prev.hasDate()) {
                    if (prev.hasSingleDate() && prev.hasStartDate()) {
                        //previous only have a start date
                        if (curr.getSingleDate().equals(prev.getSingleDate())) {
                            curr.setCollideWithPrev(true);
                        } else {
                            curr.setCollideWithPrev(false);
                        }
                    } else if (prev.hasDateRange()) {
                        //previous is event task
                        if (curr.getSingleDate().equals(prev.getStartDate())) {
                            //start date collides
                            curr.setCollideWithPrev(true);
                        } else if (curr.getSingleDate().after(prev.getStartDate()) && curr.getSingleDate().before(prev.getEndDate())) {
                            //current date falls between previous's date range
                            curr.setCollideWithPrev(true);
                        } else {
                            curr.setCollideWithPrev(false);
                        }
                    } else {
                        curr.setCollideWithPrev(false);
                    }
                } else {
                    curr.setCollideWithPrev(false);
                }
                
                if (next != null && next.hasDate()) {
                    if (next.hasSingleDate() && next.hasStartDate()) {
                        //next only have a start date
                        if (curr.getSingleDate().equals(next.getSingleDate())) {
                            curr.setCollideWithNext(true);
                        } else {
                            curr.setCollideWithNext(false);
                        }
                    } else if (next.hasDateRange()) {
                        //next is event task
                        if (curr.getSingleDate().equals(next.getStartDate())) {
                            //start date collides
                            curr.setCollideWithNext(true);
                        } else if (curr.getSingleDate().after(next.getStartDate()) && curr.getSingleDate().before(next.getEndDate())) {
                            //current date falls between next's date range
                            curr.setCollideWithNext(true);
                        } else {
                            curr.setCollideWithNext(false);
                        }
                    } else {
                        curr.setCollideWithNext(false);
                    }
                } else {
                    curr.setCollideWithNext(false);
                }
            } else if (curr.hasDateRange()) { 
                //current is event task
                if (prev != null && prev.hasDate()) {
                    if (prev.hasSingleDate() && prev.hasStartDate()) {
                        //previous only have a start date
                        if (prev.getSingleDate().equals(curr.getStartDate())) {
                            //start date collides
                            curr.setCollideWithPrev(true);
                        } else if (prev.getSingleDate().after(curr.getStartDate()) && prev.getSingleDate().before(curr.getEndDate())) {
                            //previous date falls between current's date range
                            curr.setCollideWithPrev(true);
                        } else {
                            curr.setCollideWithNext(false);
                        }
                    } else if (prev.hasDateRange()) {
                        //previous is event task
                        if (curr.getStartDate().equals(prev.getStartDate()) || curr.getEndDate().equals(prev.getEndDate())) {
                            curr.setCollideWithPrev(true);
                        } else if (prev.getStartDate().after(curr.getStartDate()) && prev.getStartDate().before(curr.getEndDate())) {
                            //previous's start date falls between current's date range
                            curr.setCollideWithPrev(true);
                        } else if (prev.getEndDate().after(curr.getStartDate()) && prev.getEndDate().before(curr.getEndDate())) {
                            //previous's end date falls between current's date range
                            curr.setCollideWithPrev(true);
                        } else if (curr.getStartDate().after(prev.getStartDate()) && curr.getStartDate().before(prev.getEndDate())) {
                            //current's start date falls between previous's date range
                            curr.setCollideWithPrev(true);
                        } else if (curr.getEndDate().after(prev.getStartDate()) && curr.getEndDate().before(prev.getEndDate())) {
                            //current's end date falls between previous's date range
                            curr.setCollideWithPrev(true);
                        } else {
                            curr.setCollideWithPrev(false);
                        }
                    } else {
                        curr.setCollideWithPrev(false);
                    }
                } else {
                    curr.setCollideWithPrev(false);
                }
                
                if (next != null && next.hasDate()) {
                    if (next.hasSingleDate() && next.hasStartDate()) {
                        //next only have a start date
                        if (next.getSingleDate().equals(curr.getStartDate())) {
                            //start date collides
                            curr.setCollideWithNext(true);
                        } else if (next.getSingleDate().after(curr.getStartDate()) && next.getSingleDate().before(curr.getEndDate())) {
                            //next date falls between current's date range
                            curr.setCollideWithNext(true);
                        } else {
                            curr.setCollideWithNext(false);
                        }
                    } else if (next.hasDateRange()) {
                        //next is event task
                        if (curr.getStartDate().equals(next.getStartDate()) || curr.getEndDate().equals(next.getEndDate())) {
                            curr.setCollideWithNext(true);
                        } else if (next.getStartDate().after(curr.getStartDate()) && next.getStartDate().before(curr.getEndDate())) {
                            //next's start date falls between current's date range
                            curr.setCollideWithNext(true);
                        } else if (next.getEndDate().after(curr.getStartDate()) && next.getEndDate().before(curr.getEndDate())) {
                            //next's end date falls between current's date range
                            curr.setCollideWithNext(true);
                        } else if (curr.getStartDate().after(next.getStartDate()) && curr.getStartDate().before(next.getEndDate())) {
                            //current's start date falls between next's date range
                            curr.setCollideWithNext(true);
                        } else if (curr.getEndDate().after(next.getStartDate()) && curr.getEndDate().before(next.getEndDate())) {
                            //current's end date falls between next's date range
                            curr.setCollideWithNext(true);
                        } else {
                            curr.setCollideWithNext(false);
                        }
                    } else {
                        curr.setCollideWithNext(false);
                    }
                } else {
                    curr.setCollideWithNext(false);
                }
            } else {
                curr.setCollideWithPrev(false);
                curr.setCollideWithNext(false);
            }
        } else {
            curr.setCollideWithPrev(false);
            curr.setCollideWithNext(false);
        }
    }
}
```
###### /src/main/logic/SearchCommand.java
``` java

package main.logic;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.temporal.TemporalAdjusters;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;

import main.data.Task;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class SearchCommand implements Command {
    Receiver receiver;
    String searchTerm;
    Date searchDate;
    
    public SearchCommand(Receiver receiver, String searchTerm) {
        this.receiver = receiver;
        this.searchTerm = searchTerm;
    }
    
    public SearchCommand(Receiver receiver, Date searchDate) {
        this.receiver = receiver;
        this.searchDate = searchDate;
    }
    
    public void execute() {
        ArrayList<Task> searchResults = new ArrayList<Task>();
        if (searchTerm != null) {
            searchResults = search(searchTerm);
        } else if (searchDate != null) {
            searchResults = search(searchDate);
        }
        updateReceiverTasks(searchResults);
    }
    
    public void undo() {
    }
    
    /**
     * This method allows you to search for tasks that has description
     * or label found in the given {@code searchTerm}.
     * 
     * @param   searchTerm
     *          The {@code String} of terms to search which are separated by spaces.
     * @return  The list of results
     */
    private ArrayList<Task> search(String searchString) {
        String searchTerm = searchString.toLowerCase();
        
        if (searchTerm.equals("this week")) {
            return searchForThisWeek();
        } else if (searchTerm.equals("next week")) {
            return searchForNextWeek();
        } else if (searchTerm.equals("upcoming")) {
            return searchForUpcoming();
        } else if (searchTerm.equals("someday")) {
            return searchForSomeday();
        } else if (searchTerm.equals("deadline")) {
            return searchForDeadline();
        } else if (searchTerm.contains("priority l") || searchTerm.contains("priority m") || searchTerm.contains("priority h")) {
            return searchForPriority(searchString);
        } else {
            return searchForString(searchTerm);
        }
    }
    
    private ArrayList<Task> searchForThisWeek() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        
        LocalDate now = LocalDate.now();
        LocalDate sundayLocalDate = now.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
        Date today = Date.from(now.atStartOfDay(ZoneId.systemDefault()).toInstant());
        Date sunday = Date.from(sundayLocalDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
        
        for (Task task : allTasks) {
            if (task.hasDateRange()) {
                Date startDate = removeTimeFromDate(task.getStartDate());
                Date endDate = removeTimeFromDate(task.getEndDate());
                if (startDate.equals(today) || startDate.equals(sunday) || (startDate.after(today) && endDate.before(sunday))) {
                    searchResults.add(task);
                } else if (endDate.equals(today) || endDate.equals(sunday) || (endDate.after(today) && endDate.before(sunday))) {
                    searchResults.add(task);
                }
            } else if (task.hasSingleDate()) {
                Date singleDate = removeTimeFromDate(task.getSingleDate());
                if (singleDate.equals(today) || singleDate.equals(sunday) || (singleDate.after(today) && singleDate.before(sunday))) {
                    searchResults.add(task);
                }
            }
        }
        
        return searchResults;
    }
    
    private ArrayList<Task> searchForNextWeek() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        
        LocalDate now = LocalDate.now();
        LocalDate sundayLocalDate = now.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
        LocalDate nextSundayLocalDate = sundayLocalDate.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
        Date sunday = Date.from(sundayLocalDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
        Date nextSunday = Date.from(nextSundayLocalDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
        
        for (Task task : allTasks) {
            if (task.hasDateRange()) {
                Date startDate = removeTimeFromDate(task.getStartDate());
                Date endDate = removeTimeFromDate(task.getEndDate());
                if (startDate.equals(nextSunday) || (startDate.after(sunday) && endDate.before(nextSunday))) {
                    searchResults.add(task);
                } else if (endDate.equals(nextSunday) || (endDate.after(sunday) && endDate.before(nextSunday))) {
                    searchResults.add(task);
                }
            } else if (task.hasSingleDate()) {
                Date singleDate = removeTimeFromDate(task.getSingleDate());
                if (singleDate.equals(nextSunday) || (singleDate.after(sunday) && singleDate.before(nextSunday))) {
                    searchResults.add(task);
                }
            }
        }
        
        return searchResults;
    }
    
    private ArrayList<Task> searchForUpcoming() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        
        LocalDate tmr = LocalDate.now().plusDays(1);
        Date tomorrow = Date.from(tmr.atStartOfDay(ZoneId.systemDefault()).toInstant());
        
        for (Task task : allTasks) {
            if (task.hasDateRange()) {
                Date startDate = removeTimeFromDate(task.getStartDate());
                Date endDate = removeTimeFromDate(task.getEndDate());
                if (startDate.after(tomorrow) || endDate.after(tomorrow)) {
                    searchResults.add(task);
                }
            } else if (task.hasSingleDate()) {
                Date singleDate = removeTimeFromDate(task.getSingleDate());
                if (singleDate.after(tomorrow)) {
                    searchResults.add(task);
                }
            }
        }
        
        return searchResults;
    }
    
    private ArrayList<Task> searchForSomeday() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        
        for (Task task : allTasks) {
            if (!task.hasDate()) {
                searchResults.add(task);
            }
        }
        
        return searchResults;
    }
    
    private ArrayList<Task> searchForDeadline() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        
        for (Task task : allTasks) {
            if (task.hasSingleDate() && task.hasEndDate()) {
                searchResults.add(task);
            }
        }
        
        return searchResults;
    }
    
    private ArrayList<Task> searchForPriority(String searchString) {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        
        String priority = searchString.split(" ")[1];
        
        for (Task task : allTasks) {
            if (task.getPriority() == 1 && priority.charAt(0) == 'l') {
                searchResults.add(task);
            }
            if (task.getPriority() == 2 && priority.charAt(0) == 'm') {
                searchResults.add(task);
            }
            if (task.getPriority() == 3 && priority.charAt(0) == 'h') {
                searchResults.add(task);
            }
        }
        
        return searchResults;
    }
    
    private ArrayList<Task> searchForString(String searchTerm) {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        String[] searchList = searchTerm.split(" ");
        
        for (Task task : allTasks) {
            String title = task.getTitle().toLowerCase();
            boolean found = true;
            int prevIndex = Integer.MIN_VALUE;
            
            for (String term : searchList) {         
                if (term.contains("#")) {
                    if (task.getLabel() == null) {
                        found = false;
                    } else if (!("#" + task.getLabel()).toLowerCase().contains(term)) {
                        found = false;
                    }
                } else {
                    String[] characters = term.split("");
                    boolean titleContainAllChars = true;
                    
                    for (String c : characters) {
                        if (!title.contains(c)) {
                            titleContainAllChars = false;
                        }
                    }
                    
                    if (titleContainAllChars) {
                        for (String character : characters) {
                            int currIndex;
                            if (prevIndex == Integer.MIN_VALUE) {
                                currIndex = title.indexOf(character);
                            } else {
                                currIndex = title.indexOf(character, prevIndex + 1);
                            }
                            if (currIndex < prevIndex) {
                                found = false;
                            } else {
                                prevIndex = currIndex;
                            }
                        }
                    } else {
                        found = false;
                    }
                }
            }
            
            if (found) {
                searchResults.add(task);
            }
        }
        
        return searchResults;
    }
    
    /**
     * This method allows you to search for tasks by date which have the
     * same date as the given {@code searchDate}. Not time specific.
     * 
     * @param   searchDate
     *          The {@code Date} search.
     * @return  The list of results
     */
    private ArrayList<Task> search(Date searchDate) {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        ArrayList<Task> searchResults = new ArrayList<Task>();
        Date dateToSearch = removeTimeFromDate(searchDate);
        
        for (Task task : allTasks) {
            if (task.hasDateRange()) {
                Date startDate = removeTimeFromDate(task.getStartDate());
                Date endDate = removeTimeFromDate(task.getEndDate());
                if (startDate.equals(dateToSearch) || endDate.equals(dateToSearch)) {
                    searchResults.add(task);
                }
            } else if (task.hasSingleDate()) {
                Date singleDate = removeTimeFromDate(task.getSingleDate());
                if (singleDate.equals(dateToSearch)) {
                    searchResults.add(task);
                }
            }
        }
        return searchResults;
    }
    
    //Removes all time details from the given Date
    private Date removeTimeFromDate(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        return calendar.getTime();
    }
    
    private void updateReceiverTasks(ArrayList<Task> searchResults) {
        ArrayList<Task> todoTasks = new ArrayList<Task>();
        ArrayList<Task> completedTasks = new ArrayList<Task>();
        
        for (Task task : searchResults) {
            if (task.isDone()) {
                completedTasks.add(task);
            } else {
                todoTasks.add(task);
            }
        }
        Collections.sort(todoTasks, new CustomTaskComparator());
        Collections.sort(completedTasks, new CustomTaskComparator());
        
        receiver.setTodoTasks(todoTasks);
        receiver.setCompletedTasks(completedTasks);
        receiver.updateObservers();
    }
}
```
###### /src/main/logic/SetFileLocationCommand.java
``` java

package main.logic;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class SetFileLocationCommand implements Command {
    Receiver receiver;
    String oldLocation;
    String newLocation;
    
    public SetFileLocationCommand(Receiver receiver, String newLocation) {
        this.receiver = receiver;
        this.oldLocation = receiver.getFilePath();
        this.newLocation = newLocation;
    }
    
    public void execute() {
        setFileLocation(newLocation);
    }
    
    public void undo() {
        setFileLocation(oldLocation);
    }
    
    /**
     * This methods sends an instruction to the {@code Storage} class
     * to update its settings.txt file
     * 
     * @param  fileLocation
     *         The location to save the output file
     */
    private void setFileLocation(String fileLocation) {
        receiver.setFilePath(fileLocation);
    }
}
```
###### /src/main/logic/UndoneCommand.java
``` java

package main.logic;
import java.util.ArrayList;

import main.data.Task;

/**
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
public class UndoneCommand implements Command {
    Receiver receiver;
    Task task;
    ArrayList<Task> tasks;
    
    public UndoneCommand(Receiver receiver, Task task) {
        this.receiver = receiver;
        this.task = task;
    }
    
    public UndoneCommand(Receiver receiver, ArrayList<Task> tasks) {
        this.receiver = receiver;
        this.tasks = tasks;
    }
    
    /**
     * This method allows you to mark a single or multiple {@code Task} from the 
     * {@code ArrayList} of {@code Task} in memory as incomplete.
     */
    public void execute() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        if (task != null) {
            for (Task t : allTasks) {
                if (t.equals(task)) {
                    t.setNotCompleted();
                }
            }
        } else if (tasks != null){
            for (Task t1 : allTasks) {
                for (Task t2 : tasks) {
                    if (t1.equals(t2)) {
                        t1.setNotCompleted();
                    }
                }
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
    
    public void undo() {
        ArrayList<Task> allTasks = receiver.getAllTasks();
        
        if (task != null) {
            for (Task t : allTasks) {
                if (t.equals(task)) {
                    t.setIsCompleted();
                    break;
                }
            }
        } else if (tasks != null){
            for (Task t1 : allTasks) {
                for (Task t2 : tasks) {
                    if (t1.equals(t2)) {
                        t1.setIsCompleted();
                    }
                }
            }
        }
        
        receiver.setAllTasks(allTasks);
        receiver.initiateSave();
    }
}
```
###### /src/main/storage/Storage.java
``` java

package main.storage;

/**
 * This is a singleton class. This class is used to read/write to
 * an output file. 
 * 
 * You can expect to see two files upon initializing this class:
 * 1. settings.txt (Stores the path of the output file - Default: tasks.txt)
 * 2. tasks.txt (Default file name)
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import main.data.Task;

public class Storage {
    
    private static final Logger logger = Logger.getLogger(Storage.class.getName());
    
	private static Storage storage;
	private String OS = System.getProperty("os.name").toLowerCase();
	
	private final String USER_SETTINGS = "settings.txt";
	private final String USER_DIR = System.getProperty("user.dir");
	private final String DEFAULT_FILE_NAME = "tasks.txt";
	
	private final String WINDOWS_DIR_SYMBOL = "\\";
	private final String MAC_DIR_SYMBOL = "/";
	private final String UNIX_DIR_SYMBOL = "/";
	private final String SOLARIS_DIR_SYMBOL = "/";
	
	private final String FILE_PATH_FORMAT = "%s%s%s";
	
	private String fileDir = null;
	private String fileName = null;
	private String filePath = null;

	private Storage() {
	    readUserSettings();
	}
	
	/**
	 * A static method to initialize an instance of the {@code Storage} class.
	 * 
	 * @return   An instance of the {@code Storage} class
	 */
	public static synchronized Storage getInstance() {
		if (storage == null) {
			storage = new Storage();
		}
		return storage;
	}
	
	/**
	 * Prevents attempts to clone this singleton class.
	 */
	public Object clone() throws CloneNotSupportedException {
		throw new CloneNotSupportedException();
	}
	
	/**
	 * Accesses the output file, read and build the data into {@code Task} objects.
	 * 
	 * @return   A {@code ArrayList} of {@code Tasks}
	 */
	public ArrayList<Task> readTasks() {
        ArrayList<Task> tasks = null;
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(filePath));
            Gson gson = new GsonBuilder().create();
            tasks = gson.fromJson(reader,
                    new TypeToken<ArrayList<Task>>() {
                    }.getType());
            reader.close();
            
            if (tasks.isEmpty()) {
                logger.log(Level.INFO, fileName + " is empty.");
                throw new Exception("Empty file");
            }
            logger.log(Level.INFO,"Successfully read tasks from: " + fileName);
        } catch (Exception e) {
            tasks = new ArrayList<Task>();
            logger.log(Level.INFO,"Return empty list.");
        }
        assert(tasks != null);
        return tasks;
    }
	
	/**
	 * This method takes in an {@code ArrayList} of {@code Tasks} and writes
	 * them into the output file.
	 * 
	 * @param  tasks
	 *         The {@code ArrayList} of {@code Tasks} to write
	 */
    public void writeTasks(ArrayList<Task> tasks) {
        try (Writer writer = new OutputStreamWriter(new FileOutputStream(
                filePath), "UTF-8")) {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            gson.toJson(tasks, writer);
            logger.log(Level.INFO,"Saved tasks to: " + fileName);
        } catch (Exception e) {
            logger.log(Level.INFO,"Corrupted file location: " + filePath);
            setFileLocation(DEFAULT_FILE_NAME);
            writeTasks(tasks);
        }
        assert((new File(filePath)).exists());
    }
	
	private String getDefaultFilePath() {
	    String path = null;
		if (isWindows()) {
			path = String.format(FILE_PATH_FORMAT,USER_DIR,WINDOWS_DIR_SYMBOL,DEFAULT_FILE_NAME);
        } else if (isMac()) {
        	path = String.format(FILE_PATH_FORMAT,USER_DIR,MAC_DIR_SYMBOL,DEFAULT_FILE_NAME);
        } else if (isUnix()) {
        	path = String.format(FILE_PATH_FORMAT,USER_DIR,UNIX_DIR_SYMBOL,DEFAULT_FILE_NAME);
        } else if (isSolaris()) {
        	path = String.format(FILE_PATH_FORMAT,USER_DIR,SOLARIS_DIR_SYMBOL,DEFAULT_FILE_NAME);
        } else {
            path = String.format(FILE_PATH_FORMAT,USER_DIR,UNIX_DIR_SYMBOL,DEFAULT_FILE_NAME);
            logger.log(Level.INFO,"OS not detected, assume UNIX OS");
        }
		assert(path != null);
		return path;
	}
	
	/**
	 * This methods updates file path and stores it in the settings file.
	 * The settings file can be found in the application folder, settings.txt.
	 * 
	 * @param  path
	 *         The path to save the output file
	 * @param  tasks
	 *         The {@code ArrayList} of {@code Task} to write to the new path
	 */
	public void setFileLocation(String path) {
	    updateFileDetails(path);
	    try(PrintWriter out = new PrintWriter(USER_SETTINGS)){
            out.print(path);
            out.close();
            logger.log(Level.INFO,"Updated user settings with: " + path);
        } catch (Exception e) {
        	logger.log(Level.WARNING,"Failed to write " + path + " to settings.txt.");
        }
	    assert((new File(USER_SETTINGS)).exists());
	    
	    File file = new File(path);
	    if (!file.exists()) {
	        try {
                file.createNewFile();
            } catch (IOException e) {
                logger.log(Level.WARNING,"Failed to create file " + path);
            }
	    }
	}
	
	private void updateFileDetails(String path) {
	    filePath = path;
	    if (isWindows()) {
	        fileDir = path.substring(0, path.lastIndexOf(WINDOWS_DIR_SYMBOL) + 1);
	        fileName = path.substring(path.lastIndexOf(WINDOWS_DIR_SYMBOL) + 1);
	    } else if (isMac()) {
	        fileDir = path.substring(0, path.lastIndexOf(MAC_DIR_SYMBOL) + 1);
	        fileName = path.substring(path.lastIndexOf(MAC_DIR_SYMBOL) + 1);
        } else if (isUnix()) {
            fileDir = path.substring(0, path.lastIndexOf(UNIX_DIR_SYMBOL) + 1);
            fileName = path.substring(path.lastIndexOf(UNIX_DIR_SYMBOL) + 1);
        } else if (isSolaris()) {
            fileDir = path.substring(0, path.lastIndexOf(SOLARIS_DIR_SYMBOL) + 1);
            fileName = path.substring(path.lastIndexOf(SOLARIS_DIR_SYMBOL) + 1);
        } else {
            fileDir = USER_DIR;
            fileName = DEFAULT_FILE_NAME;
        }
	    assert(filePath != null);
	    assert(fileDir != null);
	    assert(fileName != null);
	}
	
	/**
	 * This method returns the current path of the output file.
	 * 
	 * @return   A {@code String} indicating the file path
	 */
	public String getFileDir() {
	    return fileDir;
	}
	
	public String getFilePath() {
	    return filePath;
	}
	
	private void readUserSettings() {
	    try {
            Scanner sc = new Scanner(new File(USER_SETTINGS));
            String path = sc.nextLine().trim();
            sc.close();
            logger.log(Level.INFO,"Read file location from settings.txt: " + path);
            if (validFilePath(path)) {
                updateFileDetails(path);
                logger.log(Level.INFO,"Valid file location: " + path);
            } else {
                logger.log(Level.INFO,"Invalid file location: " + path);
                throw new InvalidPathException(path, "Invalid file location");
            }
        } catch (Exception e) {
            fileName = DEFAULT_FILE_NAME;
            logger.log(Level.INFO,USER_SETTINGS + " not found.");
            setFileLocation(getDefaultFilePath());
            readUserSettings();
        }
	    assert(fileName != null);
	}
	
	private boolean validFilePath(String path) {
        File file = new File(path);
        return file.exists();
	}
	
	private boolean isWindows() {
		return (OS.contains("win"));
	}
	
	private boolean isMac() {
		return (OS.contains("mac"));
	}
	
	private boolean isUnix() {
		return (OS.contains("nix") || OS.contains("nux") || OS.contains("aix"));
	}
	
	private boolean isSolaris() {
		return (OS.contains("sunos"));
	}

}
```
###### /src/test/TestLogic.java
``` java

/** 
 * How to use the logic component:
 * 1. get an instance of invoker and receiver
 *      Invoker invoker = new Invoker();
        Receiver receiver = Receiver.getReceiver();
 * 2. create command objects with receiver and task as parameters
 *      Command add = new AddCommand(receiver, task);
 * 3. use the invoker to execute the command object
 *      invoker.execute(add);
 *      
 * Short form: invoker.execute(new AddCommand(receiver, task));
 * 
 * Observer pattern: example of update() can be found at the last method
 * 
 * Available commands:
 * AddCommand(Task task);
 * DeleteCommand(Task task);
 * DeleteCommand(ArrayList<Task> tasks);
 * EditCommand(Task oldTask, Task newTask);
 * DoneCommand(Task task);
 * DoneCommand(ArrayList<Task> tasks);
 * UndoneCommand(Task task);
 * UndoneCommand(ArrayList<Task> tasks);
 * SetFileLocationCommand(String newLocation);
 * 
 * To get the tasks before the observer pattern is up,
 * getTodoTasks();
 * getCompletedTasks();
 * 
 */

/**
 * @author Bevin Seetoh Jia Jin
 *
 */

package test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.EmptyStackException;
import java.util.Observable;
import java.util.Observer;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import main.data.Task;
import main.logic.AddCommand;
import main.logic.Command;
import main.logic.DeleteCommand;
import main.logic.DoneCommand;
import main.logic.EditCommand;
import main.logic.Invoker;
import main.logic.PriorityCommand;
import main.logic.Receiver;
import main.logic.SearchCommand;
import main.logic.SetFileLocationCommand;
import main.logic.UndoneCommand;
import main.parser.CommandParser;
import main.storage.Storage;

public class TestLogic implements Observer {
	CommandParser parser;
	Receiver receiver;
	Invoker invoker;
	Observer observer;
	ArrayList<Task> todo = new ArrayList<Task>();
	ArrayList<Task> completed = new ArrayList<Task>();
	
	ArrayList<Task> originalTasks = new ArrayList<Task>();
	String originalFilePath;
	
	String test = "test.txt";
	
	/*
	 * Creates a test.txt file to be used for each test case
	 */
	@Before
    public void initialize() {
        parser = new CommandParser();
        invoker = new Invoker();
        receiver = Receiver.getInstance();
        receiver.addObserver(this);
        
        if (originalFilePath == null) {
            originalFilePath = receiver.getFilePath();
            originalTasks.addAll(receiver.getAllTasks());
        }
        
        receiver.setAllTasks(new ArrayList<Task>());
        invoker.execute(new SetFileLocationCommand(receiver, test));
    }
	
	/*
     * Deletes the test.txt file after each test case
     */
	@After
	public void removeTestFile() {
	    receiver.setAllTasks(originalTasks);
	    invoker.execute(new SetFileLocationCommand(receiver, originalFilePath));
	    
	    File testFile = new File(test);
	    if (testFile.exists()) {
	        testFile.delete();
	    }
	}
	
	/* 
	 * This is a system test.
	 * Tests the basic commands that handles single tasks
	 * with their respective undo/redo methods.
	 */
	@Test
	public void singleTaskTest() {
	    Task exampleTask = new Task("example");
        Task editedTask = new Task("edited task");
        
        invoker.execute(new AddCommand(receiver, exampleTask));
        assertEquals(exampleTask, todo.get(0));
        
        invoker.undo();
        assertTrue(todo.isEmpty());
        
        invoker.redo();
        assertEquals(exampleTask, todo.get(0));
        
        invoker.execute(new EditCommand(receiver, exampleTask, editedTask));
        assertEquals(editedTask, todo.get(0));
        
        invoker.undo();
        assertEquals(exampleTask, todo.get(0));
        
        invoker.redo();
        assertEquals(editedTask, todo.get(0));
        
        invoker.execute(new DoneCommand(receiver, editedTask));
        assertEquals(editedTask, completed.get(0));
        
        invoker.undo();
        assertEquals(editedTask, todo.get(0));
        
        invoker.redo();
        assertEquals(editedTask, completed.get(0));
        
        invoker.execute(new UndoneCommand(receiver, editedTask));
        assertEquals(editedTask, todo.get(0));
        
        invoker.undo();
        assertEquals(editedTask, completed.get(0));
        
        invoker.redo();
        assertEquals(editedTask, todo.get(0));
        
        invoker.execute(new DeleteCommand(receiver, editedTask));
        assertTrue(todo.isEmpty());
        
        invoker.undo();
        assertEquals(editedTask, todo.get(0));
        
        invoker.redo();  
        assertTrue(todo.isEmpty());
        
        invoker.undo();
        assertEquals(editedTask, todo.get(0));
        
        Storage storage = receiver.getStorage();
        ArrayList<Task> outputTasks = storage.readTasks();
        assertEquals(1, outputTasks.size());
        assertEquals(editedTask.getTitle(), outputTasks.get(0).getTitle());
	}
	
	/* 
	 * This is a system test.
     * Tests the basic commands that handles multiple tasks
     * with their respective undo/redo methods.
     */
	@Test
	public void multipleTasksTest() {
	    Task exampleTask = new Task("example");
        Task editedTask = new Task("edited task");
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(exampleTask);
        tasks.add(editedTask);
        
        invoker.execute(new AddCommand(receiver, exampleTask));
        invoker.execute(new AddCommand(receiver, editedTask));
        assertEquals(2, todo.size());
        assertEquals(0, completed.size());
        
        invoker.execute(new DoneCommand(receiver, tasks));
        assertEquals(0, todo.size());
        assertEquals(2, completed.size());
        
        invoker.undo();
        assertEquals(2, todo.size());
        assertEquals(0, completed.size());
        
        invoker.redo();
        assertEquals(0, todo.size());
        assertEquals(2, completed.size());
        
        invoker.execute(new UndoneCommand(receiver, tasks));
        assertEquals(2, todo.size());
        assertEquals(0, completed.size());
        
        invoker.undo();
        assertEquals(0, todo.size());
        assertEquals(2, completed.size());
        
        invoker.redo();
        assertEquals(2, todo.size());
        assertEquals(0, completed.size());
        
        invoker.execute(new DeleteCommand(receiver, tasks));
        assertTrue(todo.isEmpty());
        assertTrue(completed.isEmpty());
        
        invoker.undo();
        assertEquals(2, todo.size());
        assertEquals(0, completed.size());
        
        invoker.redo();
        assertEquals(0, todo.size());
        assertEquals(0, completed.size());
        
        invoker.undo();
        assertEquals(2, todo.size());
        assertEquals(0, completed.size());
        
        Storage storage = receiver.getStorage();
        ArrayList<Task> outputTasks = storage.readTasks();
        assertEquals(2, outputTasks.size());
        assertEquals(exampleTask.getTitle(), outputTasks.get(0).getTitle());
        assertEquals(editedTask.getTitle(), outputTasks.get(1).getTitle());
	}
	
	/*
	 * This is a system test.
	 * Tests the search command with strings.
	 * Search with one term, multiple terms, and with tag.
	 */
	@Test
	public void searchStringTest() {
	    try {
    	    Task task1 = parser.parseAdd("a b c #f");
    	    Task task2 = parser.parseAdd("a b c d");
    	    Task task3 = parser.parseAdd("a b c d #e");
    	    
    	    invoker.execute(new AddCommand(receiver, task1));
            invoker.execute(new AddCommand(receiver, task2));
            invoker.execute(new AddCommand(receiver, task3));
            assertEquals(3, todo.size());
            invoker.execute(new SearchCommand(receiver, ""));
            assertEquals(3, todo.size());
            invoker.execute(new SearchCommand(receiver, "a b c"));
            assertEquals(3, todo.size());
            invoker.execute(new SearchCommand(receiver, "b a"));
            assertEquals(0, todo.size());
            invoker.execute(new SearchCommand(receiver, "d"));
            assertEquals(2, todo.size());
            invoker.execute(new SearchCommand(receiver, "d #e"));
            assertEquals(1, todo.size());
            assertEquals(task3, todo.get(0));
            invoker.execute(new SearchCommand(receiver, ""));
            assertEquals(3, todo.size());
            
            Storage storage = receiver.getStorage();
            ArrayList<Task> outputTasks = storage.readTasks();
            assertEquals(3, outputTasks.size());
            assertEquals(task1.getTitle(), outputTasks.get(0).getTitle());
            assertEquals(task2.getTitle(), outputTasks.get(1).getTitle());
            assertEquals(task3.getTitle(), outputTasks.get(2).getTitle());
	    } catch (Exception e) {
	        e.printStackTrace();
	    }
	}
	
	/*
     * Tests the search command with date.
     */
    @Test
    public void searchDateTest() {
        try {
            Date today = new Date();
            Calendar calendar = Calendar.getInstance(); 
            calendar.setTime(today); 
            calendar.add(Calendar.DATE, 1);
            Date tomorrow = calendar.getTime();
            
            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
            Date fifthJune = sdf.parse("5/6/2099");
            
            Task task1 = parser.parseAdd("task1 by 11.59pm today");
            Task task2 = parser.parseAdd("task2 by 11.59pm");
            Task task3 = parser.parseAdd("task3 by tomorrow 11.59pm");
            Task task4 = parser.parseAdd("task4 by 5 june 2099 1pm");
            Task task5 = parser.parseAdd("task5 on 5 june 2099 at 1-2pm");
            
            invoker.execute(new AddCommand(receiver, task1));
            invoker.execute(new AddCommand(receiver, task2));
            invoker.execute(new AddCommand(receiver, task3));
            invoker.execute(new AddCommand(receiver, task4));
            invoker.execute(new AddCommand(receiver, task5));
            invoker.execute(new DoneCommand(receiver,task5));
            assertTrue(todo.size() == 4);
            
            invoker.execute(new SearchCommand(receiver, today));
            assertTrue(todo.size() == 2);
            
            invoker.execute(new SearchCommand(receiver, tomorrow));
            assertTrue(todo.size() == 1);
            assertEquals(task3, todo.get(0));
            
            invoker.execute(new SearchCommand(receiver, fifthJune));
            assertTrue(todo.size() == 1);
            assertTrue(completed.size() == 1);
            assertEquals(task4, todo.get(0));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
	
    /*
     * Tests the search command with key strings such as:
     * "this week", "next week", "upcoming", "someday", "deadline", "priority l/m/h"
     */
    @Test
    public void searchKeywordTest() {
        try {
            Task task1 = parser.parseAdd("task1 by 11.59pm today");
            Task task2 = parser.parseAdd("task2 at 10-11pm today");
            Task task3 = parser.parseAdd("task3 at 1-2pm today");
            Task task4 = parser.parseAdd("task4 next monday at 11pm");
            Task task5 = parser.parseAdd("task5 next monday 1-2pm");
            Task task6 = parser.parseAdd("task6 on 5 june 2099 at 11pm");
            Task task7 = parser.parseAdd("task7 on 5 june 2099 at 1-2pm");
            Task task8 = parser.parseAdd("no date");
            
            invoker.execute(new AddCommand(receiver, task1));
            invoker.execute(new AddCommand(receiver, task2));
            invoker.execute(new AddCommand(receiver, task3));
            invoker.execute(new AddCommand(receiver, task4));
            invoker.execute(new AddCommand(receiver, task5));
            invoker.execute(new AddCommand(receiver, task6));
            invoker.execute(new AddCommand(receiver, task7));
            invoker.execute(new AddCommand(receiver, task8));
            invoker.execute(new PriorityCommand(receiver, task5));
            invoker.execute(new PriorityCommand(receiver, task6));
            invoker.execute(new PriorityCommand(receiver, task6));
            invoker.execute(new PriorityCommand(receiver, task7));
            invoker.execute(new PriorityCommand(receiver, task7));
            invoker.execute(new PriorityCommand(receiver, task7));
            assertTrue(todo.size() == 8);
            
            invoker.execute(new SearchCommand(receiver, "this week"));
            assertTrue(todo.size() == 3);
            
            invoker.execute(new SearchCommand(receiver, "next week"));
            assertTrue(todo.size() == 2);
            
            invoker.execute(new SearchCommand(receiver, "upcoming"));
            assertTrue(todo.size() == 4);
            
            invoker.execute(new SearchCommand(receiver, "someday"));
            assertTrue(todo.size() == 1);
            
            invoker.execute(new SearchCommand(receiver, "deadline"));
            assertTrue(todo.size() == 1);
            
            invoker.execute(new SearchCommand(receiver, "priority l"));
            assertTrue(todo.size() == 1);
            
            invoker.execute(new SearchCommand(receiver, "priority m"));
            assertTrue(todo.size() == 1);
            
            invoker.execute(new SearchCommand(receiver, "priority h"));
            assertTrue(todo.size() == 1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
	/*
	 * Tests the priority command
	 * Cycle through priority 0 to 3, then undo and redo
	 * Ensures boundary 0 and 3 not exceeded
	 */
	@Test
	public void priorityTest() {
	    Task task = new Task("test");
	    
	    invoker.execute(new AddCommand(receiver, task));
	    assertEquals(0, task.getPriority());
	    
	    invoker.execute(new PriorityCommand(receiver, task));
	    assertEquals(1, task.getPriority());
	    
	    invoker.execute(new PriorityCommand(receiver, task));
	    assertEquals(2, task.getPriority());
        
	    invoker.execute(new PriorityCommand(receiver, task));
        assertEquals(3, task.getPriority());
        
        invoker.execute(new PriorityCommand(receiver, task));
        assertEquals(0, task.getPriority());
        
        invoker.undo();
        assertEquals(3, task.getPriority());
        
        invoker.undo();
        assertEquals(2, task.getPriority());
        
        invoker.undo();
        assertEquals(1, task.getPriority());
        
        invoker.undo();
        assertEquals(0, task.getPriority());
        
        invoker.redo();
        assertEquals(1, task.getPriority());
        
        invoker.redo();
        assertEquals(2, task.getPriority());
        
        invoker.redo();
        assertEquals(3, task.getPriority());
        
        invoker.redo();
        assertEquals(0, task.getPriority());
	}
	
	/*
	 * Adds a mixture of all possible cases to test comparator
	 */
	@Test
	public void comparatorTest() {
	    try {
	        invoker.execute(new AddCommand(receiver, parser.parseAdd("floating")));
    	    invoker.execute(new DoneCommand(receiver, todo));
    	    invoker.execute(new AddCommand(receiver, parser.parseAdd("start date at 11am")));
    	    invoker.execute(new AddCommand(receiver, parser.parseAdd("end date by 1")));
    	    invoker.execute(new AddCommand(receiver, parser.parseAdd("floating")));
    	    invoker.execute(new AddCommand(receiver, parser.parseAdd("range date from 1am to 11pm today")));
    	    invoker.execute(new AddCommand(receiver, parser.parseAdd("range date from 11am to 10pm")));
    	    invoker.execute(new DoneCommand(receiver, todo.get(0)));
    	    while (!todo.isEmpty()) {
    	        invoker.execute(new DeleteCommand(receiver, todo.get(0)));
    	    }
    	    while (!completed.isEmpty()) {
                invoker.execute(new DeleteCommand(receiver, completed.get(0)));
            }
	    } catch (Exception e) {
	        e.printStackTrace();
	    }
	}
	
	/*
     * Tests the detection of tasks with overlapping timings
     */
    @Test
    public void timeCollisionTest() {
        try {
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Meet Tom for drinks at 1am")));
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Meet John for drinks at 1am")));
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Catch up with Jim at 1-2am")));
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Group discussion at 1-3am")));
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Buy snacks at 1.10am")));
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Call Jim at 3am")));
            invoker.execute(new AddCommand(receiver, parser.parseAdd("Submit report by 3am")));
            assertFalse(todo.get(0).getCollideWithPrev());
            assertTrue(todo.get(0).getCollideWithNext());
            assertTrue(todo.get(1).getCollideWithPrev());
            assertTrue(todo.get(1).getCollideWithNext());
            assertTrue(todo.get(2).getCollideWithPrev());
            assertTrue(todo.get(2).getCollideWithNext());
            assertTrue(todo.get(3).getCollideWithPrev());
            assertTrue(todo.get(3).getCollideWithNext());
            assertTrue(todo.get(4).getCollideWithPrev());
            assertFalse(todo.get(4).getCollideWithNext());
            assertFalse(todo.get(5).getCollideWithPrev());
            assertFalse(todo.get(5).getCollideWithNext());
            assertFalse(todo.get(6).getCollideWithPrev());
            assertFalse(todo.get(6).getCollideWithNext());

            while (!todo.isEmpty()) {
                invoker.execute(new DeleteCommand(receiver, todo.get(0)));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
	
	/*
	 * Tests set location command with undo and redo
	 */
	@Test
	public void setFilePathTest() {
	    assertNotNull(receiver.getFileDir());
	    String originalPath = receiver.getFilePath();
	    String test = "test2.txt";
	    File file = new File(test);
	    
	    Command setLocation = new SetFileLocationCommand(receiver, test);
	    invoker.execute(setLocation);
	    assertTrue(file.exists());
	    invoker.undo();
	    assertEquals(receiver.getFilePath(), originalPath);
	    invoker.redo();
	    assertEquals(receiver.getFilePath(), test);
	    invoker.undo();
	    assertEquals(receiver.getFilePath(), originalPath);
	    file.delete();
	}
	
	/*
     * Tests if getter methods are assigned 
     * when constructor is called.
     */
    @Test
    public void getMethodsTest() {
        assertNotNull(receiver.getAllTasks());
        assertNotNull(receiver.getTodoTasks());
        assertNotNull(receiver.getCompletedTasks());
    }
    
    /*
     * Test if CloneNotSupportedException is thrown.
     * Singleton classes do not support cloning.
     */
    @Test
    public void receiverCloneTest() {
        try {
            receiver.clone();
        } catch (CloneNotSupportedException e) {
            assertNotNull(e);
        }
    }
    
    /*
     * This is a boundary case for the undo stack
     * Undo until stack is empty, then undo when stack is empty.
     * Tests if the EmptyStackException is thrown.
     */
    @Test
    public void emptyUndoStackTest() {
        invoker.execute(new AddCommand(receiver, new Task("test task")));
        try {
            while (invoker.isUndoAvailable()) {
                invoker.undo();
            }
            assertFalse(invoker.isUndoAvailable());
            invoker.undo();
        } catch (EmptyStackException e) {
            assertNotNull(e);
        }
    }
    
    /*
     * This is a boundary case for the redo stack
     * Redo until stack is empty, then redo when stack is empty.
     * Tests if the EmptyStackException is thrown.
     */
    @Test
    public void emptyRedoStackTest() {
        Task task = new Task("test task");
        invoker.execute(new AddCommand(receiver, task));
        invoker.undo();
        try {
            while (invoker.isRedoAvailable()) {
                invoker.redo();
            }
            assertFalse(invoker.isRedoAvailable());
            invoker.redo();
        } catch (EmptyStackException e) {
            assertNotNull(e);
        }
    }
	
	/*
	 * Tests observer pattern update method
	 */
    @Override
    public void update(Observable o, Object arg) {
        if (o == receiver) {
            todo = receiver.getTodoTasks();
            completed = receiver.getCompletedTasks();
            assertNotNull(todo);
            assertNotNull(completed);
        }
    }
}
```
###### /src/test/TestStorage.java
``` java

/**
 * @author Bevin Seetoh Jia Jin
 *
 */

package test;

import static org.junit.Assert.*;

import java.io.File;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import main.data.Task;
import main.storage.Storage;

public class TestStorage {
    
    Storage storage;
    
    /*
     * Tests settings.txt exists but saved path is corrupted
     */
    @Test
    public void readUserSettingsTest() {
        String testPath = "storageTest.txt";
        String originalPath = storage.getFilePath();
        ArrayList<Task> originalTasks = storage.readTasks();
        
        storage.setFileLocation(testPath);
        File file = new File(testPath);
        assertTrue(file.exists());
        file.delete();
        
        storage.setFileLocation(originalPath);
        ArrayList<Task> newTasks = storage.readTasks();
        assertEquals(newTasks.size(), originalTasks.size());
    }
    
    /*
     * Test if CloneNotSupportedException is thrown.
     * Singleton classes do not support cloning.
     */
    @Test
    public void storageCloneTest() {
        try {
            storage.clone();
        } catch (CloneNotSupportedException e) {
        }
    }
    
    /*
     * This is a boundary case for writing task.
     * Add zero task.
     * Add one task.
     */
    @Test
    public void readWriteTest() {
        ArrayList<Task> tasks = new ArrayList<Task>();
        storage.writeTasks(tasks);
        assertNotNull(storage.readTasks());
        
        tasks.add(new Task("test"));
        storage.writeTasks(tasks);
        assertNotNull(storage.readTasks());
        storage.writeTasks(new ArrayList<Task>());
    }
    
    /*
     * Tests if there is a file path even if settings.txt 
     * is deleted in @Before.
     */
    @Test
    public void readFilePath() {
        assertNotNull(storage.getFileDir());
    }
    
    /*
     * Tests if settings.txt does not exist
     */
    @Before
    public void initialize() {
        File file = new File("settings.txt");
        if (file.exists()) {
            file.delete();
        }
        storage = Storage.getInstance();
    }

}
```
