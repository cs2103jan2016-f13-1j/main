# A0126400Y
###### /bin/main/resources/layouts/HelpPage.fxml
``` fxml
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.StackPane?>

<fx:root type="javafx.scene.layout.StackPane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">

<ImageView pickOnBounds="true" preserveRatio="true" >
   <image>
      <Image url="@../images/help_page.png" />
   </image>
</ImageView>

</fx:root>
```
###### /bin/main/resources/layouts/ListCellHeaderLayout.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.text.Font?>

<fx:root fx:id="headerTitle" maxWidth="1.7976931348623157E308" minHeight="60.0" prefHeight="60.0" prefWidth="700.0" style="-fx-background-color: #FFFFFF; -fx-border-radius: 4 4 4 4; -fx-background-radius: 4 4 4 4; -fx-border-style: solid inside; -fx-border-width: 0.5; -fx-border-color: rgba(00,00,00,0.24);" text="Today" type="javafx.scene.control.Label" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
   <font>
      <Font name="Noto Sans" size="18.0" />
   </font>
   <padding>
      <Insets left="20.0" />
   </padding>
</fx:root>
```
###### /bin/main/resources/layouts/ListCellLayout.fxml
``` fxml
<?import com.jfoenix.controls.JFXButton?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.shape.Circle?>
<?import javafx.scene.shape.Line?>
<?import javafx.scene.shape.Rectangle?>
<?import javafx.scene.text.Font?>

<HBox fx:id="horizontalBox" alignment="CENTER_LEFT" minHeight="60.0" nodeOrientation="LEFT_TO_RIGHT" prefHeight="60.0" prefWidth="700.0" spacing="20.0" stylesheets="@../styles/CustomListCellLayout.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <JFXButton fx:id="labelTaskTime" cacheHint="SPEED" maxWidth="160.0" minWidth="160.0" prefHeight="40.0" prefWidth="160.0" text="12pm - 12pm" textAlignment="CENTER">
         <font>
            <Font name="Noto Sans" size="18.0" />
         </font>
         <HBox.margin>
            <Insets left="-7.0" />
         </HBox.margin>
      </JFXButton>
      <StackPane cacheHint="SPEED" minHeight="60.0">
         <children>
            <Line fx:id="topLine" startY="40.0" stroke="#0000001f" StackPane.alignment="TOP_CENTER" />
            <Line fx:id="bottomLine" endY="39.0" startY="1.0" stroke="#0000001f" StackPane.alignment="BOTTOM_CENTER" />
            <Circle fx:id="circleIndex" fill="WHITE" radius="18.0" stroke="#979797" strokeType="INSIDE" />
            <Label fx:id="labelTaskIndex" contentDisplay="CENTER" text="999" textAlignment="CENTER">
               <font>
                  <Font name="Noto Sans" size="16.0" />
               </font>
            </Label>
         </children>
      </StackPane>
      <VBox fx:id="verticalBox" alignment="CENTER_LEFT" cacheHint="SPEED">
         <children>
            <Label fx:id="labelTaskTitle" text="Appointment with boss tyson">
               <font>
                  <Font name="Noto Sans" size="18.0" />
               </font>
            </Label>
            <Label fx:id="labelTaskDate" minWidth="140.0" text="21 March - 22 March" textFill="#0000008a">
               <font>
                  <Font name="Noto Sans" size="14.0" />
               </font>
            </Label>
         </children>
      </VBox>
      <StackPane alignment="BOTTOM_RIGHT" cacheHint="SPEED" prefWidth="155.0" HBox.hgrow="ALWAYS">
         <children>
            <Rectangle fx:id="rectangleTaskPriority" fill="#ff6f1f" height="60.0" stroke="TRANSPARENT" strokeType="INSIDE" width="14.0" />
            <Label fx:id="labelTaskLabel" alignment="CENTER" minWidth="86.0" prefHeight="24.0" style="-fx-background-color: TRANSPARENT; -fx-border-radius: 4 4 4 4; -fx-background-radius: 4 4 4 4; -fx-border-color: #303F9F; -fx-border-width: 1.5;" text="Work" textFill="#303f9f">
               <font>
                  <Font name="Noto Sans" size="14.0" />
               </font>
               <StackPane.margin>
                  <Insets bottom="12.0" right="42.0" />
               </StackPane.margin>
            </Label>
         </children>
      </StackPane>
   </children>
   <padding>
      <Insets bottom="20.0" left="30.0" top="20.0" />
   </padding>
</HBox>
```
###### /bin/main/resources/layouts/RootLayout.fxml
``` fxml
<?import com.jfoenix.controls.JFXButton?>
<?import com.jfoenix.controls.JFXListView?>
<?import com.jfoenix.controls.JFXTabPane?>
<?import com.jfoenix.controls.JFXTextField?>
<?import com.jfoenix.controls.JFXDialog?>
<?import java.lang.String?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.Group?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Tab?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>
<?import javafx.scene.text.TextFlow?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.shape.Circle?>
<?import javafx.scene.shape.SVGPath?>
<?import main.ui.ListViewController?>


<StackPane fx:id="dialogContainer" prefHeight="1000.0" prefWidth="860.0" xmlns="http://javafx.com/javafx/8.0.65"
   xmlns:fx="http://javafx.com/fxml/1" fx:controller="main.ui.RootLayoutController">

<AnchorPane fx:id="rootLayout" cacheHint="SPEED" prefHeight="1080.0"
	prefWidth="860.0" stylesheets="@../styles/RootLayout.css"  >
		<children>
<BorderPane fx:id="toolbar" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="80.0" prefWidth="860.0" style="-fx-background-color: #303F9F;" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
   <left>
      <Label fx:id="labelAppTitle" alignment="CENTER" text="Dooleh" textFill="WHITE" BorderPane.alignment="CENTER_LEFT">
         <font>
            <Font name="Noto Sans" size="24.0" />
         </font>
      </Label>
   </left>
   <right>
      <HBox alignment="CENTER_RIGHT" BorderPane.alignment="CENTER">
         <children>
            <JFXButton fx:id="buttonUndo" prefHeight="75.0" prefWidth="75.0">
               <graphic>
                  <SVGPath fx:id="iconUndo" content="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" fill="#ffffff66" scaleX="1.3" scaleY="1.3" scaleZ="1.3" />
               </graphic>
            </JFXButton>
            <JFXButton fx:id="buttonRedo" prefHeight="75.0" prefWidth="75.0">
               <graphic>
                  <SVGPath fx:id="iconRedo" content="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z" fill="#ffffff66" scaleX="1.3" scaleY="1.3" scaleZ="1.3" />
               </graphic>
            </JFXButton>
            <JFXButton fx:id="buttonHelp" prefHeight="75.0" prefWidth="75.0">
               <graphic>
                  <SVGPath fx:id="iconHelp" content="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z" fill="WHITE" scaleX="1.3" scaleY="1.3" scaleZ="1.3" />
               </graphic>
            </JFXButton>
         </children>
      </HBox>
   </right>
   <padding>
      <Insets left="20.0" />
   </padding>
</BorderPane>
		</children>
	<children>
		<JFXTabPane fx:id="tabPane" cacheHint="SPEED" tabMinHeight="48.0"
			tabMinWidth="420.0" AnchorPane.bottomAnchor="0.0"
			AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0"
			AnchorPane.topAnchor="80.0">
			<tabs>
				<Tab fx:id="tabTodo" closable="false" text="To-do">
					<content>
					<ListViewController fx:id="todoListViewController"/>
					</content>
				</Tab>
				<Tab fx:id="tabCompleted" closable="false" text="Completed">
					<content>
						<ListViewController fx:id="completedListViewController"/>
					</content>
				</Tab>
			</tabs>
		</JFXTabPane>
		<JFXTextField fx:id="commandBar" cacheHint="SPEED"
			prefHeight="48.0" promptText="Schedule a meeting with boss" style="-fx-prompt-text-fill: #808080;"
			AnchorPane.bottomAnchor="20.0" AnchorPane.leftAnchor="20.0"
			AnchorPane.rightAnchor="20.0">
			<font>
				<Font name="Noto Sans" size="18.0" />
			</font>
		</JFXTextField>
		<JFXButton fx:id="chipSearchMode" style="-fx-background-color: #4CAF50;"
			textFill="WHITE" visible="false" AnchorPane.bottomAnchor="30.0"
			AnchorPane.leftAnchor="30.0">
			<font>
				<Font name="Noto Sans" size="14.0" />
			</font>
		</JFXButton>

		<JFXButton fx:id="btnFeedback" alignment="CENTER"
			buttonType="RAISED" cacheHint="SPEED" layoutY="796.0" prefHeight="48.0"
			style="-fx-background-color: white;" visible="false"
			AnchorPane.bottomAnchor="70.0" AnchorPane.leftAnchor="20.0"
			AnchorPane.rightAnchor="20.0">
			<font>
				<Font name="Noto Sans" size="13.0" />
			</font>
			<graphic>
				<Group fx:id="groupFeedback">
					<children>
						<TextFlow fx:id="textFlowFeedback">
							<children>
								<Text fx:id="textUserAction" strokeType="OUTSIDE"
									strokeWidth="0.0" text="User action:">
									<font>
										<Font name="Noto Sans" size="20.0" />
									</font>
								</Text>
								<Text fx:id="textUserParsedResult" strokeType="OUTSIDE"
									strokeWidth="0.0" text="Parsed feedback">
									<font>
										<Font size="20.0" />
									</font>
								</Text>
							</children>
						</TextFlow>
					</children>
				</Group>
			</graphic>
		</JFXButton>
	</children>

	<children>
		<HBox alignment="CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="100.0" prefWidth="860.0" spacing="60.0" style="-fx-background-color: #FFFFFF;"
			AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0"
			AnchorPane.topAnchor="130.0">
   <children>
   	  <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="OVERDUE" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane prefWidth="102.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksOverdue" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER" StackPane.alignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="TODAY" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font></Label>
            <StackPane prefWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksToday" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER" StackPane.alignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label text="TOMORROW" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane maxWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksTomorrow" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="UPCOMING" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane prefWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksUpcoming" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="SOMEDAY" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane prefWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksSomeday" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER" StackPane.alignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
   </children>
</HBox>
	</children>
	<children>
		<AnchorPane fx:id="anchorPaneExecutionResult" opacity="0.0"
			style="-fx-background-color: #323232e5;" AnchorPane.bottomAnchor="108.0"
			AnchorPane.leftAnchor="40.0" AnchorPane.rightAnchor="40.0">
			<children>
				<Label fx:id="labelExecutedCommand" layoutX="10.0" layoutY="10.0"
					text="Deleted:" textAlignment="RIGHT" textFill="#c5cae9"
					AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
					AnchorPane.topAnchor="0.0">
					<font>
						<Font name="Noto Sans" size="16.0" />
					</font>
				</Label>
				<Label fx:id="labelExecutionDetails" layoutX="190.0"
					prefHeight="58.0" prefWidth="490.0"
					text="this is a verrrrry long text this is a verrrrry long text this is a verrrrry long text this is a verrrrry long text"
					textFill="WHITE" AnchorPane.bottomAnchor="0.0"
					AnchorPane.leftAnchor="70.0" AnchorPane.rightAnchor="100.0"
					AnchorPane.topAnchor="0.0">
					<font>
						<Font name="Noto Sans" size="16.0" />
					</font>
				</Label>
				<Label fx:id="labelSuggestedAction" layoutX="714.0"
					prefHeight="58.0" text="UNDO (F1)" textFill="#ffc107"
					AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0"
					AnchorPane.topAnchor="0.0">
					<font>
						<Font name="Noto Sans" size="16.0" />
					</font>
				</Label>
			</children>
			<padding>
				<Insets left="60.0" right="60.0" />
			</padding>
		</AnchorPane>
	</children>
</AnchorPane>

<JFXDialog fx:id="dialogHelp"></JFXDialog>

</StackPane>
```
###### /bin/main/resources/layouts/TaskListView.fxml
``` fxml
<?import java.lang.String?>
<?import javafx.scene.layout.AnchorPane?>
<?import com.jfoenix.controls.JFXListView?>
<?import javafx.geometry.Insets?>

<fx:root type="javafx.scene.layout.AnchorPane" cacheHint="SPEED" stylesheets="@../styles/RootLayout.css" xmlns="http://javafx.com/javafx/8.0.65"
	xmlns:fx="http://javafx.com/fxml/1" >
	<children>
		<JFXListView fx:id="listView" cacheHint="SPEED"
			layoutY="89.0" stylesheets="@../styles/RootLayout.css"
			AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
			AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
			<styleClass>
				<String fx:value="decrement-arrow" />
				<String fx:value="increment-arrow" />
				<String fx:value="decrement-button" />
				<String fx:value="increment-button" />
				<String fx:value="jfx-list-view" />
				<String fx:value="scroll-bar" />
				<String fx:value="thumb" />
				<String fx:value="track" />
			</styleClass>
		</JFXListView>
	</children>
	<padding>
		<Insets bottom="88.0" left="20.0" right="20.0" top="123.0" />
	</padding>
</fx:root>
```
###### /bin/main/resources/styles/CustomListCellLayout.css
``` css
.jfx-button {
	-fx-text-alignment: center;
	-fx-text-fill: white;
	-fx-background-color: #4CAF50;
}
```
###### /bin/main/resources/styles/RootLayout.css
``` css

.jfx-tab-pane {
	-fx-background-color: #E6E6E6;
}
.jfx-tab-pane .tab-header-area .tab-header-background {
	-fx-background-color: #303F9F;
}
.jfx-tab-pane .tab-header-area .tab {
	
}
.jfx-tab-pane .tab-header-area .headers-region .tab-selected-line {
	-fx-stroke: #FFFFFF;
}

.jfx-text-field {

	-fx-focus-color: #FFFFFF;
    -fx-unfocus-color: #303F9F;
}

.jfx-list-view .scroll-bar:horizontal .track,
.jfx-list-view .scroll-bar:vertical .track {
	-fx-background-color:transparent;
-fx-border-color:transparent;
-fx-background-radius: 0.0em;
-fx-border-radius:0em;
}

.jfx-list-view .scroll-bar:horizontal .increment-button ,
.jfx-list-view .scroll-bar:horizontal .decrement-button {
-fx-background-color:transparent;
-fx-background-radius: 0.0em;
-fx-padding:0.0 0.0 0.0 0.0;
}

.jfx-list-view .scroll-bar:vertical .increment-button ,
.jfx-list-view .scroll-bar:vertical .decrement-button {
-fx-background-color:transparent;
-fx-background-radius: 0.0em;
-fx-padding:0.0 0.0 0.0 0.0;
}
.jfx-list-view .scroll-bar .increment-arrow,
.jfx-list-view .scroll-bar .decrement-arrow{
-fx-shape:"";
-fx-padding:0.0;
}

.jfx-list-view .scroll-bar:horizontal .thumb,
.jfx-list-view .scroll-bar:vertical .thumb {
-fx-background-color:transparent;
-fx-background-insets: 0.0, 0.0, 0.0;
-fx-background-radius: 0.0em;
}

.list-cell {
    -fx-background-color: #FAFAFA
}

.list-cell:odd {
    -fx-background-color: #FAFAFA;
}

.list-cell:filled:selected:focused, .list-cell:filled:selected, .list-view:horizontal .list-cell:filled:selected {
    -fx-background-color: lightgray;
    -fx-text-fill: -fx-selection-bar-text;
}
```
###### /src/main/data/TaskHeader.java
``` java
package main.data;

public class TaskHeader extends Task {
    public static final int CELL_OFFSET_TODAY = 1;
    public static final int CELL_OFFSET_TOMORROW = 2;
    public static final int CELL_OFFSET_UPCOMING = 3;
    public static final int CELL_OFFSET_SOMEDAY = 4;
    private String title;
    private Type headerType;

    public enum Type {
        TODAY, TOMORROW, UPCOMING, SOMEDAY, OVERDUE
    }

    public TaskHeader(String headerTitle) {
        this.title = headerTitle;

        switch (headerTitle.toLowerCase()) {
            case "today" :
                headerType = Type.TODAY;
                break;
            case "tomorrow" :
                headerType = Type.TOMORROW;
                break;
            case "upcoming" :
                headerType = Type.UPCOMING;
                break;
            case "someday" :
                headerType = Type.SOMEDAY;
                break;
            case "overdue" :
                headerType = Type.OVERDUE;
                break;
            default: // TODO
        }
    }

    public String getTitle() {
        return this.title;
    }

    public Type getType() {
        return headerType;
    }

    @Override
    public String toString() {
        return this.title;
    }

}
```
###### /src/main/resources/layouts/HelpPage.fxml
``` fxml
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.StackPane?>

<fx:root type="javafx.scene.layout.StackPane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">

<ImageView pickOnBounds="true" preserveRatio="true" >
   <image>
      <Image url="@../images/help_page.png" />
   </image>
</ImageView>

</fx:root>
```
###### /src/main/resources/layouts/ListCellHeaderLayout.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.text.Font?>

<fx:root fx:id="headerTitle" maxWidth="1.7976931348623157E308" minHeight="60.0" prefHeight="60.0" prefWidth="700.0" style="-fx-background-color: #FFFFFF; -fx-border-radius: 4 4 4 4; -fx-background-radius: 4 4 4 4; -fx-border-style: solid inside; -fx-border-width: 0.5; -fx-border-color: rgba(00,00,00,0.24);" text="Today" type="javafx.scene.control.Label" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
   <font>
      <Font name="Noto Sans" size="18.0" />
   </font>
   <padding>
      <Insets left="20.0" />
   </padding>
</fx:root>
```
###### /src/main/resources/layouts/ListCellLayout.fxml
``` fxml
<?import com.jfoenix.controls.JFXButton?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.shape.Circle?>
<?import javafx.scene.shape.Line?>
<?import javafx.scene.shape.Rectangle?>
<?import javafx.scene.text.Font?>

<HBox fx:id="horizontalBox" alignment="CENTER_LEFT" minHeight="60.0" nodeOrientation="LEFT_TO_RIGHT" prefHeight="60.0" prefWidth="700.0" spacing="20.0" stylesheets="@../styles/CustomListCellLayout.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <JFXButton fx:id="labelTaskTime" cacheHint="SPEED" maxWidth="160.0" minWidth="160.0" prefHeight="40.0" prefWidth="160.0" text="12pm - 12pm" textAlignment="CENTER">
         <font>
            <Font name="Noto Sans" size="18.0" />
         </font>
         <HBox.margin>
            <Insets left="-7.0" />
         </HBox.margin>
      </JFXButton>
      <StackPane cacheHint="SPEED" minHeight="60.0">
         <children>
            <Line fx:id="topLine" startY="40.0" stroke="#0000001f" StackPane.alignment="TOP_CENTER" />
            <Line fx:id="bottomLine" endY="39.0" startY="1.0" stroke="#0000001f" StackPane.alignment="BOTTOM_CENTER" />
            <Circle fx:id="circleIndex" fill="WHITE" radius="18.0" stroke="#979797" strokeType="INSIDE" />
            <Label fx:id="labelTaskIndex" contentDisplay="CENTER" text="999" textAlignment="CENTER">
               <font>
                  <Font name="Noto Sans" size="16.0" />
               </font>
            </Label>
         </children>
      </StackPane>
      <VBox fx:id="verticalBox" alignment="CENTER_LEFT" cacheHint="SPEED">
         <children>
            <Label fx:id="labelTaskTitle" text="Appointment with boss tyson">
               <font>
                  <Font name="Noto Sans" size="18.0" />
               </font>
            </Label>
            <Label fx:id="labelTaskDate" minWidth="140.0" text="21 March - 22 March" textFill="#0000008a">
               <font>
                  <Font name="Noto Sans" size="14.0" />
               </font>
            </Label>
         </children>
      </VBox>
      <StackPane alignment="BOTTOM_RIGHT" cacheHint="SPEED" prefWidth="155.0" HBox.hgrow="ALWAYS">
         <children>
            <Rectangle fx:id="rectangleTaskPriority" fill="#ff6f1f" height="60.0" stroke="TRANSPARENT" strokeType="INSIDE" width="14.0" />
            <Label fx:id="labelTaskLabel" alignment="CENTER" minWidth="86.0" prefHeight="24.0" style="-fx-background-color: TRANSPARENT; -fx-border-radius: 4 4 4 4; -fx-background-radius: 4 4 4 4; -fx-border-color: #303F9F; -fx-border-width: 1.5;" text="Work" textFill="#303f9f">
               <font>
                  <Font name="Noto Sans" size="14.0" />
               </font>
               <StackPane.margin>
                  <Insets bottom="12.0" right="42.0" />
               </StackPane.margin>
            </Label>
         </children>
      </StackPane>
   </children>
   <padding>
      <Insets bottom="20.0" left="30.0" top="20.0" />
   </padding>
</HBox>
```
###### /src/main/resources/layouts/RootLayout.fxml
``` fxml
<?import com.jfoenix.controls.JFXButton?>
<?import com.jfoenix.controls.JFXListView?>
<?import com.jfoenix.controls.JFXTabPane?>
<?import com.jfoenix.controls.JFXTextField?>
<?import com.jfoenix.controls.JFXDialog?>
<?import java.lang.String?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.Group?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Tab?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>
<?import javafx.scene.text.TextFlow?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.shape.Circle?>
<?import javafx.scene.shape.SVGPath?>
<?import main.ui.ListViewController?>


<StackPane fx:id="dialogContainer" prefHeight="1000.0" prefWidth="860.0" xmlns="http://javafx.com/javafx/8.0.65"
   xmlns:fx="http://javafx.com/fxml/1" fx:controller="main.ui.RootLayoutController">

<AnchorPane fx:id="rootLayout" cacheHint="SPEED" prefHeight="1080.0"
	prefWidth="860.0" stylesheets="@../styles/RootLayout.css"  >
		<children>
<BorderPane fx:id="toolbar" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="80.0" prefWidth="860.0" style="-fx-background-color: #303F9F;" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
   <left>
      <Label fx:id="labelAppTitle" alignment="CENTER" text="Dooleh" textFill="WHITE" BorderPane.alignment="CENTER_LEFT">
         <font>
            <Font name="Noto Sans" size="24.0" />
         </font>
      </Label>
   </left>
   <right>
      <HBox alignment="CENTER_RIGHT" BorderPane.alignment="CENTER">
         <children>
            <JFXButton fx:id="buttonUndo" prefHeight="75.0" prefWidth="75.0">
               <graphic>
                  <SVGPath fx:id="iconUndo" content="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" fill="#ffffff66" scaleX="1.3" scaleY="1.3" scaleZ="1.3" />
               </graphic>
            </JFXButton>
            <JFXButton fx:id="buttonRedo" prefHeight="75.0" prefWidth="75.0">
               <graphic>
                  <SVGPath fx:id="iconRedo" content="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z" fill="#ffffff66" scaleX="1.3" scaleY="1.3" scaleZ="1.3" />
               </graphic>
            </JFXButton>
            <JFXButton fx:id="buttonHelp" prefHeight="75.0" prefWidth="75.0">
               <graphic>
                  <SVGPath fx:id="iconHelp" content="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z" fill="WHITE" scaleX="1.3" scaleY="1.3" scaleZ="1.3" />
               </graphic>
            </JFXButton>
         </children>
      </HBox>
   </right>
   <padding>
      <Insets left="20.0" />
   </padding>
</BorderPane>
		</children>
	<children>
		<JFXTabPane fx:id="tabPane" cacheHint="SPEED" tabMinHeight="48.0"
			tabMinWidth="420.0" AnchorPane.bottomAnchor="0.0"
			AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0"
			AnchorPane.topAnchor="80.0">
			<tabs>
				<Tab fx:id="tabTodo" closable="false" text="To-do">
					<content>
					<ListViewController fx:id="todoListViewController"/>
					</content>
				</Tab>
				<Tab fx:id="tabCompleted" closable="false" text="Completed">
					<content>
						<ListViewController fx:id="completedListViewController"/>
					</content>
				</Tab>
			</tabs>
		</JFXTabPane>
		<JFXTextField fx:id="commandBar" cacheHint="SPEED"
			prefHeight="48.0" promptText="Schedule a meeting with boss" style="-fx-prompt-text-fill: #808080;"
			AnchorPane.bottomAnchor="20.0" AnchorPane.leftAnchor="20.0"
			AnchorPane.rightAnchor="20.0">
			<font>
				<Font name="Noto Sans" size="18.0" />
			</font>
		</JFXTextField>
		<JFXButton fx:id="chipSearchMode" style="-fx-background-color: #4CAF50;"
			textFill="WHITE" visible="false" AnchorPane.bottomAnchor="30.0"
			AnchorPane.leftAnchor="30.0">
			<font>
				<Font name="Noto Sans" size="14.0" />
			</font>
		</JFXButton>

		<JFXButton fx:id="btnFeedback" alignment="CENTER"
			buttonType="RAISED" cacheHint="SPEED" layoutY="796.0" prefHeight="48.0"
			style="-fx-background-color: white;" visible="false"
			AnchorPane.bottomAnchor="70.0" AnchorPane.leftAnchor="20.0"
			AnchorPane.rightAnchor="20.0">
			<font>
				<Font name="Noto Sans" size="13.0" />
			</font>
			<graphic>
				<Group fx:id="groupFeedback">
					<children>
						<TextFlow fx:id="textFlowFeedback">
							<children>
								<Text fx:id="textUserAction" strokeType="OUTSIDE"
									strokeWidth="0.0" text="User action:">
									<font>
										<Font name="Noto Sans" size="20.0" />
									</font>
								</Text>
								<Text fx:id="textUserParsedResult" strokeType="OUTSIDE"
									strokeWidth="0.0" text="Parsed feedback">
									<font>
										<Font size="20.0" />
									</font>
								</Text>
							</children>
						</TextFlow>
					</children>
				</Group>
			</graphic>
		</JFXButton>
	</children>

	<children>
		<HBox alignment="CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="100.0" prefWidth="860.0" spacing="60.0" style="-fx-background-color: #FFFFFF;"
			AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0"
			AnchorPane.topAnchor="130.0">
   <children>
   	  <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="OVERDUE" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane prefWidth="102.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksOverdue" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER" StackPane.alignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="TODAY" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font></Label>
            <StackPane prefWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksToday" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER" StackPane.alignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label text="TOMORROW" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane maxWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksTomorrow" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="UPCOMING" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane prefWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksUpcoming" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
      <StackPane prefHeight="100.0">
         <children>
            <Label alignment="CENTER" prefWidth="102.0" text="SOMEDAY" textFill="#3f51b5" StackPane.alignment="TOP_CENTER">
               <font>
                  <Font name="Noto Sans Bold" size="16.0" />
               </font>
            </Label>
            <StackPane prefWidth="60.0">
               <children>
                  <Circle fill="#3f51b5" radius="16.0" stroke="TRANSPARENT" strokeType="INSIDE" />
                  <Text fx:id="totalTasksSomeday" fill="WHITE" fontSmoothingType="LCD" strokeType="OUTSIDE" strokeWidth="0.0" text="999" textAlignment="CENTER" StackPane.alignment="CENTER">
                     <font>
                        <Font name="Noto Sans Bold" size="14.0" />
                     </font>
                  </Text>
               </children>
               <padding>
                  <Insets top="8.0" />
               </padding>
            </StackPane>
         </children>
         <padding>
            <Insets top="18.0" />
         </padding>
      </StackPane>
   </children>
</HBox>
	</children>
	<children>
		<AnchorPane fx:id="anchorPaneExecutionResult" opacity="0.0"
			style="-fx-background-color: #323232e5;" AnchorPane.bottomAnchor="108.0"
			AnchorPane.leftAnchor="40.0" AnchorPane.rightAnchor="40.0">
			<children>
				<Label fx:id="labelExecutedCommand" layoutX="10.0" layoutY="10.0"
					text="Deleted:" textAlignment="RIGHT" textFill="#c5cae9"
					AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
					AnchorPane.topAnchor="0.0">
					<font>
						<Font name="Noto Sans" size="16.0" />
					</font>
				</Label>
				<Label fx:id="labelExecutionDetails" layoutX="190.0"
					prefHeight="58.0" prefWidth="490.0"
					text="this is a verrrrry long text this is a verrrrry long text this is a verrrrry long text this is a verrrrry long text"
					textFill="WHITE" AnchorPane.bottomAnchor="0.0"
					AnchorPane.leftAnchor="70.0" AnchorPane.rightAnchor="100.0"
					AnchorPane.topAnchor="0.0">
					<font>
						<Font name="Noto Sans" size="16.0" />
					</font>
				</Label>
				<Label fx:id="labelSuggestedAction" layoutX="714.0"
					prefHeight="58.0" text="UNDO (F1)" textFill="#ffc107"
					AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0"
					AnchorPane.topAnchor="0.0">
					<font>
						<Font name="Noto Sans" size="16.0" />
					</font>
				</Label>
			</children>
			<padding>
				<Insets left="60.0" right="60.0" />
			</padding>
		</AnchorPane>
	</children>
</AnchorPane>

<JFXDialog fx:id="dialogHelp"></JFXDialog>

</StackPane>
```
###### /src/main/resources/layouts/TaskListView.fxml
``` fxml
<?import java.lang.String?>
<?import javafx.scene.layout.AnchorPane?>
<?import com.jfoenix.controls.JFXListView?>
<?import javafx.geometry.Insets?>

<fx:root type="javafx.scene.layout.AnchorPane" cacheHint="SPEED" stylesheets="@../styles/RootLayout.css" xmlns="http://javafx.com/javafx/8.0.65"
	xmlns:fx="http://javafx.com/fxml/1" >
	<children>
		<JFXListView fx:id="listView" cacheHint="SPEED"
			layoutY="89.0" stylesheets="@../styles/RootLayout.css"
			AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
			AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
			<styleClass>
				<String fx:value="decrement-arrow" />
				<String fx:value="increment-arrow" />
				<String fx:value="decrement-button" />
				<String fx:value="increment-button" />
				<String fx:value="jfx-list-view" />
				<String fx:value="scroll-bar" />
				<String fx:value="thumb" />
				<String fx:value="track" />
			</styleClass>
		</JFXListView>
	</children>
	<padding>
		<Insets bottom="88.0" left="20.0" right="20.0" top="123.0" />
	</padding>
</fx:root>
```
###### /src/main/resources/styles/CustomListCellLayout.css
``` css
.jfx-button {
	-fx-text-alignment: center;
	-fx-text-fill: white;
	-fx-background-color: #4CAF50;
}
```
###### /src/main/resources/styles/RootLayout.css
``` css

.jfx-tab-pane {
	-fx-background-color: #E6E6E6;
}
.jfx-tab-pane .tab-header-area .tab-header-background {
	-fx-background-color: #303F9F;
}
.jfx-tab-pane .tab-header-area .tab {
	
}
.jfx-tab-pane .tab-header-area .headers-region .tab-selected-line {
	-fx-stroke: #FFFFFF;
}

.jfx-text-field {

	-fx-focus-color: #FFFFFF;
    -fx-unfocus-color: #303F9F;
}

.jfx-list-view .scroll-bar:horizontal .track,
.jfx-list-view .scroll-bar:vertical .track {
	-fx-background-color:transparent;
-fx-border-color:transparent;
-fx-background-radius: 0.0em;
-fx-border-radius:0em;
}

.jfx-list-view .scroll-bar:horizontal .increment-button ,
.jfx-list-view .scroll-bar:horizontal .decrement-button {
-fx-background-color:transparent;
-fx-background-radius: 0.0em;
-fx-padding:0.0 0.0 0.0 0.0;
}

.jfx-list-view .scroll-bar:vertical .increment-button ,
.jfx-list-view .scroll-bar:vertical .decrement-button {
-fx-background-color:transparent;
-fx-background-radius: 0.0em;
-fx-padding:0.0 0.0 0.0 0.0;
}
.jfx-list-view .scroll-bar .increment-arrow,
.jfx-list-view .scroll-bar .decrement-arrow{
-fx-shape:"";
-fx-padding:0.0;
}

.jfx-list-view .scroll-bar:horizontal .thumb,
.jfx-list-view .scroll-bar:vertical .thumb {
-fx-background-color:transparent;
-fx-background-insets: 0.0, 0.0, 0.0;
-fx-background-radius: 0.0em;
}

.list-cell {
    -fx-background-color: #FAFAFA
}

.list-cell:odd {
    -fx-background-color: #FAFAFA;
}

.list-cell:filled:selected:focused, .list-cell:filled:selected, .list-view:horizontal .list-cell:filled:selected {
    -fx-background-color: lightgray;
    -fx-text-fill: -fx-selection-bar-text;
}
```
###### /src/main/ui/AppColor.java
``` java
package main.ui;

public class AppColor {
    public static final String PRIMARY_BLUE = "3F51B5";
    public static final String PRIMARY_BLUE_LIGHT = "C5CAE9";
    public static final String PRIMARY_BLUE_DARK = "303F9F";
    public static final String PRIMARY_GREEN = "4CAF50";
    public static final String PRIMARY_GREEN_LIGHT = "C8E6C9";
    public static final String PRIMARY_LIME_LIGHT = "F0F4C3";
    public static final String PRIMARY_RED = "F44336";
    public static final String PRIMARY_RED_LIGHT = "FFCDD2";
    public static final String PRIMARY_AMBER = "FFC107";
    public static final String PRIMARY_WHITE = "FFFFFF";
    public static final String PRIORITY_LOW = "#FFC107";
    public static final String PRIORITY_MED = "#FF9800";
    public static final String PRIORITY_HIGH = "#FF5252";
    public static final String PRIORITY_NONE = "#FF5252";
    public static final String LINE_STROKE = "#000000";
    public static final String CIRCLE_STROKE = "#979797";



}
```
###### /src/main/ui/HelpPage.java
``` java
package main.ui;

import java.io.IOException;

import javafx.fxml.FXMLLoader;
import javafx.scene.layout.StackPane;

public class HelpPage extends StackPane {

    public HelpPage(){
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/main/resources/layouts/HelpPage.fxml"));
        fxmlLoader.setRoot(this);
        fxmlLoader.setController(this);

        try {
            fxmlLoader.load();
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }
    }

}
```
###### /src/main/ui/ListCellController.java
``` java
package main.ui;

import java.io.IOException;

import com.jfoenix.controls.JFXButton;
import com.jfoenix.controls.JFXListCell;
import com.jfoenix.effects.JFXDepthManager;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import main.data.Task;
import main.data.TaskHeader;

public class ListCellController extends JFXListCell<Task> {

    @FXML // fx:id="horizontalBox"
    private HBox horizontalBox; // Value injected by FXMLLoader

    @FXML // fx:id="labelTaskTime"
    private JFXButton labelTaskTime; // Value injected by FXMLLoader

    @FXML // fx:id="topLine"
    private Line topLine; // Value injected by FXMLLoader

    @FXML // fx:id="bottomLine"
    private Line bottomLine; // Value injected by FXMLLoader

    @FXML // fx:id="circleIndex"
    private Circle circleIndex; // Value injected by FXMLLoader

    @FXML // fx:id="labelTaskIndex"
    private Label labelTaskIndex; // Value injected by FXMLLoader

    @FXML // fx:id="verticalBox"
    private VBox verticalBox; // Value injected by FXMLLoader

    @FXML // fx:id="labelTaskTitle"
    private Label labelTaskTitle; // Value injected by FXMLLoader

    @FXML // fx:id="labelTaskDate"
    private Label labelTaskDate; // Value injected by FXMLLoader

    @FXML // fx:id="labelTaskLabel"
    private Label labelTaskLabel; // Value injected by FXMLLoader

    @FXML // fx:id="rectangleTaskPriority"
    private Rectangle rectangleTaskPriority; // Value injected by FXMLLoader

    private ListViewController parentListViewController;

    @FXML // This method is called by the FXMLLoader when initialization is
          // complete
    void initialize() {
        assert horizontalBox != null : "fx:id=\"horizontalBox\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert labelTaskTime != null : "fx:id=\"labelTaskTime\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert topLine != null : "fx:id=\"topLine\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert bottomLine != null : "fx:id=\"bottomLine\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert circleIndex != null : "fx:id=\"circleIndex\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert labelTaskIndex != null : "fx:id=\"labelTaskIndex\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert verticalBox != null : "fx:id=\"verticalBox\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert labelTaskTitle != null : "fx:id=\"labelTaskTitle\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert labelTaskDate != null : "fx:id=\"labelTaskDate\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert labelTaskLabel != null : "fx:id=\"labelTaskLabel\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";
        assert rectangleTaskPriority != null : "fx:id=\"rectangleTaskPriority\" was not injected: check your FXML file 'CustomListCellLayout.fxml'.";

    }

    public ListCellController(ListViewController parentListViewController) {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/resources/layouts/ListCellLayout.fxml"));
        loader.setController(this);
        try {
            loader.load();
            this.parentListViewController = parentListViewController;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void updateItem(Task task, boolean empty) {
        super.updateItem(task, empty);
        if (empty || task == null) {
            setGraphic(null);
        } else {
            if (task instanceof TaskHeader) {
                ListCellHeaderController listCellHeader = new ListCellHeaderController();
                listCellHeader.setText(task.getTitle());
                setGraphic(listCellHeader);
            } else {
                showTaskIndex(getIndex());
                setLabelTaskTitle(task);
                showTaskTime(task);
                showTaskDate(task);
                showTaskLabel(task);
                showTaskPriority(task);
                showTaskCollisions(task);
                // HBox is the parent layout of all
                // the other UI components here.
                // Returning an instance of this
                // will include the other UI
                // components here as well
                setGraphic(getHorizontalBox());
            }

        }

    }

    /**
     * @param task
     */
    private void showTaskCollisions(Task task) {
        if (!task.getCollideWithPrev() && !task.getCollideWithNext()) {
            topLine.setStroke(Color.web(AppColor.LINE_STROKE, 0.12));
            bottomLine.setStroke(Color.web(AppColor.LINE_STROKE, 0.12));
            circleIndex.setStroke(Color.web(AppColor.CIRCLE_STROKE));
            return;
        }

        if (task.getCollideWithPrev()) {
            topLine.setStroke(Color.web(AppColor.PRIMARY_RED));
            circleIndex.setStroke(Color.web(AppColor.PRIMARY_RED));
        } else {
            topLine.setStroke(Color.web(AppColor.LINE_STROKE, 0.12));
        }
        if (task.getCollideWithNext()) {
            bottomLine.setStroke(Color.web(AppColor.PRIMARY_RED));
            circleIndex.setStroke(Color.web(AppColor.PRIMARY_RED));
        } else {
            bottomLine.setStroke(Color.web(AppColor.LINE_STROKE, 0.12));
        }
    }

    public HBox getHorizontalBox() {
        return horizontalBox;
    }

    public void showTaskIndex(int taskIndex) {
        this.labelTaskIndex.setText(parentListViewController.getDisplayIndex(taskIndex) + "");
    }


    public void showTaskTime(Task task) {
        if (task.getSimpleTime().isEmpty()) {
            this.labelTaskTime.setText("-");
            return;
        }
        this.labelTaskTime.setText(task.getSimpleTime());
    }

    public void setLabelTaskTitle(Task task) {
        this.labelTaskTitle.setText(task.getTitle());
    }

    public void showTaskDate(Task task) {
        if (!task.hasDate()) {
            verticalBox.getChildren().remove(this.labelTaskDate);
            return;
        }

        this.labelTaskDate.setText(task.getSimpleDate());

        if (!verticalBox.getChildren().contains(this.labelTaskDate)) {
            verticalBox.getChildren().add(this.labelTaskDate);
        }

    }

    public void showTaskLabel(Task task) {
        if (task.hasLabel()) {
            this.labelTaskLabel.setText(task.getLabel());
            this.labelTaskLabel.setVisible(true);
        } else {
            this.labelTaskLabel.setVisible(false);
        }
    }

    public void showTaskPriority(Task task) {
        if (task.getPriority() == 1) {
            rectangleTaskPriority.setFill(Color.web(AppColor.PRIORITY_LOW));
            return;
        }

        if (task.getPriority() == 2) {
            rectangleTaskPriority.setFill(Color.web(AppColor.PRIORITY_MED));
            return;
        }

        if (task.getPriority() == 3) {
            rectangleTaskPriority.setFill(Color.web(AppColor.PRIORITY_HIGH));
            return;
        }

        rectangleTaskPriority.setFill(Color.TRANSPARENT);
    }
}
```
###### /src/main/ui/ListCellHeaderController.java
``` java
package main.ui;

import java.io.IOException;

import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;

public class ListCellHeaderController extends Label {
    public ListCellHeaderController() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/resources/layouts/ListCellHeaderLayout.fxml"));
        loader.setRoot(this);
        loader.setController(this);
        try {
            loader.load();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```
###### /src/main/ui/ListViewController.java
``` java
package main.ui;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.jfoenix.controls.JFXListCell;
import com.jfoenix.controls.JFXListView;
import com.sun.javafx.scene.control.skin.VirtualFlow;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SelectionMode;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.util.Callback;
import main.data.Task;
import main.data.TaskHeader;
import main.logic.AddCommand;
import main.logic.Command;
import main.logic.DeleteCommand;
import main.logic.DoneCommand;
import main.logic.EditCommand;
import main.logic.UndoneCommand;

@SuppressWarnings("restriction")
public class ListViewController extends AnchorPane {
    private static final Logger logger = Logger.getLogger(ListViewController.class.getName());
    private static final String STRING_LISTVIEW_TODO_EMPTY = "You have no task!";

    @FXML
    private JFXListView<Task> listView;

    // ListView UI related
    private VirtualFlow<IndexedCell<String>> virtualFlow;

    private RootLayoutController rootLayoutController;
    private ObservableList<Task> observableTaskList = FXCollections.observableArrayList();
    private ArrayList<Task> taskListWithHeaders;
    private int previousSelectedTaskIndex;
    private HashMap<Integer, Integer> displayIndexToActualIndexMap;
    private HashMap<Integer, Integer> actualIndexToDisplayIndexMap;

    private int totalOverdueTasks;
    private int totalTodayTasks;
    private int totalTomorrowTasks;
    private int totalUpcomingTasks;
    private int totalSomedayTasks;

    private boolean isOverdueHeaderAdded;
    private boolean isTodayHeaderAdded;
    private boolean isTomorrowHeaderAdded;
    private boolean isUpcomingHeaderAdded;
    private boolean isSomedayHeaderAdded;
    private boolean isArrowKeysPressed;

    public ListViewController() {
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/main/resources/layouts/TaskListView.fxml"));
        fxmlLoader.setRoot(this);
        fxmlLoader.setController(this);

        try {
            fxmlLoader.load();
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }
    }

    @FXML
    void initialize() {
        listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        listView.setPlaceholder(new Label(STRING_LISTVIEW_TODO_EMPTY));
        listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {

            @Override
            public JFXListCell<Task> call(ListView<Task> param) {
                return new ListCellController(ListViewController.this);
            }
        });
    }

    public ArrayList<Task> getTaskList() {
        return taskListWithHeaders;
    }

    public void refreshListView(ArrayList<Task> taskList) {
        saveSelectedIndex();
        observableTaskList.clear();
        populateListView(taskList);
        restoreListViewPreviousSelection();
    }

    public void populateListView(ArrayList<Task> taskList) {
        taskListWithHeaders = createListWithHeaders(taskList);
        initHashMapForListViewIndexes();
        observableTaskList.setAll(taskListWithHeaders);
        listView.setItems(observableTaskList);
    }

    private void initHashMapForListViewIndexes() {
        if (displayIndexToActualIndexMap == null) {
            displayIndexToActualIndexMap = new HashMap<>(taskListWithHeaders.size());
        }

        if (actualIndexToDisplayIndexMap == null) {
            actualIndexToDisplayIndexMap = new HashMap<>(taskListWithHeaders.size());
        }

        actualIndexToDisplayIndexMap.clear();
        displayIndexToActualIndexMap.clear();

        for (int i = 0; i < taskListWithHeaders.size(); i++) {
            Task task = taskListWithHeaders.get(i);
            int indexWithOffset = getIndexWithOffset(task, i);
            boolean isTaskObject = !(task instanceof TaskHeader);
            if (isTaskObject) {
                mapIndexWithOffsetToActualIndex(indexWithOffset, i);
                mapActualIndexToIndexWithOffset(i, indexWithOffset);
            }

        }

    }

    public void mapIndexWithOffsetToActualIndex(int displayIndex, int actualIndex) {
        displayIndexToActualIndexMap.put(displayIndex, actualIndex);

    }

    public void mapActualIndexToIndexWithOffset(int actualIndex, int displayIndex) {
        actualIndexToDisplayIndexMap.put(actualIndex, displayIndex);

    }

    public int getActualIndex(int displayIndex) {
        return displayIndexToActualIndexMap.get(displayIndex);
    }

    public int getDisplayIndex(int actualIndex) {
        return actualIndexToDisplayIndexMap.get(actualIndex);
    }

    private int getIndexWithOffset(Task task, int taskIndex) {
        int numberOfHeaders = 0;
        
        if (task.isToday() && !task.isOverdue()) {
            if (isOverdueHeaderAdded()) {
                numberOfHeaders++;
            }
        }
        
        if (task.isTomorrow()) {
            if (isOverdueHeaderAdded()) {
                numberOfHeaders++;
            }
            if (isTodayHeaderAdded()) {
                numberOfHeaders++;
            }
        }
        
        if (task.isUpcoming()) {
            if (isOverdueHeaderAdded()) {
                numberOfHeaders++;
            }
            if (isTodayHeaderAdded()) {
                numberOfHeaders++;
            }
            if (isTomorrowHeaderAdded()) {
                numberOfHeaders++;
            }
        }
        
        if (task.isSomeday()) {
            if (isOverdueHeaderAdded()) {
                numberOfHeaders++;
            }
            if (isTodayHeaderAdded()) {
                numberOfHeaders++;
            }
            if (isTomorrowHeaderAdded()) {
                numberOfHeaders++;
            }
            if (isUpcomingHeaderAdded()) {
                numberOfHeaders++;
            }
        }
        
        int indexWithOffset = taskIndex - numberOfHeaders;
        return indexWithOffset;
    }

    public int getTotalOverdueTasks() {
        return totalOverdueTasks;
    }

    public int getTotalTodayTasks() {
        return totalTodayTasks;
    }

    public int getTotalTomorrowTasks() {
        return totalTomorrowTasks;
    }

    public int getTotalUpcomingTasks() {
        return totalUpcomingTasks;
    }

    public int getTotalSomedayTasks() {
        return totalSomedayTasks;
    }

    private ArrayList<Task> createListWithHeaders(ArrayList<Task> taskList) {
        // +4 to the size due to the additional header task objects
        ArrayList<Task> taskListWithHeaders = new ArrayList<>(taskList.size() + 4);
        taskListWithHeaders.addAll(taskList);
        resetCountForTaskCategories();
        resetHeadersState();

        for (int i = 0; i < taskListWithHeaders.size(); i++) {
            Task task = taskListWithHeaders.get(i);

            if (task.isOverdue()) {
                if (!isOverdueHeaderAdded) {
                    taskListWithHeaders.add(i, new TaskHeader("Overdue"));
                    isOverdueHeaderAdded = true;
                }
                totalOverdueTasks++;
            }

            if (task.isToday() && !task.isOverdue()) { // cases where task is
                                                       // today and not overdue
                if (!isTodayHeaderAdded) {
                    taskListWithHeaders.add(i, new TaskHeader("Today"));
                    isTodayHeaderAdded = true;
                }
                totalTodayTasks++;
            }

            if (task.isTomorrow()) {
                if (!isTomorrowHeaderAdded) {
                    taskListWithHeaders.add(i, new TaskHeader("Tomorrow"));
                    isTomorrowHeaderAdded = true;
                }
                totalTomorrowTasks++;
            }
            if (task.isUpcoming()) {
                if (!isUpcomingHeaderAdded) {
                    taskListWithHeaders.add(i, new TaskHeader("Upcoming"));
                    isUpcomingHeaderAdded = true;
                }
                totalUpcomingTasks++;
            }
            if (task.isSomeday()) {
                if (!isSomedayHeaderAdded) {
                    taskListWithHeaders.add(i, new TaskHeader("Someday"));
                    isSomedayHeaderAdded = true;
                }
                totalSomedayTasks++;
            }

        }

        recalculateTotalTasksForEveryCategory();



        return taskListWithHeaders;
    }

    private void recalculateTotalTasksForEveryCategory() {
        // decrement all the counters by 1 due to double counting when an
        // insertion of a task header causes items in the arraylist to be
        // shifted to the right
        if (totalOverdueTasks != 0) {
            totalOverdueTasks = totalOverdueTasks - 1;
        }
        if (totalTodayTasks != 0) {
            totalTodayTasks = totalTodayTasks - 1;
        }
        if (totalTomorrowTasks != 0) {
            totalTomorrowTasks = totalTomorrowTasks - 1;
        }
        if (totalUpcomingTasks != 0) {
            totalUpcomingTasks = totalUpcomingTasks - 1;
        }
        if (totalSomedayTasks != 0) {
            totalSomedayTasks = totalSomedayTasks - 1;
        }
    }

    private void resetCountForTaskCategories() {
        totalOverdueTasks = 0;
        totalTodayTasks = 0;
        totalTomorrowTasks = 0;
        totalUpcomingTasks = 0;
        totalSomedayTasks = 0;
    }

    private void resetHeadersState() {
        isOverdueHeaderAdded = false;
        isTodayHeaderAdded = false;
        isTomorrowHeaderAdded = false;
        isUpcomingHeaderAdded = false;
        isSomedayHeaderAdded = false;
    }

    public void selectListViewFirstItem() {
        listView.getSelectionModel().select(1);
        saveSelectedIndex();
        initCustomViewportBehaviorForListView();

        listView.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<Task>() {

            @Override
            public void changed(ObservableValue<? extends Task> observable, Task oldValue, Task newValue) {
                // TODO will encounter nullpointer on first run
                // saveSelectedIndex();
                
                if (newValue instanceof TaskHeader) {
                    if (getSelectedIndex() < getPreviousSelectedIndex()) {
                        listView.getSelectionModel().clearAndSelect(getSelectedIndex() - 1);

                    } else if (getSelectedIndex() > getPreviousSelectedIndex()) {
                        listView.getSelectionModel().clearAndSelect(getSelectedIndex() + 1);
                    }
                }
                
                adjustViewportForListView();

            }
        });
    }

    public void initListViewBehavior() {
        initCustomViewportBehaviorForListView();
    }

    /**
     * This method currently accesses the private API, the VirtualFlow class.
     * This method can only be called after the Stage has been set in the
     * MainApp class. Due to the lifecycle of the JavaFX framework, we can only
     * to grab an instance of the VirtualFlow class from our ListView after the
     * Stage has been set. This will allow us to adjust the viewport of the
     * ListView programmatically whenever user hits the up/down arrow key to
     * select items from the ListView. See adjustViewportForListView() method to
     * find out more about the viewport adjusting algorithm
     */
    @SuppressWarnings({ "unchecked" })
    private void initCustomViewportBehaviorForListView() {
        for (Node node : listView.getChildrenUnmodifiable()) {
            if (node instanceof VirtualFlow) {
                // get an instance of VirtualFlow. this is essentially the
                // viewport for ListView
                virtualFlow = (VirtualFlow<IndexedCell<String>>) node;
            }
        }

    }

    /**
     * This method is used to emulate the original behavior of a ListView, i.e.
     * the automatic scrolling of focused ListView when a selected item is not
     * visible within the viewport.
     */
    private void adjustViewportForListView() {
        if (virtualFlow.getFirstVisibleCellWithinViewPort() != null) {
            int firstVisibleIndex = virtualFlow.getFirstVisibleCellWithinViewPort().getIndex();
            int lastVisibleIndex = virtualFlow.getLastVisibleCellWithinViewPort().getIndex();

            if (isArrowKeysPressed) {
                if (getSelectedIndex() <= firstVisibleIndex) {
                    // if the item at current index -1 is a task header, adjust
                    // viewport to show header
                    if (taskListWithHeaders.get(getSelectedIndex() - 1) instanceof TaskHeader) {
                        listView.scrollTo(getSelectedIndex() - 1);
                    } else {
                        // viewport will scroll and show the current item at the
                        // top
                        listView.scrollTo(getSelectedIndex());
                    }

                } else if (getSelectedIndex() > lastVisibleIndex) {
                    // viewport will scroll and show the current item at the
                    // bottom
                    listView.scrollTo(firstVisibleIndex + 1);
                }
                isArrowKeysPressed = false;
                return;
            }

            Command lastExecutedCommand = rootLayoutController.getLastExecutedCommand();
            boolean isAddCommand = lastExecutedCommand instanceof AddCommand;
            boolean isEditCommand = lastExecutedCommand instanceof EditCommand;
            boolean isDeleteCommand = lastExecutedCommand instanceof DeleteCommand;
            boolean isDoneCommand = lastExecutedCommand instanceof DoneCommand;
            boolean isUndoneCommand = lastExecutedCommand instanceof UndoneCommand;

            if (isAddCommand || isEditCommand || isDeleteCommand || isDoneCommand || isUndoneCommand) {
                logger.log(Level.INFO, "Adjusting viewport for: " + lastExecutedCommand.getClass().getSimpleName());
                
                int numberOfCellsDifference;
                if (getSelectedIndex() <= firstVisibleIndex) {
                    numberOfCellsDifference = firstVisibleIndex - getSelectedIndex();
                    if (taskListWithHeaders.get(getSelectedIndex() - 1) instanceof TaskHeader) {
                        listView.scrollTo(getSelectedIndex() - 1);
                    } else {
                        listView.scrollTo(getSelectedIndex());
                    }

                } else if (getSelectedIndex() > lastVisibleIndex) {
                    numberOfCellsDifference = getSelectedIndex() - lastVisibleIndex;
                    if (numberOfCellsDifference == 1) {
                        listView.scrollTo(firstVisibleIndex + 1);
                    } else {
                        listView.scrollTo(numberOfCellsDifference + 4);
                    }
                }
                return;
            }
        }
    }

    /**
    *
    */
    public int getSelectedIndex() {
        if (listView.getSelectionModel().getSelectedIndex() < 0) {
            return 1;
        }
        return listView.getSelectionModel().getSelectedIndex();
    }

    /**
    *
    */
    public void saveSelectedIndex() {
        previousSelectedTaskIndex = getSelectedIndex();
    }

    /**
    *
    */
    public int getPreviousSelectedIndex() {
        return previousSelectedTaskIndex;
    }

    /**
    *
    */
    public void restoreListViewPreviousSelection() {
        // if previous selected index was the last index in the previous list
        if (previousSelectedTaskIndex == observableTaskList.size()) {
            listView.getSelectionModel().clearAndSelect(observableTaskList.size() - 1); // select
                                                                                        // the
                                                                                        // last
                                                                                        // index
            saveSelectedIndex();
            logger.log(Level.INFO, "Restore ListView selection to last item");
        } else {
            listView.getSelectionModel().select(previousSelectedTaskIndex);
            saveSelectedIndex();
            logger.log(Level.INFO, "Restore ListView selection to previous to previous item");
        }
    }

    public void clearListViewSelection() {
        listView.getSelectionModel().clearSelection();
    }

    public void select(int index) {
        int actualIndex;
        try {
            actualIndex = displayIndexToActualIndexMap.get(index);
        } catch (NullPointerException e) {
            actualIndex = displayIndexToActualIndexMap.get(index - 1);
        }
        listView.getSelectionModel().select(actualIndex);
    }

    public void clearAndSelect(int index) {
        int actualIndex = displayIndexToActualIndexMap.get(index);
        listView.getSelectionModel().clearAndSelect(actualIndex);
    }

    public void selectAll() {
        listView.getSelectionModel().selectAll();
    }

    public void selectLast() {
        listView.getSelectionModel().selectLast();
    }

    public void setRootLayoutController(RootLayoutController rootLayoutController) {
        this.rootLayoutController = rootLayoutController;
    }

    /**
    *
    */
    public void handleArrowKeys(KeyEvent keyEvent) {
        saveSelectedIndex();
        if (keyEvent.getCode() == KeyCode.UP) {
            if (getPreviousSelectedIndex() > 1) {
                isArrowKeysPressed = true;
                listView.getSelectionModel().clearAndSelect(getPreviousSelectedIndex() - 1);
            }

        } else if (keyEvent.getCode() == KeyCode.DOWN) {
            if (getPreviousSelectedIndex() < observableTaskList.size() - 1) {
                isArrowKeysPressed = true;
                listView.getSelectionModel().clearAndSelect(getPreviousSelectedIndex() + 1);
            }

        }

        logger.log(Level.INFO, "Pressed " + keyEvent.getCode() + " arrow key: currently selected index is "
                + getSelectedIndex() + " current listview: " + listView.getId());
    }

    public boolean isOverdueHeaderAdded() {
        return isOverdueHeaderAdded;
    }

    public boolean isTodayHeaderAdded() {
        return isTodayHeaderAdded;
    }

    public boolean isTomorrowHeaderAdded() {
        return isTomorrowHeaderAdded;
    }

    public boolean isUpcomingHeaderAdded() {
        return isUpcomingHeaderAdded;
    }

    public boolean isSomedayHeaderAdded() {
        return isSomedayHeaderAdded;
    }
}
```
###### /src/main/ui/MainApp.java
``` java
package main.ui;

import java.io.IOException;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class MainApp extends Application {
    private static final String WINDOW_TITLE = "Dooleh";
    private Stage primaryStage;
    private StackPane rootLayout;

    @Override
    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.primaryStage.setTitle(WINDOW_TITLE);
        initRootLayout();
    }

    /**
     * Initializes the root layout.
     */
    public void initRootLayout() {
        try {
            // Load root layout from fxml file.
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/resources/layouts/RootLayout.fxml"));
//            rootLayout = FXMLLoader.load(getClass().getResource("/main/resources/layouts/RootLayout.fxml"));

            rootLayout = (StackPane) loader.load();

            // Show the scene containing the root layout.
            Scene scene = new Scene(rootLayout);

            primaryStage.setScene(scene);
            primaryStage.show();

            //get a handle on the UI controller and set focus to the text field
            RootLayoutController rootLayoutController = (RootLayoutController) loader.getController();
            rootLayoutController.requestFocusForCommandBar();
            rootLayoutController.selectFirstItemFromListView();
            rootLayoutController.initListViewBehavior();
            rootLayoutController.setMainApp(this);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Returns the main stage.
     *
     * @return
     */
    public Stage getPrimaryStage() {
        return primaryStage;
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /src/main/ui/RootLayoutController.java
``` java
package main.ui;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.EmptyStackException;
import java.util.Observable;
import java.util.Observer;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.jfoenix.controls.JFXButton;
import com.jfoenix.controls.JFXDialog;
import com.jfoenix.controls.JFXDialog.DialogTransition;
import com.jfoenix.controls.JFXTabPane;
import com.jfoenix.controls.JFXTextField;

import javafx.animation.FadeTransition;
import javafx.animation.SequentialTransition;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.control.Label;
import javafx.scene.control.SingleSelectionModel;
import javafx.scene.control.Tab;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.SVGPath;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.stage.FileChooser;
import javafx.stage.FileChooser.ExtensionFilter;
import javafx.util.Duration;
import main.data.ParseIndexResult;
import main.data.Task;
import main.data.TaskHeader;
import main.logic.AddCommand;
import main.logic.Command;
import main.logic.DeleteCommand;
import main.logic.DoneCommand;
import main.logic.EditCommand;
import main.logic.Invoker;
import main.logic.PriorityCommand;
import main.logic.Receiver;
import main.logic.SearchCommand;
import main.logic.SetFileLocationCommand;
import main.logic.UndoneCommand;
import main.parser.CommandParser;
import main.parser.exceptions.InvalidLabelFormat;
import main.parser.exceptions.InvalidTaskIndexFormat;

public class RootLayoutController implements Observer {
    private static final String STRING_COMMAND_EDIT = "edit";
    private static final String STRING_COMMAND_DELETE = "delete";
    private static final String STRING_COMMAND_DELETE_SHORTHAND = "del";
    private static final String STRING_COMMAND_SEARCH = "search";
    private static final String STRING_COMMAND_DONE = "done";
    private static final String STRING_COMMAND_UNDONE = "undone";
    private static final String STRING_COMMAND_UNDO = "undo";
    private static final String STRING_COMMAND_REDO = "redo";
    private static final String STRING_COMMAND_SET_FILE_LOCATION = "set";
    private static final String STRING_COMMAND_EXIT = "exit";
    private static final String STRING_COMMAND_CLOSE = "close";
    private static final String STRING_COMMAND_QUIT = "quit";
    private static final String STRING_DOUBLE_QUOTATIONS_WITH_TEXT = "\"%1$s\"";
    private static final String STRING_TAB_TASK_SIZE = "(%1$s)";
    private static final String STRING_FEEDBACK_ACTION_ADD = "Adding:";
    private static final String STRING_FEEDBACK_ACTION_EDIT = "Editing:";
    private static final String STRING_FEEDBACK_ACTION_DELETE = "Deleting:";
    private static final String STRING_FEEDBACK_TOTAL_TASK = "(%1$s tasks)";
    private static final String STRING_FEEDBACK_ACTION_SEARCH = "Searching:";
    private static final String STRING_FEEDBACK_ACTION_DONE = "Mark as done:";
    private static final String STRING_FEEDBACK_ACTION_UNDONE = "Mark as undone:";
    private static final String STRING_FEEDBACK_ACTION_UNDO = "Undoing:";
    private static final String STRING_FEEDBACK_ACTION_REDO = "Redoing:";
    private static final String STRING_FEEDBACK_ACTION_EXIT = "Exit Dooleh";
    private static final String STRING_FEEDBACK_TOTAL_ACTION = "%1$s action(s)";
    private static final String STRING_FEEDBACK_ACTION_SET_FILE_LOCATION = "Set file location";
    private static final String STRING_ERROR_NOT_FOUND = "Task %1$s not found.";
    private static final String STRING_EMPTY = "";
    private static final String STRING_WHITESPACE = " ";

    private static final KeyCombination HOTKEY_CTRL_TAB = new KeyCodeCombination(KeyCode.TAB,
            KeyCombination.CONTROL_DOWN);
    private static final KeyCombination HOTKEY_CTRL_P = new KeyCodeCombination(KeyCode.P, KeyCombination.CONTROL_DOWN);
    private static final KeyCombination HOTKEY_CTRL_D = new KeyCodeCombination(KeyCode.D, KeyCombination.CONTROL_DOWN);

    @FXML // fx:id="ListViewController"
    private ListViewController todoListViewController;

    @FXML // fx:id="ListViewController"
    private ListViewController completedListViewController;

    @FXML // fx:id="rootLayout"
    private AnchorPane rootLayout;

    @FXML // fx:id="buttonUndo"
    private JFXButton buttonUndo;

    @FXML // fx:id="buttonRedo"
    private JFXButton buttonRedo;

    @FXML // fx:id="buttonHelp"
    private JFXButton buttonHelp;

    @FXML // fx:id="iconUndo"
    private SVGPath iconUndo;

    @FXML // fx:id="iconRedo"
    private SVGPath iconRedo;

    @FXML // fx:id="dialogHelp"
    private JFXDialog dialogHelp;

    @FXML // fx:id="dialogContainer"
    private StackPane dialogContainer;

    @FXML // fx:id="totalTasksOverdue"
    private Text totalTasksOverdue;

    @FXML // fx:id="totalTasksToday"
    private Text totalTasksToday;

    @FXML // fx:id="totalTasksTomorrow"
    private Text totalTasksTomorrow;

    @FXML // fx:id="totalTastotalTasksUpcomingksToday"
    private Text totalTasksUpcoming;

    @FXML // fx:id="totalTasksSomeday"
    private Text totalTasksSomeday;

    @FXML // fx:id="tabPane"
    private JFXTabPane tabPane;

    @FXML // fx:id="tabTodo"
    private Tab tabTodo;

    @FXML // fx:id="tabCompleted"
    private Tab tabCompleted;

    @FXML // fx:id="commandBar"
    private JFXTextField commandBar;

    @FXML // fx:id="chipSearchMode"
    private JFXButton chipSearchMode;

    @FXML // fx:id="btnFeedback"
    private JFXButton btnFeedback;

    @FXML // fx:id="groupFeedback"
    private Group groupFeedback;

    @FXML // fx:id="textFlowFeedback"
    private TextFlow textFlowFeedback;

    @FXML // fx:id="textUserAction"
    private Text textUserAction;

    @FXML // fx:id="textUserParsedResult"
    private Text textUserParsedResult;

    @FXML // fx:id="anchorPaneExecutionResult"
    private AnchorPane anchorPaneExecutionResult;

    @FXML // fx:id="labelExecutedCommand"
    private Label labelExecutedCommand;

    @FXML // fx:id="labelExecutionDetails"
    private Label labelExecutionDetails;

    @FXML // fx:id="labelSuggestedAction"
    private Label labelSuggestedAction;

    private MainApp mainApp;

    private Invoker invoker;
    private Receiver receiver;
    private CommandParser commandParser;
    private Command commandToBeExecuted;
    private SearchCommand searchCommand;

    private Task taskToBeExecuted;
    private ArrayList<Task> listOfTaskToBeExecuted = new ArrayList<>();
    private ArrayList<Integer> taskIndexesToBeExecuted = new ArrayList<>();

    private ArrayList<Task> todoTasks;
    private ArrayList<Task> completedTasks;
    private ArrayList<Task> todoTasksWithHeaders;
    private ArrayList<Task> completedTasksWithHeaders;
    private String inputFeedback;
    private String userInput;
    private String[] userInputArray;
    private String userCommand;
    private String userArguments;
    private int previousCaretPosition;
    private boolean isSearchMode;
    private boolean isUndoRedo;
    private int numberOfActions;

    private ArrayList<Task> currentList;

    private ListViewController currentListViewController;

    private static final Logger logger = Logger.getLogger(RootLayoutController.class.getName());

    /**
     * Use to set {@code allTasks} with a new {@code ArrayList}
     *
     * @param observable
     * @param observable
     */
    @Override
    public void update(Observable observable, Object arg) {
        if (observable instanceof Receiver) {
            if (commandToBeExecuted != null) {
                logger.log(Level.INFO, "(" + commandToBeExecuted.getClass().getSimpleName() + ") update() is called");

                refreshListView();
                refreshUndoRedoState();
                // TODO do something about this
                if (isUndoRedo) {
                    isUndoRedo = false;
//                    System.out.println("IS UNDO, selected index: " + getCurrentListViewController().getSelectedIndex());
//                    return;
                }

                boolean isAddCommand = commandToBeExecuted instanceof AddCommand;
                boolean isDeleteCommand = commandToBeExecuted instanceof DeleteCommand;
                boolean isEditCommand = commandToBeExecuted instanceof EditCommand;
                boolean isDoneCommand = commandToBeExecuted instanceof DoneCommand;
                boolean isUndoneCommand = commandToBeExecuted instanceof UndoneCommand;
                boolean isSearchCommand = commandToBeExecuted instanceof SearchCommand;

                if (isAddCommand || isEditCommand) {
                    int displayIndex = getCurrentListViewController().getDisplayIndex(getIndexFromLastExecutedTask());
                    getCurrentListViewController().clearListViewSelection();
                    getCurrentListViewController().select(displayIndex);
                } else if (isDeleteCommand || isDoneCommand || isUndoneCommand) {
                    getCurrentListViewController().clearListViewSelection();
                    if (getCurrentListViewController().getPreviousSelectedIndex() >= getCurrentList().size() - 1) {
                        getCurrentListViewController().selectLast();
                    } else {
                        // select back the previous first index that was in the
                        // range
                        if (getCurrentList().size() > 0) {
                            getCurrentListViewController().select(taskIndexesToBeExecuted.get(0));
                        }
                    }
                } else if (isSearchCommand) {
                    if (userArguments.equals(" ")) {
                        showFeedback(true, STRING_FEEDBACK_ACTION_SEARCH, "");
                    } else {
                        int numberOfTasks = 0;
                        for (Task task : currentList) {
                            if (!(task instanceof TaskHeader)) {
                                numberOfTasks++;
                            }
                        }

                        showFeedback(true, STRING_FEEDBACK_ACTION_SEARCH,
                                " Found " + numberOfTasks + " task(s) for \"" + userArguments + "\"");
                    }
                }
            } else {
                if (isUndoRedo) {
                    refreshListView();
                }
            }
        }
    }

    /**
     * @return void
     */
    private void refreshUndoRedoState() {
        if (invoker.isUndoAvailable()) {
            iconUndo.setFill(Color.web(AppColor.PRIMARY_WHITE));
        } else {
            iconUndo.setFill(Color.web(AppColor.PRIMARY_WHITE, 0.4));
        }
        if (invoker.isRedoAvailable()) {
            iconRedo.setFill(Color.web(AppColor.PRIMARY_WHITE));
        } else {
            iconRedo.setFill(Color.web(AppColor.PRIMARY_WHITE, 0.4));
        }
    }

    /**
     *
     * @return
     */
    public int getIndexFromLastExecutedTask() {
        return getCurrentList().indexOf(taskToBeExecuted);
    }

    public void requestFocusForCommandBar() {
        logger.log(Level.INFO, "Set focus to command bar");
        commandBar.requestFocus();
    }

    public void initListViewBehavior() {
        todoListViewController.initListViewBehavior();
        completedListViewController.initListViewBehavior();
    }

    public void selectFirstItemFromListView() {
        logger.log(Level.INFO, "Set Select the first item on the ListView");
        todoListViewController.selectListViewFirstItem();
        completedListViewController.selectListViewFirstItem();
        setCurrentListViewController(tabTodo.getText());
    }

    public void setMainApp(MainApp mainApp) {
        this.mainApp = mainApp;
    }

    @FXML
    private void initialize() {
        logger.log(Level.INFO, "Initializing the UI...");

        assertDependencyInjection();
        initLogicAndParser();
        initListView();
        initTabSelectionListener();
        initKeyboardListener();
        initCommandBarListener();
        initSearchModeChipsLayoutListener();
        initToolBarButtons();

        logger.log(Level.INFO, "UI initialization complete");
    }

    private void initToolBarButtons() {
        buttonUndo.setOnMouseClicked(new EventHandler<Event>() {

            @Override
            public void handle(Event event) {
                handleUndo();

            }
        });
        buttonRedo.setOnMouseClicked(new EventHandler<Event>() {

            @Override
            public void handle(Event event) {
                handleRedo();

            }
        });

        dialogHelp.setContent(new HelpPage());
        dialogHelp.setTransitionType(DialogTransition.CENTER);
        buttonHelp.setOnMouseClicked(new EventHandler<Event>() {

            @Override
            public void handle(Event event) {
                toggleHelpDialog();

            }
        });
    }

    private void assertDependencyInjection() {
        assert rootLayout != null : "fx:id=\"rootLayout\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert buttonUndo != null : "fx:id=\"buttonUndo\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert buttonRedo != null : "fx:id=\"buttonRedo\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert buttonHelp != null : "fx:id=\"buttonHelp\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert iconRedo != null : "fx:id=\"iconRedo\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert iconUndo != null : "fx:id=\"iconUndo\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert dialogContainer != null : "fx:id=\"dialogContainer\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert dialogHelp != null : "fx:id=\"dialogHelp\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert totalTasksOverdue != null : "fx:id=\"totalTasksOverdue\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert totalTasksToday != null : "fx:id=\"totalTasksToday\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert totalTasksTomorrow != null : "fx:id=\"totalTasksTomorrow\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert totalTasksUpcoming != null : "fx:id=\"totalTasksUpcoming\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert totalTasksSomeday != null : "fx:id=\"totalTasksSomeday\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert tabPane != null : "fx:id=\"tabPane\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert tabTodo != null : "fx:id=\"tabTodo\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert tabCompleted != null : "fx:id=\"tabCompleted\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert commandBar != null : "fx:id=\"commandBar\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert chipSearchMode != null : "fx:id=\"chipSearchMode\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert btnFeedback != null : "fx:id=\"btnFeedback\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert groupFeedback != null : "fx:id=\"groupFeedback\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert textFlowFeedback != null : "fx:id=\"textFlowFeedback\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert textUserAction != null : "fx:id=\"textUserAction\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert textUserParsedResult != null : "fx:id=\"textUserParsedResult\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert anchorPaneExecutionResult != null : "fx:id=\"anchorPaneExecutionResult\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert labelExecutedCommand != null : "fx:id=\"labelExecutedCommand\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert labelExecutionDetails != null : "fx:id=\"labelExecutionDetails\" was not injected: check your FXML file 'RootLayout.fxml'.";
        assert labelSuggestedAction != null : "fx:id=\"labelSuggestedAction\" was not injected: check your FXML file 'RootLayout.fxml'.";
    }

    /**
     *
     */
    private void initSearchModeChipsLayoutListener() {
        chipSearchMode.widthProperty().addListener(new ChangeListener<Number>() {

            @Override
            public void changed(ObservableValue<? extends Number> observable, Number oldValue, Number newValue) {
                // inset : top right bottom left
                if (chipSearchMode.getText().isEmpty()) {
                    commandBar.setPadding(new Insets(8, 8, 8, 8));
                } else {
                    commandBar.setPadding(new Insets(8, 8, 8, newValue.doubleValue() + 20));
                }
            }
        });
        logger.log(Level.INFO, "Adding listener to search mode chip");
    }

    /**
    *
    */
    private void initTabSelectionListener() {
        tabPane.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<Tab>() {

            @Override
            public void changed(ObservableValue<? extends Tab> observable, Tab oldValue, Tab newValue) {
                setCurrentListViewController(newValue.getText());
                setCurrentList(newValue.getText());
                updateTotalTasksForEveryCategory();
            }
        });
    }

    /**
     *
     */
    private void initCommandBarListener() {
        logger.log(Level.INFO, "Adding listener for command bar");
        commandBar.focusedProperty().addListener(new ChangeListener<Boolean>() {

            @Override
            public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
                logger.log(Level.INFO, "Command bar focus is: " + newValue);
                if (!newValue) {
                    commandBar.requestFocus();
                }

            }
        });
        commandBar.textProperty().addListener(new ChangeListener<String>() {

            @Override
            public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
                // TODO Auto-generated method stub
                handleKeyStrokes(newValue);

            }
        });
        commandBar.setOnAction(new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                // do nothing when there is no user input
                if (commandBar.getText().isEmpty()) {
                    event.consume();
                    return;
                }

                handleEnterKey();
                event.consume();
            }
        });
    }

    /**
     *
     */
    private void initKeyboardListener() {
        rootLayout.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {

            @Override
            public void handle(KeyEvent keyEvent) {
                if (keyEvent.getCode() == KeyCode.UP || keyEvent.getCode() == KeyCode.DOWN) {
                    handleArrowKeys(keyEvent);
                    keyEvent.consume();
                } else if (keyEvent.getCode() == KeyCode.ESCAPE) {
                    handleEscKey();
                } else if (keyEvent.getCode() == KeyCode.F1) {
                    handleUndo();
                    keyEvent.consume();
                } else if (keyEvent.getCode() == KeyCode.F2) {
                    handleRedo();
                    keyEvent.consume();
                } else if (keyEvent.getCode() == KeyCode.F3) {
                    toggleHelpDialog();
                    keyEvent.consume();
                } else if (keyEvent.getCode() == KeyCode.DELETE) {
                    handleDeleteKey();
                    keyEvent.consume();
                } else if (keyEvent.getCode() == KeyCode.BACK_SPACE) {
                    // Do not consume the event here (i.e. event.consume())
                    handleBackspaceKey();
                } else if (HOTKEY_CTRL_TAB.match(keyEvent)) {
                    handleCtrlTab();
                    keyEvent.consume();
                } else if (HOTKEY_CTRL_P.match(keyEvent)) {
                    handleCtrlP();
                    keyEvent.consume();
                } else if (HOTKEY_CTRL_D.match(keyEvent)) {
                    handleCtrlD();
                    keyEvent.consume();
                } else if (keyEvent.getCode() == KeyCode.TAB) {
                    // do nothing here to prevent the ui from changing focus
                    keyEvent.consume();
                }

                saveCaretPosition();
            }

            private void handleEscKey() {
                dialogHelp.close();
            }
        });
    }

    private void initLogicAndParser() {
        if (invoker == null) {
            invoker = new Invoker();
        }

        if (receiver == null) {
            receiver = Receiver.getInstance();
            receiver.addObserver(this);
        }

        if (commandParser == null) {
            commandParser = new CommandParser();
        }

    }

    /**
     * In ListController now
     */
    private void initListView() {
        populateListView();
        todoListViewController.setRootLayoutController(this);
        completedListViewController.setRootLayoutController(this);
    }

    /**
     * In ListController now
     *
     */
    private void populateListView() {
        getTasksFromReceiver();
        todoListViewController.populateListView(todoTasks);
        completedListViewController.populateListView(completedTasks);
        updateListWithHeaders();
        updateTabAndLabelWithTotalTasks();
        setCurrentList(getSelectedTabName());
        setCurrentListViewController(getSelectedTabName());
        updateTotalTasksForEveryCategory();

        logger.log(Level.INFO, "Populated Todo List: " + todoTasks.size() + " task");
        logger.log(Level.INFO, "Populated Completed List: " + completedTasks.size() + " task");
    }

    /**
     * In ListController now
     *
     */
    private void refreshListView() {
        getTasksFromReceiver();
        todoListViewController.refreshListView(todoTasks);
        completedListViewController.refreshListView(completedTasks);
        updateListWithHeaders();
        updateTabAndLabelWithTotalTasks();
        setCurrentList(getSelectedTabName());
        setCurrentListViewController(getSelectedTabName());
        updateTotalTasksForEveryCategory();
    }

    private void updateTotalTasksForEveryCategory() {
        totalTasksOverdue.setText(String.valueOf(getCurrentListViewController().getTotalOverdueTasks()));
        totalTasksToday.setText(String.valueOf(getCurrentListViewController().getTotalTodayTasks()));
        totalTasksTomorrow.setText(String.valueOf(getCurrentListViewController().getTotalTomorrowTasks()));
        totalTasksUpcoming.setText(String.valueOf(getCurrentListViewController().getTotalUpcomingTasks()));
        totalTasksSomeday.setText(String.valueOf(getCurrentListViewController().getTotalSomedayTasks()));
    }

    private void updateListWithHeaders() {
        todoTasksWithHeaders = todoListViewController.getTaskList();
        completedTasksWithHeaders = completedListViewController.getTaskList();
    }

    private void getTasksFromReceiver() {
        todoTasks = receiver.getTodoTasks();
        assert todoTasks != null;
        completedTasks = receiver.getCompletedTasks();
        assert completedTasks != null;

    }

    private void updateTabAndLabelWithTotalTasks() {
        tabTodo.setText("To-do" + STRING_WHITESPACE + String.format(STRING_TAB_TASK_SIZE, todoTasks.size()));
        tabCompleted
                .setText("Completed" + STRING_WHITESPACE + String.format(STRING_TAB_TASK_SIZE, completedTasks.size()));

    }

    /**
     *
     */
    private void handleUndo() {
        if (invoker.isUndoAvailable()) {
            try {
                isUndoRedo = true;
                Command previousCommand = invoker.undo();
                logger.log(Level.INFO, "Pressed F1 key: UNDO operation");

                if (!chipSearchMode.getText().equals("")) {
                    invoker.execute(searchCommand);
                }
                showExecutionResult(previousCommand, "Undo");
            } catch (EmptyStackException emptyStackException) {
                logger.log(Level.WARNING, emptyStackException.getMessage());
            }
        }
    }

    /**
     *
     */
    private void handleRedo() {
        if (invoker.isRedoAvailable()) {
            try {
                isUndoRedo = true;
                Command previousCommand = invoker.redo();
                logger.log(Level.INFO, "Pressed F2 key: REDO operation");

                if (!chipSearchMode.getText().equals("")) {
                    invoker.execute(searchCommand);
                }
                showExecutionResult(previousCommand, "Redo");
            } catch (EmptyStackException emptyStackException) {
                logger.log(Level.WARNING, emptyStackException.getMessage());
            }
        }
    }

    /**
     *
     */
    private void handleKeyStrokes(String input) {
        if (commandParser == null) {
            commandParser = new CommandParser();
        }
        userInput = input;
        userInput = userInput.trim();
        assert userInput != null;

        if (userInput.isEmpty()) {
            logger.log(Level.INFO, "Command bar is empty");
            clearStoredUserInput();
            btnFeedback.setVisible(false);
            return;
        }

        logger.log(Level.INFO, "User is typing: " + userInput);
        btnFeedback.setVisible(true);
        extractUserInput();
        parseUserInput();

    }

    /**
     *
     */
    private void handleArrowKeys(KeyEvent keyEvent) {
        getCurrentListViewController().handleArrowKeys(keyEvent);
    }

    /**
     *
     */
    private void handleEnterKey() {
        if (commandBar.getText().trim().length() > 0) {
            if (userCommand.equals(STRING_COMMAND_EXIT) || userCommand.equals(STRING_COMMAND_QUIT)
                    || userCommand.equals(STRING_COMMAND_CLOSE)) {
                System.exit(0);
            }
            if (userCommand.equals(STRING_COMMAND_UNDO)) {
                if (numberOfActions < 0) {
                    handleUndo();
                } else {
                    for (int i = 0; i < numberOfActions; i++) {
                        handleUndo();
                    }
                }
                resetStateAfterExecution();
                return;

            }

            if (userCommand.equals(STRING_COMMAND_REDO)) {
                if (numberOfActions < 0) {
                    handleRedo();
                } else {
                    for (int i = 0; i < numberOfActions; i++) {
                        handleRedo();
                    }
                }
                resetStateAfterExecution();
                return;
            }

            if (commandToBeExecuted == null) {
                return;
            }

            logger.log(Level.INFO, "(" + commandToBeExecuted.getClass().getSimpleName() + ") Pressed ENTER key: "
                    + commandBar.getText());

            boolean isSearchCommand = commandToBeExecuted instanceof SearchCommand;
            boolean isSetFileLocationCommand = commandToBeExecuted instanceof SetFileLocationCommand;

            if (isSetFileLocationCommand) {
                if (userInputArray.length <= 1) {
                    File selectedFile = showFileChooserDialog();
                    if (selectedFile == null) {
                        return;
                    }
                    String selectedFilePath = getFilePath(selectedFile);
                    commandToBeExecuted = new SetFileLocationCommand(receiver, selectedFilePath);
                }
                invoker.execute(commandToBeExecuted);
            }

            if (!isSearchCommand) {
                invoker.execute(commandToBeExecuted);
                showExecutionResult(commandToBeExecuted, null);
            } else {
                isSearchMode = true;
                showSearchChipInCommandBar(isSearchMode);
            }

        }

        if (isSearchMode) {
            invoker.execute(searchCommand);
        }

        resetStateAfterExecution();

    }

    private void resetStateAfterExecution() {
        btnFeedback.setVisible(false);
        clearStoredUserInput();
        commandBar.clear();
    }

    /**
     *
     */
    private void handleBackspaceKey() {
        if (isSearchMode && commandBar.getLength() == 0) {
            // invoker.undo();
            commandToBeExecuted = new SearchCommand(receiver, "");
            invoker.execute(commandToBeExecuted);
            isSearchMode = false;
            showSearchChipInCommandBar(isSearchMode);
        }
    }

    /**
     *
     */
    private void showSearchChipInCommandBar(boolean isVisible) {
        if (isVisible) {
            chipSearchMode.setVisible(isVisible);
            chipSearchMode.setText(STRING_COMMAND_SEARCH + STRING_WHITESPACE
                    + String.format(STRING_DOUBLE_QUOTATIONS_WITH_TEXT, userArguments));

        } else {
            chipSearchMode.setVisible(isVisible);

            // must set it to a empty string so that the the chip will resize
            // and the chip listener will resize the command bar
            chipSearchMode.setText("");
        }

    }

    /**
     *
     */
    private void handleDeleteKey() {
        logger.log(Level.INFO, "Pressed DELETE key: task index  " + getCurrentListViewController().getSelectedIndex());
        int taskIndex = getCurrentListViewController().getSelectedIndex();
        int actualIndex = getCurrentListViewController().getDisplayIndex(taskIndex);

        taskIndexesToBeExecuted = new ArrayList<>(1);
        taskIndexesToBeExecuted.add(actualIndex);
        listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
        taskToBeExecuted = getCurrentList().get(getCurrentListViewController().getSelectedIndex());
        commandToBeExecuted = new DeleteCommand(receiver, getTasksToBeExecuted(taskIndexesToBeExecuted));
        invoker.execute(commandToBeExecuted);
        showExecutionResult(commandToBeExecuted, null);
    }

    /**
     *
     */
    private void handleCtrlTab() {
        SingleSelectionModel<Tab> selectionModel = tabPane.getSelectionModel();

        // already at the last tab, lets bounce back to first tab
        if (selectionModel.getSelectedIndex() == tabPane.getTabs().size() - 1) {
            selectionModel.selectFirst();
        } else {
            selectionModel.selectNext();
        }

        logger.log(Level.INFO, "Pressed CTRL+TAB key: current selected Tab is " + "\"" + getSelectedTabName() + "\"");
    }

    /**
     *
     */
    private void handleCtrlP() {
        Task oldTask = currentList.get(getCurrentListViewController().getSelectedIndex());
        commandToBeExecuted = new PriorityCommand(receiver, oldTask);
        invoker.execute(commandToBeExecuted);
        logger.log(Level.INFO,
                "Pressed CTRL+P key: Task " + getCurrentListViewController().getSelectedIndex() + 1 + " Priority");
    }

    /**
     *
     */
    private void handleCtrlD() {
        taskToBeExecuted = getCurrentList().get(getCurrentListViewController().getSelectedIndex());

        if (getSelectedTabName().equals(tabTodo.getText())) {
            logger.log(Level.INFO,
                    "Pressed CTRL+D key: Task " + (getCurrentListViewController().getSelectedIndex() + 1) + " done");
            taskIndexesToBeExecuted.clear();
            taskIndexesToBeExecuted.add(getCurrentListViewController().getSelectedIndex());
            // taskToBeExecuted =
            // getCurrentTaskList().get(getCurrentListViewController().getPreviousSelectedIndex());
            listOfTaskToBeExecuted.clear();
            listOfTaskToBeExecuted.add(taskToBeExecuted);
            commandToBeExecuted = new DoneCommand(receiver, listOfTaskToBeExecuted);

        } else if (getSelectedTabName().equals(tabCompleted.getText())) {
            logger.log(Level.INFO,
                    "Pressed CTRL+D key: Task " + (getCurrentListViewController().getSelectedIndex() + 1) + " undone");
            taskIndexesToBeExecuted.clear();
            taskIndexesToBeExecuted.add(getCurrentListViewController().getSelectedIndex());
            // taskToBeExecuted =
            // getCurrentTaskList().get(previousSelectedTaskIndex);
            listOfTaskToBeExecuted.clear();
            listOfTaskToBeExecuted.add(taskToBeExecuted);
            commandToBeExecuted = new UndoneCommand(receiver, listOfTaskToBeExecuted);
        }

        invoker.execute(commandToBeExecuted);

        showExecutionResult(commandToBeExecuted, null);
        if (!chipSearchMode.getText().equals("")) {
            invoker.execute(searchCommand);
        }
        logger.log(Level.INFO,
                "Pressed CTRL+D key: Task " + (getCurrentListViewController().getSelectedIndex() + 1) + " done");

    }

    /**
     *
     */
    private void extractUserInput() {
        userInputArray = userInput.split(" ");
        userCommand = userInputArray[0].toLowerCase();
        if (userInputArray.length > 1) {
            userArguments = userInput.substring(userCommand.length() + 1);
            logger.log(Level.INFO, "Extracted user arguments: " + userArguments);
        }
    }

    /**
     *
     */
    private void parseUserInput() {
        commandToBeExecuted = null;
        switch (userCommand) {
            case STRING_COMMAND_EDIT :
                parseEdit();
                break;
            case STRING_COMMAND_DELETE :
            case STRING_COMMAND_DELETE_SHORTHAND :
                parseDelete();
                break;
            case STRING_COMMAND_SEARCH :
                parseSearch();
                break;
            case STRING_COMMAND_DONE :
                parseDone();
                break;
            case STRING_COMMAND_UNDONE :
                parseUndone();
                break;
            case STRING_COMMAND_UNDO :
                parseUndo();
                break;
            case STRING_COMMAND_REDO :
                parseRedo();
                break;
            case STRING_COMMAND_SET_FILE_LOCATION :
                parseSetFileLocation();
                break;
            case STRING_COMMAND_EXIT :
            case STRING_COMMAND_CLOSE :
            case STRING_COMMAND_QUIT :
                parseExit();
                break;
            default:
                parseAdd();
        }
    }

    private void parseExit() {
        showFeedback(true, STRING_FEEDBACK_ACTION_EXIT, "");
    }

    /**
     *
     */
    private void parseAdd() {
        logger.log(Level.INFO, "Sending user input to commandParser: " + userInput);

        try {
            taskToBeExecuted = commandParser.parseAdd(userInput);
            commandToBeExecuted = new AddCommand(receiver, taskToBeExecuted);
            inputFeedback = taskToBeExecuted.toString();
            showFeedback(true, STRING_FEEDBACK_ACTION_ADD, inputFeedback);

        } catch (InvalidLabelFormat e) {
            logger.log(Level.INFO, "ADD command has invalid label.");
        }
    }

    private void parseDelete() {
        if (userInputArray.length <= 1) {
            logger.log(Level.INFO, "DELETE command has no index. Interpreting as ADD command instead");
            parseAdd(); // no index found. parse the input as an Add operation
                        // instead
            return;
        }

        if (userArguments.toLowerCase().equals("all")) {
            // previousSelectedTaskIndex = 0;
            ArrayList<Task> tasksToDelete = new ArrayList<Task>();
            for (Task task : getCurrentList()) {
                if (!(task instanceof TaskHeader)) {
                    tasksToDelete.add(task);
                }
            }
            listOfTaskToBeExecuted = tasksToDelete;
            commandToBeExecuted = new DeleteCommand(receiver, listOfTaskToBeExecuted);
            getCurrentListViewController().clearListViewSelection();
            getCurrentListViewController().selectAll();

            int numberOfTasks = 0;
            for (Task task : getCurrentList()) {
                if (!(task instanceof TaskHeader)) {
                    numberOfTasks++;
                }
            }

            showFeedback(true, STRING_FEEDBACK_ACTION_DELETE,
                    userArguments + STRING_WHITESPACE + String.format(STRING_FEEDBACK_TOTAL_TASK, numberOfTasks));
            return;

        }

        logger.log(Level.INFO, "Sending user input to commandParser: " + userInput);
        ParseIndexResult parseIndexResult;
        try {
            parseIndexResult = commandParser.parseIndexes(userInput, getCurrentList().size());

            if (parseIndexResult.hasInvalidIndex()) {
                throw new IndexOutOfBoundsException();
            }

            if (parseIndexResult.hasValidIndex()) {
                taskIndexesToBeExecuted = parseIndexResult.getValidIndexes();

                if (taskIndexesToBeExecuted.size() == 1) { // when there's only
                                                           // 1
                                                           // index
                    int taskIndex = taskIndexesToBeExecuted.get(0);
                    int actualIndex = getCurrentListViewController().getActualIndex(taskIndex);
                    inputFeedback = getCurrentList().get(actualIndex).toString();
                    taskToBeExecuted = getCurrentList().get(actualIndex);
                    listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
                    commandToBeExecuted = new DeleteCommand(receiver, listOfTaskToBeExecuted);
                    getCurrentListViewController().clearListViewSelection();
                    getCurrentListViewController().select(taskIndex);
                    showFeedback(true, STRING_FEEDBACK_ACTION_DELETE, inputFeedback);

                    // when there's a range of indexes
                } else if (taskIndexesToBeExecuted.size() > 1) {
                    listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
                    commandToBeExecuted = new DeleteCommand(receiver, listOfTaskToBeExecuted);
                    getCurrentListViewController()
                            .clearAndSelect(taskIndexesToBeExecuted.get(taskIndexesToBeExecuted.size() - 1));
                    for (int index : taskIndexesToBeExecuted) {
                        getCurrentListViewController().select(index);
                    }
                    showFeedback(true, STRING_FEEDBACK_ACTION_DELETE, userArguments + STRING_WHITESPACE
                            + String.format(STRING_FEEDBACK_TOTAL_TASK, listOfTaskToBeExecuted.size()));
                }
            } else {
                taskIndexesToBeExecuted.clear();
            }
        } catch (InvalidTaskIndexFormat invalidTaskIndexFormat) {
            logger.log(Level.INFO, "DELETE command index(es) invalid: " + userArguments);
            getCurrentListViewController().clearListViewSelection();
            showFeedback(true, STRING_FEEDBACK_ACTION_DELETE, String.format(STRING_ERROR_NOT_FOUND, userArguments));
            clearStoredUserInput();
            return;
        } catch (Exception e) {
            logger.log(Level.INFO, "DELETE command index(es) invalid: " + userArguments);
            getCurrentListViewController().clearListViewSelection();
            showFeedback(true, STRING_FEEDBACK_ACTION_DELETE, String.format(STRING_ERROR_NOT_FOUND, userArguments));
            clearStoredUserInput();
            return;
        }

    }

    private void parseEdit() {
        if (userInputArray.length <= 1) {
            logger.log(Level.INFO, "EDIT command has no arguments. Interpreting as ADD command instead");
            // no arguments found. parse the input as an Add operation instead
            parseAdd();
            return;
        }

        int taskIndex = commandParser.getIndexForEdit(userInput);
        logger.log(Level.INFO, "EDIT command index is " + taskIndex);

        // parsing edit command with index
        try {
            logger.log(Level.INFO, "EDIT command index is " + taskIndex);
            int actualIndex = getCurrentListViewController().getActualIndex(taskIndex);
            Task taskToBeEdited = getCurrentList().get(actualIndex);
            showFeedback(true, STRING_FEEDBACK_ACTION_EDIT, taskToBeEdited.toString());
            userArguments = userInput.substring(userInputArray[0].length() + userInputArray[1].length() + 1).trim();
            logger.log(Level.INFO, "EDIT command arguments is: " + userArguments);
            taskToBeExecuted = commandParser.parseEdit(taskToBeEdited, userArguments);
            commandToBeExecuted = new EditCommand(receiver, taskToBeEdited, taskToBeExecuted);
            getCurrentListViewController().clearAndSelect(taskIndex);
            return;
        } catch (IndexOutOfBoundsException ioobe) {
            logger.log(Level.WARNING, "EDIT command index is out of range. index = " + taskIndex + " ArrayList size = "
                    + currentList.size());
            showFeedback(true, STRING_FEEDBACK_ACTION_EDIT, String.format(STRING_ERROR_NOT_FOUND, userInputArray[1]));
            clearStoredUserInput();
            return;
        } catch (InvalidLabelFormat e) {
            logger.log(Level.WARNING, "EDIT command has invalid label.");
        }

    }

    /**
     *
     */
    private void parseSearch() {
        if (userInput.equals(STRING_COMMAND_SEARCH)) {
            userArguments = STRING_WHITESPACE;
        }

        logger.log(Level.INFO, "Searching: " + userArguments);

        Date dateFromUserInput = commandParser.getDateForSearch(userArguments);

        // search input contains no date
        if (dateFromUserInput == null) {
            logger.log(Level.INFO, "SEARCH command has no date: " + userArguments);
            commandToBeExecuted = new SearchCommand(receiver, userArguments);
            searchCommand = new SearchCommand(receiver, userArguments.toString());
        } else {
            logger.log(Level.INFO, "SEARCH command has date: " + userArguments);
            commandToBeExecuted = new SearchCommand(receiver, dateFromUserInput);
            searchCommand = new SearchCommand(receiver, dateFromUserInput);
        }
        invoker.execute(commandToBeExecuted);
    }

    private void parseDone() {
        // no index found. parse the input as an Add operation instead
        if (userInputArray.length <= 1) {
            logger.log(Level.INFO, "DONE command has no index. Interpreting as ADD command instead");
            parseAdd();
            return;
        }

        if (userArguments.toLowerCase().equals("all")) {
            ArrayList<Task> tasksToDone = new ArrayList<Task>();

            for (Task task : getCurrentList()) {
                if (!(task instanceof TaskHeader)) {
                    tasksToDone.add(task);
                }
            }

            listOfTaskToBeExecuted = tasksToDone;
            commandToBeExecuted = new DoneCommand(receiver, listOfTaskToBeExecuted);
            getCurrentListViewController().clearListViewSelection();
            getCurrentListViewController().selectAll();

            int numberOfTasks = listOfTaskToBeExecuted.size();

            showFeedback(true, STRING_FEEDBACK_ACTION_DONE,
                    userArguments + STRING_WHITESPACE + String.format(STRING_FEEDBACK_TOTAL_TASK, numberOfTasks));
            return;
        }

        logger.log(Level.INFO, "Sending user input to commandParser: " + userInput);
        ParseIndexResult parseIndexResult;
        try {
            parseIndexResult = commandParser.parseIndexes(userInput, getCurrentList().size());

            if (parseIndexResult.hasInvalidIndex()) {
                throw new IndexOutOfBoundsException();
            }
            if (parseIndexResult.hasValidIndex()) {
                taskIndexesToBeExecuted = parseIndexResult.getValidIndexes();

                if (taskIndexesToBeExecuted.size() == 1) { // when there's only
                                                           // 1
                                                           // index
                    int taskIndex = taskIndexesToBeExecuted.get(0);
                    int actualIndex = getCurrentListViewController().getActualIndex(taskIndex);
                    inputFeedback = getCurrentList().get(actualIndex).toString();
                    taskToBeExecuted = getCurrentList().get(actualIndex);
                    listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
                    commandToBeExecuted = new DoneCommand(receiver, listOfTaskToBeExecuted);
                    getCurrentListViewController().clearListViewSelection();
                    getCurrentListViewController().select(taskIndex);
                    showFeedback(true, STRING_FEEDBACK_ACTION_DONE, inputFeedback);

                } else if (taskIndexesToBeExecuted.size() > 1) { // when there's
                                                                 // a
                                                                 // range of
                                                                 // indexes
                    listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
                    commandToBeExecuted = new DoneCommand(receiver, listOfTaskToBeExecuted);
                    getCurrentListViewController()
                            .clearAndSelect(taskIndexesToBeExecuted.get(taskIndexesToBeExecuted.size() - 1));
                    for (int index : taskIndexesToBeExecuted) {
                        getCurrentListViewController().select(index);
                    }
                    showFeedback(true, STRING_FEEDBACK_ACTION_DONE, userArguments + STRING_WHITESPACE
                            + String.format(STRING_FEEDBACK_TOTAL_TASK, listOfTaskToBeExecuted.size()));
                }
            } else {
                taskIndexesToBeExecuted.clear();
            }
        } catch (InvalidTaskIndexFormat invalidTaskIndexFormat) {
            logger.log(Level.INFO, "DONE command index(es) invalid: " + userArguments);
            getCurrentListViewController().clearListViewSelection();
            showFeedback(true, STRING_FEEDBACK_ACTION_DONE, String.format(STRING_ERROR_NOT_FOUND, userArguments));
            clearStoredUserInput();
            return;
        } catch (Exception e) {
            logger.log(Level.INFO, "DONE command index(es) invalid: " + userArguments);
            getCurrentListViewController().clearListViewSelection();
            showFeedback(true, STRING_FEEDBACK_ACTION_DONE, String.format(STRING_ERROR_NOT_FOUND, userArguments));
            clearStoredUserInput();
            return;
        }
    }

    private void parseUndone() {
        if (userInputArray.length <= 1) {
            logger.log(Level.INFO, "UNDONE command has no index. Interpreting as ADD command instead");
            parseAdd(); // no index found. parse the input as an Add operation
                        // instead
            return;
        }

        if (userArguments.toLowerCase().equals("all")) {
            // previousSelectedTaskIndex = 0;
            ArrayList<Task> tasksToUndone = new ArrayList<Task>();
            for (Task task : getCurrentList()) {
                if (!(task instanceof TaskHeader)) {
                    tasksToUndone.add(task);
                }
            }
            listOfTaskToBeExecuted = tasksToUndone;
            commandToBeExecuted = new UndoneCommand(receiver, listOfTaskToBeExecuted);
            getCurrentListViewController().clearListViewSelection();
            getCurrentListViewController().selectAll();

            int numberOfTasks = 0;
            for (Task task : getCurrentList()) {
                if (!(task instanceof TaskHeader)) {
                    numberOfTasks++;
                }
            }

            showFeedback(true, STRING_FEEDBACK_ACTION_UNDONE,
                    userArguments + STRING_WHITESPACE + String.format(STRING_FEEDBACK_TOTAL_TASK, numberOfTasks));
            return;

        }

        logger.log(Level.INFO, "Sending user input to commandParser: " + userInput);
        ParseIndexResult parseIndexResult;
        try {
            parseIndexResult = commandParser.parseIndexes(userInput, getCurrentList().size());

            if (parseIndexResult.hasInvalidIndex()) {
                throw new IndexOutOfBoundsException();
            }
            if (parseIndexResult.hasValidIndex()) {
                taskIndexesToBeExecuted = parseIndexResult.getValidIndexes();

                if (taskIndexesToBeExecuted.size() == 1) { // when there's only
                                                           // 1
                                                           // index
                    int taskIndex = taskIndexesToBeExecuted.get(0);
                    int actualIndex = getCurrentListViewController().getActualIndex(taskIndex);
                    inputFeedback = getCurrentList().get(actualIndex).toString();
                    taskToBeExecuted = getCurrentList().get(actualIndex);
                    listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
                    commandToBeExecuted = new UndoneCommand(receiver, listOfTaskToBeExecuted);
                    getCurrentListViewController().clearListViewSelection();
                    getCurrentListViewController().select(taskIndex);
                    showFeedback(true, STRING_FEEDBACK_ACTION_UNDONE, inputFeedback);

                } else if (taskIndexesToBeExecuted.size() > 1) { // when there's
                                                                 // a
                                                                 // range of
                                                                 // indexes
                    listOfTaskToBeExecuted = getTasksToBeExecuted(taskIndexesToBeExecuted);
                    commandToBeExecuted = new UndoneCommand(receiver, listOfTaskToBeExecuted);
                    getCurrentListViewController()
                            .clearAndSelect(taskIndexesToBeExecuted.get(taskIndexesToBeExecuted.size() - 1));
                    for (int index : taskIndexesToBeExecuted) {
                        getCurrentListViewController().select(index);
                    }
                    showFeedback(true, STRING_FEEDBACK_ACTION_UNDONE, userArguments + STRING_WHITESPACE
                            + String.format(STRING_FEEDBACK_TOTAL_TASK, listOfTaskToBeExecuted.size()));
                }
            } else {
                taskIndexesToBeExecuted.clear();
            }
        } catch (InvalidTaskIndexFormat invalidTaskIndexFormat) {
            logger.log(Level.INFO, "UNDONE command index(es) invalid: " + userArguments);
            getCurrentListViewController().clearListViewSelection();
            showFeedback(true, STRING_FEEDBACK_ACTION_UNDONE, String.format(STRING_ERROR_NOT_FOUND, userArguments));
            clearStoredUserInput();
            return;
        } catch (Exception e) {
            logger.log(Level.INFO, "UNDONE command index(es) invalid: " + userArguments);
            getCurrentListViewController().clearListViewSelection();
            showFeedback(true, STRING_FEEDBACK_ACTION_UNDONE, String.format(STRING_ERROR_NOT_FOUND, userArguments));
            clearStoredUserInput();
            return;
        }
    }

    private void parseUndo() {
        numberOfActions = commandParser.getIndexForEdit(userInput);
        if (numberOfActions >= 0) {
            showFeedback(true, STRING_FEEDBACK_ACTION_UNDO,
                    String.format(STRING_FEEDBACK_TOTAL_ACTION, numberOfActions));
        } else {
            showFeedback(true, STRING_FEEDBACK_ACTION_UNDO, String.format(STRING_FEEDBACK_TOTAL_ACTION, 1));
        }
    }

    private void parseRedo() {
        numberOfActions = commandParser.getIndexForEdit(userInput);
        if (numberOfActions >= 0) {
            showFeedback(true, STRING_FEEDBACK_ACTION_REDO,
                    String.format(STRING_FEEDBACK_TOTAL_ACTION, numberOfActions));
        } else {
            showFeedback(true, STRING_FEEDBACK_ACTION_REDO, String.format(STRING_FEEDBACK_TOTAL_ACTION, 0));
        }

    }

    private void parseSetFileLocation() {
        showFeedback(true, STRING_FEEDBACK_ACTION_SET_FILE_LOCATION, userArguments);
        if (userInputArray.length <= 1) {
            logger.log(Level.INFO, "SET command has no arguments.");
            // no arguments found. parse the input as an Add operation instead
            commandToBeExecuted = new SetFileLocationCommand(receiver, "");
        } else {
            logger.log(Level.INFO, "SET command arguments: " + userArguments);
            commandToBeExecuted = new SetFileLocationCommand(receiver, userArguments);
        }

    }

    private File showFileChooserDialog() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Set file location");
        fileChooser.getExtensionFilters().addAll(new ExtensionFilter("Text Files", "*.txt"));
        fileChooser.setInitialFileName("tasks");

        fileChooser.setInitialDirectory(new File(receiver.getFileDir()));
        File selectedFile = fileChooser.showSaveDialog(mainApp.getPrimaryStage());

        return selectedFile;
    }

    private String getFilePath(File selectedFile) {
        String selectedFilePath = "";
        try {
            selectedFilePath = selectedFile.getCanonicalPath();
            return selectedFilePath;
        } catch (IOException e) {
            // TODO show some feedback about invalid filepath
            logger.log(Level.WARNING, "File path is invalid");
        }

        return selectedFilePath;
    }

    /**
    *
    */
    private ArrayList<Task> getTasksToBeExecuted(ArrayList<Integer> taskIndexes) {
        ArrayList<Task> tasksToBeDeleted = new ArrayList<>(taskIndexes.size());
        for (Integer index : taskIndexes) {
            int actualIndex = getCurrentListViewController().getActualIndex(index);
            tasksToBeDeleted.add(getCurrentList().get(actualIndex));
        }
        return tasksToBeDeleted;
    }

    /**
     *
     */
    private void clearStoredUserInput() {
        userInput = STRING_EMPTY;
        userInputArray = null;
        userCommand = STRING_EMPTY;
        userArguments = STRING_EMPTY;
    }

    /**
     *
     */
    private void showFeedback(boolean isVisible, String userAction, String userFeedback) {
        if (isVisible) {
            logger.log(Level.INFO, "Showing user feedback: " + userFeedback);
        }

        textUserAction.setText(userAction + STRING_WHITESPACE);
        // textUserAction.setFont(new Font(20));
        textUserAction.setFill(Color.web("303F9F", 0.7));
        textUserParsedResult.setText(userFeedback);
        // textUserParsedResult.setFont(new Font(20));
        textUserParsedResult.setFill(Color.web("#00111a", 0.7));

        // textFlowFeedback.getChildren().clear();
        // textFlowFeedback.getChildren().addAll(textUserAction,
        // textUserParsedResult);

        // labelUserAction.setVisible(isVisible);
        // labelUserParsedInput.setVisible(isVisible);
        // labelUserAction.setText(userAction);
        // labelUserParsedInput.setText(userFeedback);
    }

    /**
     *
     */
    private void showExecutionResult(Command executedCommand, String undoOrRedo) {
        logger.log(Level.INFO, "Showing user execution result: ");

        if (executedCommand instanceof AddCommand) {
            if (undoOrRedo != null) {
                labelExecutedCommand.setText(undoOrRedo + STRING_WHITESPACE + "add.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_WHITE));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));

            } else {
                labelExecutedCommand.setText("Added:");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_BLUE_LIGHT, 0.7));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0.9));
                labelExecutionDetails.setText(taskToBeExecuted.toString());
            }

        }

        if (executedCommand instanceof EditCommand) {
            if (undoOrRedo != null) {
                labelExecutedCommand.setText(undoOrRedo + STRING_WHITESPACE + "edit.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_WHITE));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            } else {
                labelExecutedCommand.setText("Edited:");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_GREEN_LIGHT, 0.7));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0.9));
                labelExecutionDetails.setText(taskToBeExecuted.toString());
            }

        }
        // TODO deleting something will not show the deleted item toString()
        if (executedCommand instanceof DeleteCommand) {
            if (undoOrRedo != null) {
                labelExecutedCommand.setText(undoOrRedo + STRING_WHITESPACE + "delete.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_WHITE));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            } else {
                labelExecutedCommand.setText("Deleted:");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_RED_LIGHT, 0.7));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0.9));

                if (listOfTaskToBeExecuted.size() == 1) {
                    labelExecutionDetails.setText(taskToBeExecuted.toString());
                } else if (listOfTaskToBeExecuted.size() > 1) {
                    labelExecutionDetails.setText(listOfTaskToBeExecuted.size() + " tasks");
                } else if (userArguments != null && userArguments.toLowerCase().equals("all")) {
                    // TODO very dirty. refactor for better checking
                    labelExecutionDetails.setText("all");
                }
            }

        }

        if (executedCommand instanceof DoneCommand) {
            if (undoOrRedo != null) {
                labelExecutedCommand.setText(undoOrRedo + STRING_WHITESPACE + "task completed.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_WHITE));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            } else {
                labelExecutedCommand.setText(listOfTaskToBeExecuted.size() + STRING_WHITESPACE + "task completed.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_LIME_LIGHT, 0.7));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            }

        }

        if (executedCommand instanceof UndoneCommand) {
            if (undoOrRedo != null) {
                labelExecutedCommand.setText(undoOrRedo + STRING_WHITESPACE + "mark task as incomplete.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_WHITE));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            } else {
                labelExecutedCommand
                        .setText("Mark " + listOfTaskToBeExecuted.size() + STRING_WHITESPACE + "task as incomplete.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_LIME_LIGHT, 0.7));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            }

        }

        if (executedCommand instanceof SetFileLocationCommand) {
            if (undoOrRedo != null) {
                labelExecutedCommand.setText(undoOrRedo + STRING_WHITESPACE + "new file location.");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_WHITE));
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0));
            } else {
                labelExecutedCommand.setText("Set:");
                labelExecutedCommand.setTextFill(Color.web(AppColor.PRIMARY_BLUE_LIGHT, 0.7));
                labelExecutionDetails.setText("New file location has been set.");
                labelExecutionDetails.setTextFill(Color.web(AppColor.PRIMARY_WHITE, 0.9));
            }

        }

        if (undoOrRedo != null) {
            if (undoOrRedo.equals("Undo")) {
                labelSuggestedAction.setText("REDO (F2)");
            } else if (undoOrRedo.equals("Redo")) {
                labelSuggestedAction.setText("UNDO (F1)");
            }
        } else {
            labelSuggestedAction.setText("UNDO (F1)");
        }

        FadeTransition appearVisible = new FadeTransition(Duration.seconds(2), anchorPaneExecutionResult);
        appearVisible.setFromValue(1);
        appearVisible.setToValue(1);
        appearVisible.setCycleCount(1);
        FadeTransition fade = new FadeTransition(Duration.seconds(1), anchorPaneExecutionResult);
        fade.setFromValue(1);
        fade.setToValue(0);
        fade.setCycleCount(1);

        SequentialTransition st = new SequentialTransition();
        st.getChildren().clear();
        st.getChildren().addAll(appearVisible, fade);
        st.play();

    }

    private ListViewController getCurrentListViewController() {
        return currentListViewController;
    }

    private ArrayList<Task> getCurrentList() {
        return currentList;
    }

    private void setCurrentListViewController(String tabName) {
        if (tabName.equals(tabTodo.getText())) {
            currentListViewController = todoListViewController; //
        } else if (tabName.equals(tabCompleted.getText())) {
            currentListViewController = completedListViewController; // completedController
        }
    }

    private void setCurrentList(String tabName) {
        if (tabName.equals(tabTodo.getText())) {
            currentList = todoTasksWithHeaders;
        } else if (tabName.equals(tabCompleted.getText())) {
            currentList = completedTasksWithHeaders;
        }
    }

    /**
     * @return String
     */
    private String getSelectedTabName() {
        return tabPane.getSelectionModel().getSelectedItem().getText();
    }

    /**
     *
     */
    private void saveCaretPosition() {
        previousCaretPosition = commandBar.getCaretPosition();
        logger.log(Level.INFO, "Save caret position to " + previousCaretPosition);
    }

    public Command getLastExecutedCommand() {
        return commandToBeExecuted;
    }

    public void restoreListViewPreviousSelection() {
        getCurrentListViewController().restoreListViewPreviousSelection();
        // TODO one more line for completedtaskcontroller
    }

    private void toggleHelpDialog() {
        if(!dialogHelp.isVisible()){
            dialogHelp.show(dialogContainer);
        }
        else{
            dialogHelp.close();
        }

    }
}
```
