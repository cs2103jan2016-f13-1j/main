# A0126297X
###### /src/main/data/ParseIndexResult.java
``` java
package main.data;

import java.util.ArrayList;

public class ParseIndexResult {
	private boolean hasValid;
	private boolean hasInvalid;
	private ArrayList<Integer> validIndexes;
	private ArrayList<Integer> invalidIndexes;
	
	public ParseIndexResult() {
		hasValid = false;
		hasInvalid = false;
		validIndexes = null;
		invalidIndexes = null;
	}
	
	public boolean hasValidIndex() {
		return hasValid;
	}
	
	public void setHasValid(boolean hasValid) {
		this.hasValid = hasValid;
	}
	
	public boolean hasInvalidIndex(){
		return hasInvalid;
	}
	
	public void setHasInvalid(boolean hasInvalid) {
		this.hasInvalid = hasInvalid;
	}
	
	public ArrayList<Integer> getValidIndexes() {
		return validIndexes;
	}

	public void setValidIndexes(ArrayList<Integer> validIndexes) {
		this.validIndexes = validIndexes;
	}
	
	public ArrayList<Integer> getInvalidIndexes() {
		return invalidIndexes;
	}

	public void setInvalidIndexes(ArrayList<Integer> invalidIndexes) {
		this.invalidIndexes = invalidIndexes;
	}
	
	public String getValidIndexesString() {
		return convertIndexesToString(validIndexes);
	}
	
	public String getInvalidIndexesString() {
		return convertIndexesToString(invalidIndexes);
	}
	
	/**
	 * This method converts an {@code ArrayList<Integer>} of indexes to {@code String}.
	 * This method is used by the UI.
	 * 
	 * @param indexes
	 * 			{@code ArrayList<Integer>} to be converted
	 * @return {@code String} of converted indexes
	 */
	private String convertIndexesToString(ArrayList<Integer> indexes) {
		StringBuilder stringBuilder = new StringBuilder();
    	boolean isRange = false;
    	
    	int start = indexes.get(0);
    	stringBuilder.append(start);
    	
    	for (int i = 1; i < indexes.size(); i++) {
    		int next = indexes.get(i);
    		
    		if ((next-1) == start) {
    			isRange = true;
    			start = next;
    		} else {
    			if (isRange) {
    				stringBuilder.append("-" + start);
    				isRange = false;
    			} else {
    				stringBuilder.append(","+start);
    			}
      			start = next;
      			stringBuilder.append(","+start);
    		}
    	}
    	
    	if (isRange) {
    		//account for having a range at the end
    		stringBuilder.append("-"+start);
    	}
    	
    	return stringBuilder.toString();
	}
}
```
###### /src/main/data/Task.java
``` java
package main.data;

import java.text.DateFormatSymbols;
import java.text.SimpleDateFormat;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;

public class Task {	   
    private String title;
    private Date startDate;
    private Date endDate;
    private boolean isDatedOnly;
    private String label;
    private boolean done;
    private int priority;
    private Date createdDate;
    private Date completedDate;
    private boolean collideWithPrev;
    private boolean collideWithNext;
    
    public Task(String title) {
        this.title = title;
        startDate = null;
        endDate = null;
        isDatedOnly = false;
        label = null;
        done = false;
        priority = 0;
        createdDate = new Date();
        completedDate = null;
        collideWithPrev = false;
        collideWithNext = false;
    }

    public Task(String title, Date startDate, Date endDate, String label) {
    	this.title = title;
    	this.startDate = startDate;
    	this.endDate = endDate;
    	isDatedOnly = false;
    	this.label = label;
    	done = false;
    	priority = 0;
    	createdDate = new Date();
    	completedDate = null;
    	collideWithPrev = false;
    	collideWithNext = false;
    }
        
    public String getTitle() {
        return title;
    }
    
    public Date getStartDate() {
        return startDate;
    }
    
    public Date getEndDate() {
        return endDate;
    }
    public boolean getIsDatedOnly() {
    	return isDatedOnly;
    }
    
    public void setIsDatedOnly(boolean isDatedOnly) {
    	this.isDatedOnly = isDatedOnly;
    }
    
    public String getLabel() {
        return label;
    }
    
    public boolean hasLabel() {
        if (label == null) {
            return false;
        } else {
            return true;
        }
    }
    
    public boolean isDone() {
        return done;
    }
    
    public void toggleDone() {
    	if (isDone()) {
    		setNotCompleted();
    	} else {
    		setIsCompleted();
    	}
    }
    
    public int getPriority() {
        return priority;
    }
    
    public void setPriority(int priority) {
    	this.priority = priority;
    }
    
    public int togglePriority(boolean increase) {
    	int limit = 3;
    	if (increase) {
    	    priority++;
            if (priority > limit) {
                priority = 0;
            }
    	} else {
    	    priority--;
    	    if (priority < 0) {
    	        priority = limit;
    	    }
    	}
    	return priority;
    }
    
    public Date getCreatedDate() {
        return createdDate;
    }
    
    public void setCreatedDate(Date createdDate) {
    	this.createdDate = createdDate;
    }
    
    public Date getCompletedDate() {
        return completedDate;
    }
    
    public void setIsCompleted() {
        done = true;
        completedDate = new Date();
    }
    
    public void setNotCompleted() {
        done = false;
        completedDate = null;
    }
    
    public boolean getCollideWithPrev() {
        return collideWithPrev;
    }
    
    public void setCollideWithPrev(boolean collide) {
        collideWithPrev = collide;
    }
    
    public boolean getCollideWithNext() {
        return collideWithNext;
    }
    
    public void setCollideWithNext(boolean collide) {
        collideWithNext = collide;
    }
    
    public boolean hasDate() {
        return (startDate != null || endDate != null);
    }
    
    public boolean hasDateRange() {
        return (startDate != null && endDate != null);
    }
    
    public boolean hasStartDate() {
        if (startDate == null) {
            return false;
        } else {
            return true;
        }
    }
    
    public boolean hasEndDate() {
        if (endDate == null) {
            return false;
        } else {
            return true;
        }
    }
    
    public boolean hasSingleDate() {
        if (startDate == null && endDate != null) {
            return true;
        } else if (startDate != null & endDate == null) {
            return true;
        } else {
            return false;
        }
    }
    
    public Date getSingleDate() {
        if (startDate == null && endDate != null) {
            return endDate;
        } else {
            return startDate;
        }
    }

    public int compareTo(Task task) {
        if (!createdDate.equals(task.getCreatedDate())) {
            return -1;
        }
    	return 0;
    }

    /* (non-Javadoc)
     * @see java.lang.Object#toString()
     * This method generates the task feedback for UI to display to user.
     */
    public String toString() {
    	if (hasDate()) {
    		if (hasDateRange()) {
    			return getFeedbackForRange();
    		} else if (hasStartDate()) {
    			return getFeedbackForStart();
    		} else if (hasEndDate()) {
    			return getFeedbackForEnd();
    		}
    	}
    	return getFeedbackForFloating();
    }
    
    private String getFeedbackForRange() {
    	int indexTitle = 0;
    	int indexStartDate = 1;
    	int indexStartTime = 2;
    	int indexStartYear = 3;
    	int indexEndDate = 4;
    	int indexEndTime = 5;
    	int indexEndYear = 6;
    	int indexIsDatedOnly = 9;
    	
    	ArrayList<String> fields = getTaskFields();
    	String title = fields.get(indexTitle);
    	String startDate = fields.get(indexStartDate);
    	String startTime = fields.get(indexStartTime);
    	String startYear = fields.get(indexStartYear);
    	String endDate = fields.get(indexEndDate);
    	String endTime = fields.get(indexEndTime);
    	String endYear = fields.get(indexEndYear);
    	String isDatedOnly = fields.get(indexIsDatedOnly);
    	
    	boolean isSameDay = startDate.equals(endDate) && startYear == null && endYear == null;
    	boolean isToday = startDate.equals(endDate) && startDate.equals("today");
    	
       	StringBuilder stringBuilder = new StringBuilder(title);
       	
       	if (isSameDay) {
       		stringBuilder.append(" " + startDate);
       	} else {
       		stringBuilder.append(" from " + startDate);
       	}
    	
    	if (startYear != null) {
    		stringBuilder.append(" " + startYear);
    	}

    	if (isToday) {
    		stringBuilder.append(" at");
    	} else if (isSameDay) {
    		stringBuilder.append(" from");
    	}
    	
    	if (!isDatedOnly.equals("true")) {
    		stringBuilder.append(" " + startTime);
    	}

    	if (isSameDay) {
    		stringBuilder.append(" - " + endTime);
    	} else {
    		stringBuilder.append(" - " + endDate);

    		if (endYear != null) {
    			stringBuilder.append(" " + endYear);
    		}

    		if (!isDatedOnly.equals("true")) {
    			stringBuilder.append(" " + endTime);
    		}
    	}
    	String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
    	return feedback;
    }
    
    private String getFeedbackForStart() {
    	int indexTitle = 0;
    	int indexStartDate = 1;
    	int indexStartTime = 2;
    	int indexStartYear = 3;
    	int indexIsDatedOnly = 9;
    	
    	ArrayList<String> fields = getTaskFields();
    	String title = fields.get(indexTitle);
    	String startDate = fields.get(indexStartDate);
    	String startTime = fields.get(indexStartTime);
    	String startYear = fields.get(indexStartYear);
    	String isDatedOnly = fields.get(indexIsDatedOnly);
    	
    	boolean isToday = startDate.equals("today");
    	
    	StringBuilder stringBuilder = new StringBuilder(title);
    	
    	if (isToday) {
    		stringBuilder.append(" " + startDate);
    	} else {
    		stringBuilder.append(" on " + startDate);
    	}
    	
		if (startYear != null) {
			stringBuilder.append(" " + startYear);
		}
		
		if (!isDatedOnly.equals("true")) {
			stringBuilder.append(" at " + startTime);
		}
		
    	String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
    	return feedback;
    }
    
    private String getFeedbackForEnd() {
    	int indexTitle = 0;
    	int indexEndDate = 4;
    	int indexEndTime = 5;
    	int indexEndYear = 6;
    	int indexIsDatedOnly = 9;
    	
    	ArrayList<String> fields = getTaskFields();
    	String title = fields.get(indexTitle);
    	String endDate = fields.get(indexEndDate);
    	String endTime = fields.get(indexEndTime);
    	String endYear = fields.get(indexEndYear);
    	String isDatedOnly = fields.get(indexIsDatedOnly);
    	
    	StringBuilder stringBuilder = new StringBuilder(title);
    	
    	stringBuilder.append(" by " + endDate);
		
		if (endYear != null) {
			stringBuilder.append(" " + endYear);
		}
		
		if (!isDatedOnly.equals("true")) {
			stringBuilder.append(" " + endTime);
		}
		
		String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
    	return feedback;
    }
    
    private String getFeedbackForFloating() {
    	int indexTitle = 0;    	
    	ArrayList<String> fields = getTaskFields();
    	String title = fields.get(indexTitle);
    	
    	StringBuilder stringBuilder = new StringBuilder(title);
    	String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
    	return feedback;
    }
    
    private String getFeedbackForLabelAndPriority(String feedback){
    	int indexLabel = 7;
    	int indexPriority = 8;
    	ArrayList<String> fields = getTaskFields();
    	String label = fields.get(indexLabel);
    	String priority = fields.get(indexPriority);
    	
    	if (label != null) {
    		feedback = feedback.concat(" #" + label);
    	}
    	
    	if (!priority.equals("0")) {
    		feedback = feedback.concat(" P:" + priority);
    	}
    	
    	return feedback;
    }
    
    /**
     * Get attributes that is in task object to form feedback
     * 
     * In order:
     * 0 - Title
     * 1 - Start Date
     * 2 - Start Time
     * 3 - Start Year
     * 4 - End Date
     * 5 - End Time
     * 6 - End Year
     * 7 - Label
     * 8 - Priority
     * 9 - isDatedOnly
     * 
     * @return ArrayList<String> of size 10
     */
    private ArrayList<String> getTaskFields() {
        ArrayList<String> fields = new ArrayList<String>();
        
        fields.add(title);
        
        if (hasDate()) {
        	if (hasStartDate()){
        		fields.add(convertDate(startDate));
            	fields.add(convertTime(startDate));
            	fields.add(convertYear(startDate));
        	} else {
        		fields.add(null);
            	fields.add(null);
            	fields.add(null);
        	}
        	
        	if (hasEndDate()) {
	        	fields.add(convertDate(endDate));
	        	fields.add(convertTime(endDate));
	        	fields.add(convertYear(endDate));
        	} else {
        		fields.add(null);
            	fields.add(null);
            	fields.add(null);
        	}
        } else {
        	fields.add(null);
        	fields.add(null);
        	fields.add(null);
        	fields.add(null);
        	fields.add(null);
        	fields.add(null);
        }
        
        if (hasLabel()) {
            fields.add(label);
        } else {
        	fields.add(null);
        }
        
        fields.add(Integer.toString(getPriority()));
        fields.add(String.valueOf(isDatedOnly));
        return fields;
    }
    
    private String convertDate(Date date) {
    	if (dateIsToday(date)) {
    		return "today";
    	}
    	
    	DayOfWeek day = getDay(date);
    	String dayShort = getShortDay(day);
    	
    	if (dateIsThisWeek(date)) {
    		return "this ".concat(dayShort);
    	} else if (dateIsNextWeek(date)){
    		return "next ".concat(dayShort);
    	} else {
    		Month month = getMonth(date);
    		String monthShort = getShortMonth(month);
    		return getDate(date).concat(" ").concat(monthShort);
    	}
    }
    
    public boolean dateIsToday(Date date) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("ddMMyyyy");
        String today = dateFormat.format(new Date());
        
        String dateString = dateFormat.format(date);
        if (today.equals(dateString)) {
            return true;
        } else {
        	return false;
        }
    }
    
    private DayOfWeek getDay(Date date) {
    	LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    	DayOfWeek day = dateTime.getDayOfWeek();
	    return day;
    }
    
    private static String getShortDay(DayOfWeek day) {
		 DateFormatSymbols symbols = new DateFormatSymbols();
		 String[] days = symbols.getShortWeekdays();
		 List<String> correctedDays = new ArrayList<String>(Arrays.asList(days)); 
		 correctedDays.remove(0);
		 correctedDays.remove(0);
		 correctedDays.add("Sun");
		 
		 int value = day.getValue() - 1;
		 return correctedDays.get(value);
	}
    
    private boolean dateIsThisWeek(Date date) {
    	Calendar calendar = Calendar.getInstance();
		calendar.setFirstDayOfWeek(Calendar.MONDAY);
		
		int currentWeek = calendar.get(Calendar.WEEK_OF_YEAR);
		
		calendar.setTime(date);
		int dateWeek = calendar.get(Calendar.WEEK_OF_YEAR);
		
		if (dateWeek == currentWeek) {
			return true;
		} else {
			return false;
		}
    }
    
    private boolean dateIsNextWeek(Date date) {
    	Calendar calendar = Calendar.getInstance();
		calendar.setFirstDayOfWeek(Calendar.MONDAY);
		
		int currentWeek = calendar.get(Calendar.WEEK_OF_YEAR);
		
		calendar.setTime(date);
		
		int dateWeek = calendar.get(Calendar.WEEK_OF_YEAR);
		int difference = dateWeek - currentWeek;
		
		if (difference == 1) {
			return true;
		} else {
			return false;
		}
    }
    
    private Month getMonth(Date date) {
    	LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    	Month month = dateTime.getMonth();
		return month;
    }
	
	private static String getShortMonth(Month month) {
		 DateFormatSymbols symbols = new DateFormatSymbols();
		 String[] months = symbols.getShortMonths();
		 int value = month.getValue() - 1;
		 return months[value];
	}
    
    private String getDate(Date date) {
    	LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
		return Integer.toString(dateTime.getDayOfMonth());
    }

    private String convertTime(Date date) {
    	SimpleDateFormat timeFormat = new SimpleDateFormat("mm");
    	String minute = timeFormat.format(date);
 
    	if (minute.equals("00")){
    		timeFormat = new SimpleDateFormat("ha");
    	} else {
    		timeFormat = new SimpleDateFormat("h:mma");
    	}
	     
	    DateFormatSymbols symbols = new DateFormatSymbols(Locale.getDefault());
        symbols.setAmPmStrings(new String[] {"am", "pm"});
        timeFormat.setDateFormatSymbols(symbols);
	    return timeFormat.format(date);
    }
    
    private String convertYear(Date date) {
    	LocalDateTime now = LocalDateTime.now();
    	String thisYear = Integer.toString(now.getYear());
    	String year = getYear(date);
    	
    	if (thisYear.equals(year)) {
    		return null;
    	} else {
    		return year;
    	}
    }
    
    private String getYear(Date date) {
		LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
		return Integer.toString(dateTime.getYear());
	}
	
    /**
     * This method formats the task's date for display purposes by the UI.
     * 
     * @return {@code String} of nicely formatted date
     */
    public String getSimpleDate() {
    	Locale locale = Locale.getDefault();
    	StringBuilder stringBuilder = new StringBuilder("");    	
    	String start, end, startMonthString, endMonthString;
    	start = end = startMonthString = endMonthString = "";
    	
    	LocalDateTime now = LocalDateTime.now();
    	String thisYear = Integer.toString(now.getYear());
    	
    	if (startDate != null) {
	    	Month startMonth = getMonth(startDate);
			startMonthString = startMonth.getDisplayName(TextStyle.FULL, locale);
			start = getDate(startDate).concat(" ").concat(startMonthString);
			
			if (!getYear(startDate).equals(thisYear)) {
	    		start = start.concat(" ").concat(getYear(startDate));
	    	}
    	}
    	
    	if (endDate != null) {
			Month endMonth = getMonth(endDate);
			endMonthString = endMonth.getDisplayName(TextStyle.FULL, locale);
			end = getDate(endDate).concat(" ").concat(endMonthString);
			
			if (!getYear(endDate).equals(thisYear)) {
	    		end = end.concat(" ").concat(getYear(endDate));
	    	}
    	}
    	
    	if (hasDateRange()) {
        	if (start.equals(end)) {
        		stringBuilder.append(start);
        	} else {
        		stringBuilder.append(start + " - " + end);
        	}
    	} else if (hasStartDate()) {
    		stringBuilder.append(start);
    	} else if (hasEndDate()) {
    		stringBuilder.append(end);
    	}
    	
    	return stringBuilder.toString();
    }
    
    /**
     * This method formats the task's time for display purposes by the UI.
     * 
     * @return {@code String} nicely formatted time
     */
    public String getSimpleTime() {
    	StringBuilder stringBuilder = new StringBuilder("");
    	int indexStartTime = 2;
    	int indexEndTime = 5;
    	
    	ArrayList<String> fields = getTaskFields();
    	String startTime = fields.get(indexStartTime);
    	String endTime = fields.get(indexEndTime);
    	
    	if (hasDateRange()) {
    		stringBuilder.append(startTime + " - " + endTime);
    	} else if (hasStartDate()) {
    		stringBuilder.append(startTime);
    	} else if (hasEndDate()) {
    		stringBuilder.append("by " + endTime);
    	} else {
    		//floating task
    		stringBuilder.append("-");
    	}
    	
    	if (getIsDatedOnly()) {
    		stringBuilder = new StringBuilder("-");
    	}
    	
    	return stringBuilder.toString();
    }
    
    /**
     * This method checks if a task is today.
     * If the task has a ranged time, it will always be today until it ends.
     * 
     * @return {@code boolean} true if is today
     */
    public boolean isToday() {
    	if (hasDateRange()) {
    		if (hasStarted()) {
    			return true;
    		} else {
    			return false;
    		}
    	} else if (hasDate()) {
    		return dateIsToday(getSingleDate());
    	}
    	
    	return false;
    }
    
    public boolean hasStarted() {
    	if (startDate == null) {
    		return false;
    	} else {
    		return (startDate.compareTo(new Date()) < 0);
    	}
    }
    
    /**
     * This method checks if a task is tomorrow.
     * 
     * If the task has a ranged time and it has started, check the end time.
     * If the end time is after tomorrow, then the task is tomorrow.
     * If the task has a ranged time and it has not started, check the start time.
     * If the start time is tomorrow, then the task is tomorrow.
     * 
     * @return {@code boolean} true if is tomorrow
     */
    public boolean isTomorrow() {   	
    	Calendar cal = Calendar.getInstance();
    	cal.setTime(new Date());
    	cal.add(Calendar.DATE, 1);
    	
    	SimpleDateFormat dateFormat = new SimpleDateFormat("ddMMyyyy");
    	String tomorrow = dateFormat.format(cal.getTime());
    	String starting = "";
    	String ending = "";
    	String single = "";
    	Date tml= null, start = null, end = null, singleDate = null;
    	
    	try {
    		tml = dateFormat.parse(tomorrow);
    	} catch (Exception e) {
    		return false;
    	}
    	
    	if (hasDateRange()) {
    		if (hasStarted()) {
    			ending = dateFormat.format(endDate);
    			
    			try {
    				end = dateFormat.parse(ending);
    			} catch (Exception e) {
    				return false;
    			}
    			
    			if (end.after(tml)) {
    				return true;
    			}
    		} else {
    			starting = dateFormat.format(startDate);
    			
    			try {
    				start = dateFormat.parse(starting);
    			} catch (Exception e) {
    				return false;
    			}
    			
    			if (start.equals(tml)) {
    				return true;
    			}
    		}
    	} else if (hasDate()) {
    		single = dateFormat.format(getSingleDate());
    		
    		try {
    			singleDate = dateFormat.parse(single);
    		} catch (Exception e) {
    			return true;
    		}
    		
    		if (singleDate.equals(tml)) {
    			return true;
    		}
    	}
    	return false;	
    }

    /**
     * This methods check if a task is upcoming.
     * An upcoming task must be after today and tomorrow.
     * 
     * @return {@code boolean} true if upcoming
     */
    public boolean isUpcoming() {
    	if (!isToday() && !isTomorrow()) {
    		Date today = new Date();

    		if (hasStartDate()) {
    			if (today.before(startDate)) {
    				return true;
    			}
    		} else if (hasEndDate()) { 
    			if (today.before(endDate)) {
    				return true;
    			}
    		} 			
    	}
    	return false;
    }
    
    /**
     * This method checks if a task is without date.
     * Since tasks have no date, it it start/due someday.
     * 
     * @return {@code boolean} true if not dated
     */
    public boolean isSomeday() {
    	if (hasDate()) {
    		return false;
    	} else {
    		return true;
    	}
    }
}
```
###### /src/main/parser/CommandParser.java
``` java
package main.parser;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.data.ParseIndexResult;
import main.data.Task;
import main.parser.exceptions.*;

public class CommandParser {
	private final int DATE_INDEX = 0;
	private final int DATE_START = 0;
	private final int DATE_END = 1;
	private final int DATE_MAX_SIZE = 2;
	
	private final String REGEX_PREPOSITION_STARTING = "(?i)\\b(from|after|at|on)\\b ?"; 
	private final String REGEX_PREPOSITION_ALL = "(?i)(\\b(from|after|at|on|by|before|to)\\b ?)";
	public final String REGEX_DAYS = "\\b((?i)((mon)(day)?|(tue)(sday|s)?|"
			+ "(wed)(nesday|s)?|(thu)(rsday|rs|r)?|(fri)(day)?|(sat)(urday)?|(sun)(day)?))\\b";
	private final String REGEX_DATE_NUM = "\\b((0?[1-9]|[12][0-9]|3[01])([/|-])(0?[1-9]|1[012]))\\b";	
	private final String REGEX_DATE_NUM_YEAR = "\\b((0?[1-9]|[12][0-9]|3[01])([/|-])(0?[1-9]|1[012])([/|-])((19|20)?\\d\\d))\\b";
	private final String REGEX_DATE_TEXT = "\\b((0?[1-9]|[12][0-9]|3[01]) ?)";
	private final String REGEX_MONTH_TEXT = "((?i)(jan)(uary)?|"
			+ "(feb)(ruary)?|" + "(mar)(ch)?|" + "(apr)(il)?|" + "(may)|"
			+ "(jun)(e)?|" + "(jul)(y)?|" + "(aug)(ust)?|" + "(sep)(tember)?|"
			+ "(oct)(ober)?|" + "(nov)(ember)?|" + "(dec)(ember)?)\\b";
	private final String REGEX_YEAR = "\\b ?((19|20)?\\d\\d)\\b";
	private final String REGEX_DATE_WORD = "\\b(today|tdy|tonight|tomorrow|tmr|tml|tmrw)\\b";
	private final String REGEX_TIME_TWELVE = "((1[012]|0?[1-9])(([:|.][0-5][0-9])?))";
	private final String REGEX_TIME_WORD = "\\b(morning|afternoon|evening|midnight)\\b";
	private final String REGEX_AM_PM = "(?i)(am|pm)";
	private final String REGEX_PRIORITY = "\\b((priority|p) ?)(1|2|3)\\b";

	private final String STRING_AM = "am";
	private final String STRING_PM = "pm";
	private final String STRING_TWELVE = "12";
	private final int DOUBLE_DIGIT = 10;
	private final int LENGTH_OFFSET = 1;
	private final int INDEX_OFFSET = 1;

	private static final Logger logger = Logger.getLogger(CommandParser.class.getName());  

	/**
	 * This method builds a {@code Task} object.
	 * 
	 * Tasks without date do not have any date/time specified.
	 * If a task has only the date specified, the time is default set to 12am.
	 * Words with prepositions might not be dated.
	 * Words without prepositions is dated if time is explicitly specified.
	 * 
	 * @param inputString
	 * 		   {@code String} input to be processed
	 * @return {@code Task} built
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	public Task parseAdd(String inputString) throws InvalidLabelFormat, InvalidTitle {
		logger.setLevel(Level.OFF);

		assert(inputString != null);
		logger.log(Level.INFO, "Parsing for ADD command.");

		String title = null;
		String label = null;
		Date startDate = null;
		Date endDate = null;
		int priority = 0;
		
		boolean hasDay = false;
		boolean hasDate = false;
		boolean hasYear = false;
		boolean hasTime = false;
		boolean hasTimeWithoutAmPm = false;
		boolean hasTimeRange = false;
		boolean hasPreposition = false;
		boolean hasStartDate = false;
		boolean hasLabel = false;
		boolean hasPriority = false;
		boolean isDatedOnly = false;
		
		int numberOfDate = 0;
		List<Date> dates = new ArrayList<Date>();
		String regex = null;
		
		//check for day
		hasDay = checkForRegexMatch(getDayRegex(), inputString);
		
		//check for date with year in both num (or text format)
		hasDate = checkForRegexMatch(getDateWithYearRegex(), inputString);
		if (hasDate) {
			hasYear = true;
		} else {
			//check for date in number format, or text format
			hasDate = checkForRegexMatch(getDateRegex(), inputString)  || checkForRegexMatch(getDateRegexText(), inputString);			
		}
	
		//check for time with am/pm or check for word indicating time
		hasTime = checkForRegexMatch(getTimeRegex(), inputString) || checkForRegexMatch(REGEX_TIME_WORD, inputString);
		hasTimeRange = checkForRegexMatch(getTimeRangeRegex(), inputString);

		//check for word indicating date
		if (checkForRegexMatch(REGEX_DATE_WORD, inputString)) {
			hasDate = true;
			hasTime = true;
		}
		
		//check for preposition
		hasPreposition = checkForRegexMatch(REGEX_PREPOSITION_ALL, inputString);
		if (hasPreposition) {
			//check for time without am/pm
			hasTimeWithoutAmPm = checkForRegexMatch(getTimeRegexWithoutAmPm(), inputString);
			//check for start preposition only
			hasStartDate = checkForRegexMatch(REGEX_PREPOSITION_STARTING, inputString);
		}
		
		inputString = correctUserInput(inputString);
		title = inputString;

		//check for priority
		hasPriority = checkForRegexMatch(REGEX_PRIORITY, inputString);
		if (hasPriority) {
			String priorityString = getPriorityString(inputString);
			priority = getPriority(priorityString);
			assert(priority > 0 && priority < 4);
			title = removeStringFromTitle(inputString, priorityString);
		}
		
		hasLabel = checkForLabel(inputString);
		if (hasLabel) {
			try {
				label = getLabel(inputString);
			} catch (Exception e) {
				throw new InvalidLabelFormat("Invalid label input detected.");
			}
			
			if (!checkValidLabel(label)) {
				label = null;
				hasLabel = false;
			}
			
			if (hasLabel) {
				String labelString = "#".concat(label);
				title = removeStringFromTitle(title, labelString);
			}
		}
		
		inputString = title;
		inputString = correctDateNumFormat(inputString, hasYear);

		if (hasDate && hasTime) {
			dates = parseDateTime(inputString);
		} else if (hasDate) {
			dates = parseDateOnly(inputString);
			isDatedOnly = true;
		} else if (hasDay && hasTime) {
			dates = parseDateTime(inputString);
		} else if (hasDay) {
			dates = parseDayOnly(inputString);
			isDatedOnly = true;
		} else if (hasTime) {
			dates = parseTimeOnly(inputString);
		} 
		
		if (inputString.contains("next week")) {
			if (!hasTime) {
				isDatedOnly = true;
			}
			
			dates = correctNextWeek(dates);
			regex = "\\bnext week\\b";
			title = removeRegex(regex, title);
		}
		
		if (hasPreposition && hasTimeWithoutAmPm) {
			dates = parseDateTime(inputString);
			dates = fixTimeForWithoutAmPm(dates);
		}
		
		numberOfDate = dates.size();
		if (numberOfDate > 0) {
			dates = assignDates(dates, hasPreposition, hasStartDate);
			startDate = dates.get(DATE_START);
			endDate = dates.get(DATE_END);

			if (hasDate && hasTime) {
				regex = "\\b(the day after )" + REGEX_DATE_WORD;
				title = removeRegex(regex, title);
			}
			
			if (hasTime) {
				//remove time from title
				regex = REGEX_PREPOSITION_ALL + "?" + REGEX_TIME_WORD;
				title = removeRegex(regex, title);			
				
				if (hasTimeRange) {
					//remove range from title
					regex = "(" + REGEX_PREPOSITION_ALL + "?)(" + getTimeRangeRegex()+ ")";
					title = removeRegex(regex, title);
				}
			}
			
			if (hasDate) {
				if (hasYear) {
					//remove date in num form with year from title
					regex = getDateWithYearRegex();
					title = removeRegex(regex, title);
				}
				
				//remove date in text form with year from title
				regex = getDateRegexTextWithYear();
				title = removeRegex(regex, title);
			
				//remove date in text form with corrected year due to shortform
				regex = "\\b ?'(\\d\\d)\\b";
				title = removeRegex(regex, title);
				
				//remove date in text form from title
				regex = getDateRegexText();
				title = removeRegex(regex, title);
			}
			
			title = removeDateFromTitle(title, dates);
		}
	
		Task task = new Task (title, startDate, endDate, label);
		task.setPriority(priority);
		task.setIsDatedOnly(isDatedOnly);
		
		logger.log(Level.INFO, "Task object built.");
		
		if (title.length() == 0) {
			logger.log(Level.WARNING, "Title cannot be parsed by parser.");
			logger.log(Level.WARNING, "InvalidTitle exception thrown.");
			throw new InvalidTitle("Invalid title detected.", task);
		}
		
		return task;
	}
	
	private List<Date> correctNextWeek(List<Date> dates) {
		Calendar cal = Calendar.getInstance();
		if (dates.size() == 0) {
			cal.setTime(new Date());
			int week = cal.get(Calendar.WEEK_OF_YEAR) + 1;
			cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
			cal.set(Calendar.WEEK_OF_YEAR, week);
			cal.setTime(setTimeToZero(cal.getTime()));
			dates.add(cal.getTime());
		} else {
			for (int i = 0; i < dates.size(); i++) {
				
				 cal.setTime(dates.get(i));
				 cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
				 dates.set(i, cal.getTime());
			}
		}
		return dates;
	}
	
	private String correctUserInput(String inputString) {
		boolean hasTimeRange = checkForRegexMatch(getTimeRangeRegex(), inputString);
		inputString = correctDateText(inputString);
		inputString = correctDateTextYear(inputString);
		inputString = correctDotTime(inputString);
		inputString = correctShorthand(inputString);
		if (hasTimeRange) {
			inputString = correctRangeTime(inputString);
		}
		inputString = removeExtraSpaces(inputString);
		return inputString;
	}
	
	private String correctDateTextYear(String inputString) {
		String regex = getDateRegexText() + "\\b ?(\\d\\d)(?:$|\\s)";
		inputString = inputString.replaceAll(regex,"$2 $4 $5 '$29 ") ;
		return inputString;
	}
	
	private String correctShorthand(String inputString) {
		String regex = "\\b(tmr|tml|tmrw)\\b";
		inputString = inputString.replaceAll(regex, "tomorrow");
		
		regex = "\\b(tdy)\\b";
		inputString = inputString.replaceAll(regex, "today");
		return inputString;
	}

	private String getPriorityString(String inputString) {
		String regex = REGEX_PRIORITY;
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(inputString);
		boolean found = matcher.find();
		if (found) {
			return matcher.group();
		}
		return null;
	}
	
	private int getPriority(String inputString) {
		assert(inputString != null);
		String priority = inputString.substring(inputString.length()-1);
		int level = Integer.parseInt(priority);
		return level;
	}
	
	private String removeStringFromTitle(String title, String string) {
		title = title.replace(string, "");
		title = removeExtraSpaces(title);
		return title;
	}
	
	/**
	 * This method checks for indication of label through detection of '#'.
	 * 
	 * @param inputString
	 * 			{@code String} input to be checked
	 * @return {@code boolean} true if found
	 */
	private boolean checkForLabel(String inputString) {
		if (inputString.contains("#")) {
			return true;
		} else {
			return false;
		}
	}

	private String getLabel(String inputString) throws InvalidLabelFormat {
		int index = inputString.indexOf("#");
		index = index + LENGTH_OFFSET;
		String substring = inputString.substring(index);
		String label = substring.trim();
		label = getFirstWord(label);
		return label;
	}

	private String getFirstWord(String inputString) throws InvalidLabelFormat {
		String word = "";
		try {
			word = inputString.split(" ")[0];
		} catch (Exception e ) {
			logger.log(Level.WARNING, "Label cannot be parsed by parser.");
			logger.log(Level.WARNING, "InvalidLabelFormat exception thrown.");
			throw new InvalidLabelFormat("Invalid label input detected.");
		}

		if (word.length() == 0) {
			logger.log(Level.WARNING, "Label cannot be parsed by parser.");
			logger.log(Level.WARNING, "InvalidLabelFormat exception thrown.");
			throw new InvalidLabelFormat("Invalid label input detected.");
		}

		return word;
	}

	private boolean checkValidLabel(String inputString) {
		if (inputString.contains("-")) {
			return false;
		} else {
			return true;
		}
	}
	
	private String removeExtraSpaces(String inputString) {
		return inputString.replaceAll("\\s+", " ").trim();
	}
	
	private boolean checkForRegexMatch(String regex, String inputString) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(inputString);
		return matcher.find();
	}
	
	private String getDayRegex() {
		return REGEX_PREPOSITION_ALL + "?" + REGEX_DAYS;
	}
	
	private String getDateRegex() {
		return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_NUM;
	}
	
	private String getDateWithYearRegex() {
		return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_NUM_YEAR;
	}
	
	private String getDateRegexText() {
		return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_TEXT + REGEX_MONTH_TEXT;
	}
	
	public String getDateRegexTextWithYear() {
		return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_TEXT + REGEX_MONTH_TEXT + REGEX_YEAR;
	}
	
	/**
	 * This method corrects date text in user input without spaces for date parsing.
	 * Eg: 1apr -> 1 apr
	 * @param inputString
	 * 			{@code String} input to be corrected
	 * @return {@code  String} with date text corrected
	 */
	private String correctDateText(String inputString) {
		String regex = REGEX_DATE_TEXT + REGEX_MONTH_TEXT;
		inputString = inputString.replaceAll(regex, "$1 $3");
		inputString = removeExtraSpaces(inputString);
		return inputString;
	}

	private String getTimeRegex() {
		return "\\b" + REGEX_TIME_TWELVE + REGEX_AM_PM;
	}

	/**
	 * This method corrects time separated with a dot for date parsing.
	 * Eg: 5.30pm 
	 * 
	 * @param inputString
	 * 			{@code String} input to be corrected
	 * @return {@code String} with time corrected
	 */
	private String correctDotTime(String inputString) {
		String regex = "\\b((1[012]|0?[1-9])(([:|.])([0-5][0-9])?))(?i)(am|pm)";
		inputString = inputString.replaceAll(regex, "$2:$5$6");
		return inputString;
	}

	private String getTimeRangeRegex() {
		return "\\b" + REGEX_TIME_TWELVE + REGEX_AM_PM + "?" 
				+ "\\s?-\\s?" +
				"\\b" + REGEX_TIME_TWELVE + REGEX_AM_PM
				+ "|" +
				"\\b" + REGEX_TIME_TWELVE + REGEX_AM_PM 
				+ "\\s?-\\s?" +
				"\\b" + REGEX_TIME_TWELVE + REGEX_AM_PM + "?\\b";
	}

	/**
	 * This method corrects ranged time for date parsing.
	 * 
	 * @param inputString
	 * 			{@code String} input to be corrected
	 * @return {@code String} with time range corrected
	 */
	private String correctRangeTime(String inputString) {
		inputString = inputString.replaceAll("()-()","$1 - $2");
		return inputString;
	}

	private String getTimeRegexWithoutAmPm() {
		return REGEX_PREPOSITION_ALL + "\\b " + REGEX_TIME_TWELVE + "\\b$";
	}
	
	/**
	 * This method uses PrettyTimeParser to generate dates from {@code String} inputString.
	 * @param inputString
	 * 			{@code String} input to be parsed
	 * @return {@code List<Date>} of dates generated if possible
	 */
	private List<Date> parseDateTime(String inputString) {
		PrettyTimeParser parser = new PrettyTimeParser(TimeZone.getDefault());
		List<Date> dates = parser.parse(inputString);
		return dates;
	}
	
	/**
	 * This method corrects dd/mm into mm/dd for date parsing.
	 * 
	 * @param inputString
	 * 			{@code String} input to be corrected
	 * @return {@code String} with the date corrected
	 */
	private String correctDateNumFormat(String inputString, boolean hasYear) {
		boolean match = false;
		String swapped = "";

		//Preserve capitalization by not using toLowerCase
		List<String> words = new ArrayList<String>(Arrays.asList(inputString.split(" ")));
		
		for (int i = 0; i< words.size(); i++) {
			if (hasYear) {
				match = Pattern.matches(REGEX_DATE_NUM_YEAR, words.get(i));
			} else {
				match = Pattern.matches(REGEX_DATE_NUM, words.get(i));
			}
			
			if (match) {
				if (words.get(i).contains("/")) {
					List<String> date = new ArrayList<String>(Arrays.asList(words.get(i).split("/")));
					swapped = date.get(1).concat("/").concat(date.get(0));
					if (date.size() == 3) {
						swapped = swapped.concat("/").concat(date.get(2));
					}
				} else if (words.get(i).contains("-")) {
					List<String> date = new ArrayList<String>(Arrays.asList(words.get(i).split("-")));
					swapped = date.get(1).concat("-").concat(date.get(0));
					if (date.size() == 3) {
						swapped = swapped.concat("-").concat(date.get(2));
					}
				}
				words.set(i, swapped);
			}
		}

		return String.join(" ", words);
	}
	
	/**
	 * This method parses the date only.
	 * Since time is not specified, it is set to 12am.
	 * 
	 * @param inputString
	 * 			{@code String} input to be parsed
	 * @return {@code List<Date>} of dates
	 */
	private List<Date> parseDateOnly(String inputString) {
		List<Date> dates = parseDateTime(inputString);
		int size = dates.size();
		for (int i = 0; i < size; i++) {
			dates.add(setTimeToZero(dates.get(i)));
		}
		
		if (size != 0) {
			dates.remove(0);
		}
		
		if (size == DATE_MAX_SIZE) {
			dates.remove(0);	
		}
		
		return dates;
	}
	
	private Date setTimeToZero(Date date) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        return cal.getTime();
    }
	
	private List<Date> parseDayOnly(String inputString) {
		List<Date> dates = parseDateOnly(inputString);
		dates = fixDayRange(dates);
		return dates;
	}
	
	/**
	 * This method ensures that range are sequential.
	 * Corrects date parsed by PrettyTime.
	 * The end will come after the start.
	 * 
	 * @param dates
	 * 			{@code List<Date>>} to be corrected
	 * @return {@code List<Date>} corrected dates
	 */
	private List<Date> fixDayRange(List<Date> dates) {
		if (dates.size() == DATE_MAX_SIZE) {
			Date start = dates.get(DATE_START);
			Date end = dates.get(DATE_END);
			if (start.after(end)) {
				Calendar cal = Calendar.getInstance();
				cal.setTime(end);
				cal.add(Calendar.WEEK_OF_YEAR, 1);
				dates.set(DATE_END, cal.getTime());
			}
		}
		return dates;
	}
	
	private List<Date> parseTimeOnly(String inputString) {
		List<Date> dates = parseDateTime(inputString);
		dates = fixTimeToNearest(dates, false);
		dates = fixTimeForRange(dates);
		return dates;
		
	}
	
	/**
	 * This method sets the time if it has past and if no date is specified.
	 * It will always take the next nearest time.
	 * 
	 * Eg:
	 * If now is 1pm, and if either 12am or 12pm is specified,
	 * it will be 12am or 12pm of the next day.
	 * 
	 * @param dates
	 * 			{@code List<Date>} dates to be parsed
	 * @param hasDate
	 * 			{@code boolean} indicating if date is specified
	 * @return {@code List<Date>} of dates
	 */
	private List<Date> fixTimeToNearest(List<Date> dates, boolean hasDate) {
		Date now = new Date();
		Calendar currentDate = Calendar.getInstance();
		currentDate.setTime(now);
		
		Calendar date = Calendar.getInstance();
		if (!hasDate) {
			for (int i = 0; i < dates.size(); i++) {
				if (dates.get(i).before(now)) {
					//date has past, get the next nearest
					date.setTime(dates.get(i));
					date.add(Calendar.DATE, 1);
					dates.set(i, date.getTime());
				}
				
				if (dates.size() == 2) {
					//update to start
					now = dates.get(i);
				}
			}
		}
		return dates;
	}
	
	/**
	 * This method ensures that range are sequential.
	 * Corrects date parsed by PrettyTime.
	 * The end will come after the start.
	 * 
	 * Eg: If now is 11pm, 10pm - 2am will be today 10pm to the next day 2am.
	 * 
	 * @param dates
	 * 			{@code List<Date>>} to be corrected
	 * @return {@code List<Date>} corrected dates
	 */
	private List<Date> fixTimeForRange(List<Date> dates) {
		if (dates.size() == DATE_MAX_SIZE) {
			Date start = dates.get(DATE_START);
			Date end = dates.get(DATE_END);
			if (end.before(start)) {
				Calendar cal = Calendar.getInstance();
				cal.setTime(end);
				cal.add(Calendar.DAY_OF_MONTH, 1);
				dates.set(DATE_END, cal.getTime());
			}
		}
		return dates;
	}
	
	/**
	 * This method sets the time for time specified without am/pm due to the presence of preposition.
	 * It will take the next possible time since am/pm is not specified.
	 * 
	 * Eg:
	 * If now is 1pm, and 10 is specified,
	 * it will be parsed as 10pm today.
	 * 
	 * If now is 10 pm, and 1 is specified,
	 * it will be parsed as 1am tomorrow.
	 * 
	 * @param dates
	 * 			{@code List<Date>} dates to be parsed
	 * @param hasDate
	 * 			{@code boolean} indicating if date is specified
	 * @return {@code List<Date>} of dates
	 */
	private List<Date> fixTimeForWithoutAmPm(List<Date> dates) {
		Date now = new Date();
		Calendar currentDate = Calendar.getInstance();
		currentDate.setTime(now);
		
		Calendar date = Calendar.getInstance();
		
			for (int i = 0; i < dates.size(); i++) {
				if (dates.get(i).before(now)) {
					//time has past, need to check next nearest
					date.setTime(dates.get(i));
					date.add(Calendar.HOUR_OF_DAY, 12);
					
					//if time is after current, still within the day
					if (date.after(currentDate)) {
						dates.set(i,date.getTime());
					} else {
						//time is before current, time has past
						//plus 12 hours to get to next nearest
						date.add(Calendar.HOUR_OF_DAY, 12);
						dates.set(i,date.getTime());
					}
				}
				
				if (dates.size() == 2) {
					//if is range, check against the fixed start date
					now = dates.get(i);
				}
			}
		return dates;
	}
	
	/**
	 * This method determines the start and end date for a task.
	 * 
	 * @param dates
	 * 			{@code List<Date} dates obtained from parsing
	 * @param hasPreposition
	 * 			{@code boolean} indicate if preposition is detected 
	 * @param hasStartDate
	 * 			{@code boolean} indicate if start date is detected through detection of preposition
	 * @return {@code List<Date>} of determined dates
	 */
	private List<Date> assignDates(List<Date> dates, boolean hasPreposition, boolean hasStartDate) {
		List<Date> assigned = new ArrayList<Date>();
		int numberOfDate = dates.size();
		
		if (numberOfDate == DATE_MAX_SIZE) {
			assigned.add(DATE_START,getDate(dates, DATE_START));
			assigned.add(DATE_END,getDate(dates, DATE_END));
		} else {
			if (hasPreposition) {
				if (hasStartDate) {
					assigned.add(DATE_START,getDate(dates, DATE_INDEX));
					assigned.add(DATE_END, null);
				} else {
					assigned.add(DATE_START, null);
					assigned.add(DATE_END,getDate(dates, DATE_INDEX));
				}
			} else {
				//no preposition
				//one date/time only
				//assume start
				assigned.add(DATE_START,getDate(dates, DATE_INDEX));
				assigned.add(DATE_END,null);
			}
		}
		return assigned;
	}
	
	private Date getDate(List<Date> dates, int index) {
		return dates.get(index);
	}

	/**
	 * This method removes date information from the {@code String} taken in.
	 * 
	 * @param title
	 * 			{@code String} containing date information
	 * @param startDate
	 * 			{@code Date} start date
	 * @param endDate
	 * 			{@code Date} end date
	 * @return {@code String} without date information
	 */
	private String removeDateFromTitle(String title, List<Date> datesList) {   
		LocalDateTime dateTime;
		
		Date startDate = datesList.get(DATE_START);
		Date endDate = datesList.get(DATE_END);

		if (startDate != null) {
			dateTime = startDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
		} else {
			dateTime = endDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
		}

		for (int i = 0; i < DATE_MAX_SIZE; i++) {
			ArrayList<String> dates = getPossibleDates(dateTime);
			ArrayList<String> months = getPossibleMonths(dateTime);
			ArrayList<String> days = getPossibleDays(dateTime);
			ArrayList<String> timings = getPossibleTimes(dateTime);
			
			title = checkAndRemove(title, dates);
			title = checkAndRemove(title, months);
			title = checkAndRemove(title, days);
			title = checkAndRemove(title, timings);

			if (startDate != null && endDate != null) {
				dateTime = endDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
			} else {
				break;
			}
		}
		return title;
	}

	/**
	 * This method generates an {@code ArrayList<String} of possible date formats from {@code LocalDateTime}.
	 * 
	 * @param dateTime
	 * 			{@code LocalDateTime} to generate different date formats
	 * @return {@code ArrayList<String} of possible date formats
	 */
	private ArrayList<String> getPossibleDates(LocalDateTime dateTime) {
		ArrayList<String> dates = new ArrayList<String>();
		String date = Integer.toString(dateTime.getDayOfMonth());
		dates.add(date);
		dates.add(date.concat("st"));
		dates.add(date.concat("nd"));
		dates.add(date.concat("rd"));
		dates.add(date.concat("th"));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("d/M")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("d/MM")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd/M")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd/MM")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("d-M")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("d-MM")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd-M")));
		dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd-MM")));
		return dates;
	}

	/**
	 * This method generates an {@code ArrayList<String} of possible month formats from {@code LocalDateTime}.
	 * 
	 * @param dateTime
	 * 			{@code LocalDateTime} to generate different month formats
	 * @return {@code ArrayList<String} of possible month formats
	 */
	private ArrayList<String> getPossibleMonths(LocalDateTime dateTime) {
		Locale locale = Locale.getDefault();
		ArrayList<String> months = new ArrayList<String>();
		Month month = dateTime.getMonth();
		months.add(month.toString().toLowerCase());
		months.add(month.getDisplayName(TextStyle.SHORT, locale).toLowerCase());
		return months;
	}

	/**
	 * This method generates an {@code ArrayList<String} of possible day formats from {@code LocalDateTime}.
	 * 
	 * @param dateTime
	 * 			{@code LocalDateTime} to generate different day formats
	 * @return {@code ArrayList<String} of possible day formats
	 */
	private ArrayList<String> getPossibleDays(LocalDateTime dateTime) {
		Locale locale = Locale.getDefault();
		DayOfWeek day = dateTime.getDayOfWeek();
		ArrayList<String> days = new ArrayList<String>();
		days.add(day.toString().toLowerCase());
		days.add(day.getDisplayName(TextStyle.SHORT, locale).toLowerCase());
		days = getDaysShorthand(days, day.toString().toLowerCase());
		
		int date = dateTime.getDayOfMonth();
		int month = dateTime.getMonthValue();
		LocalDateTime today = LocalDateTime.now();
		if (month == today.getMonthValue()) {
			if (date == today.getDayOfMonth()) {
				days.add("today");
				days.add("tdy");
				days.add("tonight");
			} else if (date == (today.getDayOfMonth()+1)) {
				days.add("tomorrow");
				days.add("tmr");
				days.add("tml");
				days.add("tmrw");
			}
		}
		return days;
	}
	
	private ArrayList<String> getDaysShorthand(ArrayList<String> days, String day) {
		switch (day) {
			case "tuesday" :
				days.add("tues");
				break;
			case "wednesday" :
				days.add("weds");
				break;
			case "thursday" :
				days.add("thur");
				days.add("thurs");
				break;
			default :
				break;
		}
		return days;
	}
	
	
	/**
	 * This method generates an {@code ArrayList<String} of possible time formats from {@code LocalDateTime}.
	 * 
	 * @param dateTime
	 * 			{@code LocalDateTime} to generate different time formats
	 * @return {@code ArrayList<String} of possible time formats
	 */
	private ArrayList<String> getPossibleTimes(LocalDateTime dateTime) {
		ArrayList<String> timings = new ArrayList<String>();
		int hour = dateTime.getHour();
		int min = dateTime.getMinute();

		assert(hour >= 0);
		assert(min >= 0);

		String colon = ":";
		String dot = ".";
		if (min < DOUBLE_DIGIT) {
			colon = colon.concat("0");
			dot = dot.concat("0");
		}

		colon = colon.concat(Integer.toString(dateTime.getMinute()));
		dot = dot.concat(Integer.toString(dateTime.getMinute()));

		timings.add(Integer.toString(hour));
		timings.add(Integer.toString(hour).concat(colon));
		timings.add(Integer.toString(hour).concat(dot));
		if (hour < 12) {
			if (hour == 0) {
				String temp = STRING_TWELVE;
				timings.add(temp.concat(STRING_AM));
				timings.add(temp.concat(colon).concat(STRING_AM));
				timings.add(temp.concat(dot).concat(STRING_AM));
			} else {
				timings.add(Integer.toString(hour).concat(STRING_AM));
				timings.add(Integer.toString(hour).concat(colon).concat(STRING_AM));
				timings.add(Integer.toString(hour).concat(dot).concat(STRING_AM));
			}
		} else if (hour >= 12) {	
			hour = hour - 12;
			if (hour == 0) {
				String temp = STRING_TWELVE;
				timings.add(temp.concat(STRING_PM));
				timings.add(temp.concat(colon).concat(STRING_PM));
				timings.add(temp.concat(dot).concat(STRING_PM));
			} else {
				timings.add(Integer.toString(hour));
				timings.add(Integer.toString(hour).concat(STRING_PM));
				timings.add(Integer.toString(hour).concat(colon).concat(STRING_PM));
				timings.add(Integer.toString(hour).concat(dot).concat(STRING_PM));
			}
		}
		return timings;
	}

	/**
	 * This method checks for and removes {@code ArrayList<String>} of targeted word from {@code String}.
	 * 
	 * If word to be removed is found, it checks if the word before it is a preposition.
	 * If preposition found, both are removed.
	 * Else, only the matching word is removed.
	 * 
	 * @param title
	 * 			{@code String} to be checked
	 * @param toBeRemoved
	 * 			{@code ArrayList<String>} of words to be removed
	 * @return {@code String} with targeted words removed
	 */
	private String checkAndRemove(String title, ArrayList<String> toBeRemoved) {
		int index = 0;
		boolean isPreposition = false;

		for (int i = 0; i < toBeRemoved.size(); i++) {
			String toBeReplaced = "";
			List<String> words = new ArrayList<String>(Arrays.asList(title.toLowerCase().split(" ")));

			if (words.contains(toBeRemoved.get(i))) {
				toBeReplaced = toBeReplaced.concat(toBeRemoved.get(i));

				index = words.indexOf(toBeRemoved.get(i));
				String word = "";
				if (index != 0) {
					index = index - INDEX_OFFSET;
					word = getWord(title, index);
				}
				
				if (word.equals("this") || word.equals("next")) {
					toBeReplaced = word.concat(" ").concat(toBeReplaced);
					if (index != 0) {
						index = index - INDEX_OFFSET;
						word = getWord(title, index);
					}
				}

				isPreposition = checkForRegexMatch(REGEX_PREPOSITION_ALL, word);
				if (isPreposition) {
					toBeReplaced = word.concat(" ").concat(toBeReplaced);
				}
			}

			toBeReplaced = "(?i)".concat(toBeReplaced); 
			title = title.replaceAll(toBeReplaced, "");
		}
		title = removeExtraSpaces(title);
		return title;
	}
	
	/**
	 * This method gets a word from {@code String} string base on {@code int} index.
	 * 
	 * @param title
	 * 			{@code String} input to obtain word from
	 * @param index
	 * 			{@code int} index of word to be obtained
	 * @return {@code String} word obtained
	 */
	private String getWord(String title, int index) {
		List<String> words = new ArrayList<String>(Arrays.asList(title.toLowerCase().split(" ")));
		String word = words.get(index);
		return word;
	}
	
	// =============================
	// Edit's stuff
	// =============================

	/**
	 * This method parses {@code String} for date.
	 * 
	 * @param inputString
	 * 			{@code String} input to be parsed
	 * @return {@code Date} if date found, {@code null} if date is not found
	 */
	public Date getDateForSearch(String inputString) {
		if (isSpecialCase(inputString)) {
			return null;
		}
		
		inputString = correctShorthand(inputString);
		List<Date> dates = parseDateTime(inputString);
		
		if (dates.size() == 0) {
			return null;
		} else {
			if (inputString.length() == 1) {
				dates = setDate(dates, inputString);
			}
			return dates.get(0);
		}
	}
	
	/**
	 * This method escapes date parsing if it is a special string.
	 * 
	 * @param inputString
	 * 			{@code String} input string
	 * @return {@code boolean} true if special case detected
	 */
	private boolean isSpecialCase(String inputString) {
		if (inputString.equalsIgnoreCase("this week") ||
				inputString.equalsIgnoreCase("next week")) {
			return true;
		} else {
			return false;
		}
	}
	
	private List<Date> setDate(List<Date> dates, String inputString) {
		int date = Integer.parseInt(inputString);
		Calendar cal = Calendar.getInstance();
        cal.setTime(dates.get(DATE_INDEX));
        cal.set(Calendar.DATE, date);
        dates.add(DATE_INDEX, cal.getTime());
		return dates;
	}
	
	/**
	 * This method detects if index is present in edit command.
	 * 
	 * @param inputString
	 * 			{@code String} input for index to be obtained
	 * @return {@code int} index if found, {@code int} -1 if index is not found
	 */
	public int getIndexForEdit(String inputString) {
		ArrayList<String> index = new ArrayList<String>();
		inputString = removeDateTime(inputString);

		Collections.addAll(index, inputString.split(" "));
		
		if (index.size() == 1) {
			return -1;
		} else {
			try {
				return (Integer.parseInt(index.get(1)));
			} catch (Exception e) {
				return -1;
			}
		}
	}
	
	/**
	 * This method removes date and time information from {@code String}.
	 * 
	 * @param inputString
	 * 			{@code String} input for information to be removed
	 * @return {@code String} without date and time information
	 */
	private String removeDateTime(String inputString) {
		boolean hasTime = false;
		boolean hasTimeRange = false;
		boolean hasDate = false;
		String regex = "";

		hasTime = checkForRegexMatch(getTimeRegex(), inputString);
		
		if (hasTime) {
			hasTimeRange = checkForRegexMatch(getTimeRangeRegex(), inputString);

			if (hasTimeRange) {
				regex = "(" + REGEX_PREPOSITION_ALL + "?)(" + getTimeRangeRegex()+ ")";
				inputString = removeRegex(regex, inputString);
			}

			regex = getTimeRegex();
			inputString = removeRegex(regex, inputString);
		}

		hasDate = checkForRegexMatch(getDateRegex(), inputString);
		if (hasDate) {
			regex = getDateRegex();
			inputString = removeRegex(regex, inputString);
			hasDate = false;
		}

		hasDate = checkForRegexMatch(getDateRegexText(), inputString);
		if (hasDate) {
			regex = getDateRegexText();
			inputString = removeRegex(regex, inputString);
		}

		return inputString;
	}

	/**
	 * This method takes in {@code String} regex and removes if from {@code String} input.
	 * 
	 * @param regex
	 * 			{@code String} expressions to be removed
	 * @param inputString
	 * 			{@code String} input for expression to be removed
	 * @return {@code String} without expression 
	 */
	private String removeRegex(String regex, String inputString) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(inputString);

		while (matcher.find()) {
			String match = matcher.group();
			inputString = inputString.replaceAll(match,"");
		}
		
		inputString = removeExtraSpaces(inputString); 		
		return inputString;
	}

	/**
	 * This method allows for editing of existing tasks.
	 * 
	 * @param oldTask
	 * 			{@code Task} to be edited
	 * @param inputString
	 * 			{@code String} of new information
	 * @return {@code Task} edited task
	 * @throws InvalidLabelFormat
	 */
	public Task parseEdit(Task oldTask, String inputString) throws InvalidLabelFormat {		
		String newTitle = oldTask.getTitle();
		String newLabel = oldTask.getLabel();
		Date newStart = oldTask.getStartDate();
		Date newEnd = oldTask.getEndDate();
		Date createdDate = oldTask.getCreatedDate();
		int priority = oldTask.getPriority();
		boolean isDatedOnly = oldTask.getIsDatedOnly();
		
		Task editedTask;
		try {
			editedTask = parseAdd(inputString);
		} catch (InvalidTitle exception) {
			//exception doesn't matter if edit is using parseAdd
			editedTask = exception.getTask();
		}
		
		if (editedTask.getTitle().length() != 0) {
			newTitle = editedTask.getTitle();
		}
	
		if (editedTask.getLabel() != null) {
			newLabel = editedTask.getLabel();
		}
		
		boolean hasPriority = checkForRegexMatch(REGEX_PRIORITY, inputString);
		if (hasPriority) {
			priority = editedTask.getPriority();
		}

		boolean hasTime = false;
		boolean hasDate = false;
		boolean hasPreposition = false;
		boolean hasTimeWithoutAmPm = false;
		List<Date> dates = new ArrayList<Date>();
		
		hasDate = checkForRegexMatch(getDateRegex(), inputString)  || checkForRegexMatch(getDateRegexText(), inputString);
		hasTime = checkForRegexMatch(getTimeRegex(), inputString) || checkForRegexMatch(REGEX_TIME_WORD, inputString);
		
		if (!hasTime) {
			hasPreposition = checkForRegexMatch(REGEX_PREPOSITION_ALL, inputString);
			if (hasPreposition) {
				hasTimeWithoutAmPm = checkForRegexMatch(getTimeRegexWithoutAmPm(), inputString);
				if (hasTimeWithoutAmPm) {
					hasTime = true;
				}
			} 
		}
		
		//check for word indicating date
		if (checkForRegexMatch(REGEX_DATE_WORD, inputString)) {
			hasDate = true;
			hasTime = true;
		}

		if (editedTask.hasDate()) {		
			if (hasDate && !hasTime) {
				
				//new
				//if date only, dont reuse time
				dates.add(editedTask.getStartDate());
				dates.add(editedTask.getEndDate());
				isDatedOnly = true;
			} else if (!hasDate && hasTime) {
				//only time, reuse date
				dates = reuseDate(editedTask, oldTask);
				isDatedOnly = false;
			} else {
				//have both
				//update by overwriting
				dates.add(editedTask.getStartDate());
				dates.add(editedTask.getEndDate());
				isDatedOnly = false;
			}
			
			newStart = dates.get(DATE_START);
			newEnd = dates.get(DATE_END);
		}
		
		Task newTask = new Task(newTitle, newStart, newEnd, newLabel);
		newTask.setCreatedDate(createdDate);
		newTask.setPriority(priority);
		newTask.setIsDatedOnly(isDatedOnly);
		return newTask;
	}
	
	/**
	 * This method duplicates the date information in {@code Task} oldTask to {@code Task} editedTask.
	 * 
	 * @param editedTask
	 * 			{@code Task} edited task that needs the old date information
	 * @param oldTask
	 * 			{@code Task} with the old date information
	 * @return {@code List<Date>} of updated dates
	 */
	/**
	 * @param editedTask
	 * @param oldTask
	 * @return
	 */
	private List<Date> reuseDate(Task editedTask, Task oldTask) {
		List<Date> dates = new ArrayList<Date>();
		Calendar reuse = Calendar.getInstance();
		Calendar latest = Calendar.getInstance();
		
		Date startDate = editedTask.getStartDate();
		Date endDate = editedTask.getEndDate();
		Date oldStart = oldTask.getStartDate();
		Date oldEnd = oldTask.getEndDate();
		
		if (startDate != null) {
			if (oldStart != null) {  
				reuse.setTime(oldStart);
			} else if (oldEnd != null) {
				reuse.setTime(oldEnd);
			}

			latest = setDayMonthYear(reuse, latest, startDate);
			oldStart = latest.getTime();
		}
		
		if (endDate != null) {
			if (oldEnd != null) {  
				reuse.setTime(oldEnd);
			} else if (oldStart != null) {
				reuse.setTime(oldStart);
			}
			
			latest = setDayMonthYear(reuse, latest, endDate);
			oldEnd = latest.getTime();
		}
		
		if (!oldTask.hasDate()) {
			//floating task
			oldStart = startDate;
			oldEnd = endDate;
		}
		
	
		if (startDate == null) {
			oldStart = null;
		}

		if (endDate == null) {
			oldEnd = null;
		}
	
		dates.add(oldStart);
		dates.add(oldEnd);
		return dates;		
	}
	
	/**
	 * This method gets the day and month from {@code Calendar} reuse and sets it in {@code Calendar} latest.
	 * 
	 * @param reuse
	 * 			{@code Calendar} for day and month to be obtained
	 * @param latest
	 * 			{@code Calendar} for day and month to be set
	 * @param date
	 * 			{@code Date} date to be set for {@code Calendar} latest
	 * @return {@code Calendar} with updated day and month
	 */
	private Calendar setDayMonthYear(Calendar reuse, Calendar latest, Date date) {
		int day = reuse.get(Calendar.DAY_OF_MONTH);
		int month = reuse.get(Calendar.MONTH);
		int year = reuse.get(Calendar.YEAR);
		
		latest.setTime(date);
		latest.set(Calendar.DAY_OF_MONTH, day);
		latest.set(Calendar.MONTH, month);
		latest.set(Calendar.YEAR, year);

		return latest;
	}	

	// =============================
	// Parsing Indexes
	// =============================

	/**
	 * This method detects the types of indexes and processes them.
	 * 
	 * @param inputString
	 * 			{@code String} input to be processed
	 * @return {@code ArrayList<Integer>} of index(es)
	 * @throws InvalidTaskIndexFormat if format is invalid
	 */
	public ParseIndexResult parseIndexes(String inputString, int maxSize) throws InvalidTaskIndexFormat {
		assert (maxSize > 0);
		
		try {
			logger.log(Level.INFO, "Parsing indexes.");
			
			String indexString = getStringWithoutCommand(inputString);
			indexString = removeWhiteSpace(indexString);
			ArrayList<Integer> indexes = new ArrayList<Integer>();
			indexes = getIndex(indexString);
			ParseIndexResult indexResult = validateIndexes(indexes, maxSize);
			logger.log(Level.INFO, "Indexes retrieved.");
			return indexResult;
		} catch (Exception e) {
			logger.log(Level.WARNING, "NumberFormatException: Indexes cannot be parsed by parser.");
			logger.log(Level.WARNING, "InvalidTaskIndexFormat exception thrown.");
			throw new InvalidTaskIndexFormat("Invalid indexes input detected.");	
		}
	}
	
	private String removeWhiteSpace(String string) {
		string = string.replaceAll("\\s","");
		assert(!string.isEmpty());
		return string;
	}

	private String getStringWithoutCommand(String commandString) throws InvalidLabelFormat{
		int index = 0;
		String command = getFirstWord(commandString); //will not fail because without command UI won't call
		index = command.length() + LENGTH_OFFSET;
		String indexString = commandString.substring(index, commandString.length());
		assert(!indexString.isEmpty());
		return indexString;
	}

	/**
	 * This method obtains all numbers based on {@code String} taken in.
	 * 
	 * @param index
	 * 			{@code String} to be processed
	 * @return {@code ArrayList<Integer>} of index(es) 
	 * @throws InvalidTaskIndexFormat 
	 */
	private ArrayList<Integer> getIndex(String index) throws InvalidTaskIndexFormat {
		ArrayList<String> indexes = new ArrayList<String>();
		ArrayList<String> tempRangedIndexes = new ArrayList<String>();
		ArrayList<Integer> multipleIndexes = new ArrayList<Integer>();
		ArrayList<Integer> rangedIndexes = new ArrayList<Integer>();

		Collections.addAll(indexes, index.split(","));

		for (int i = 0; i < indexes.size(); i++) {
			if (indexes.get(i).contains("-")) {
				Collections.addAll(tempRangedIndexes, indexes.get(i).split("-"));

				//remove all empty after splitting
				//else will cause parseInt to fail
				tempRangedIndexes = removeEmpty(tempRangedIndexes);
				rangedIndexes = getRangedIndexes(tempRangedIndexes);

				if (rangedIndexes.size() == 1) {
					logger.log(Level.WARNING, "NumberFormatException: Indexes cannot be parsed by parser.");
					logger.log(Level.WARNING, "InvalidTaskIndexFormat exception thrown.");
					throw new InvalidTaskIndexFormat("Invalid indexes input detected.");
				}

				multipleIndexes.addAll(getMultipleIndexes(rangedIndexes));

				tempRangedIndexes.clear();
				rangedIndexes.clear();
			} else {
				int indexToAdd = Integer.parseInt(indexes.get(i));
				if (!multipleIndexes.contains(indexToAdd)) {
					multipleIndexes.add(indexToAdd);
				}
			}
		}

		Collections.sort(multipleIndexes);
		return multipleIndexes;
	}

	private ArrayList<String> removeEmpty(ArrayList<String> arrayStrings) {
		ArrayList<String> empty = new ArrayList<String>();
		empty.add("");
		arrayStrings.removeAll(empty);
		return arrayStrings;
	}

	/**
	 * This method gets the range of indexes.
	 * 
	 * @param arrayStrings
	 * 			{@code ArrayList<String>} to be processed
	 * @return {@code ArrayList<Integer>} of index(es) range
	 */
	private ArrayList<Integer> getRangedIndexes(ArrayList<String> arrayStrings) {
		ArrayList<Integer> ranged = new ArrayList<Integer>();

		for (int i = 0; i < arrayStrings.size(); i++) {
			ranged.add(Integer.parseInt(arrayStrings.get(i)));
		}

		return ranged;    	
	}

	/**
	 * This method gets multiple indexes.
	 * 
	 * @param arrayIntegers
	 * 			{@code ArrayList<Integer>} to be processed
	 * @return {@code ArrayList<Integer>} of indexes
	 */
	private ArrayList<Integer> getMultipleIndexes(ArrayList<Integer> arrayIntegers) {
		ArrayList<Integer> multiple = new ArrayList<Integer>();
		int start, end;
		int possibleRange = arrayIntegers.size() - 1;

		for (int i = 0; i < possibleRange; i++) {
			//Check and fix range for descending cases
			if (arrayIntegers.get(i) < arrayIntegers.get(i+1)) {
				start = arrayIntegers.get(i);
				end = arrayIntegers.get(i+1);
			} else {
				start = arrayIntegers.get(i+1);
				end = arrayIntegers.get(i);
			}
			
			//prevent duplicates from being added twice
			for (int j = start; j <= end; j++) {
				if (!multiple.contains(j)) {
					multiple.add(j);
				}
			}
		}

		return multiple;
	}
	
	private ParseIndexResult validateIndexes(ArrayList<Integer> indexes, int maxSize) {
		ArrayList<Integer> validIndexes = new ArrayList<Integer>();
		ArrayList<Integer> invalidIndexes = new ArrayList<Integer>();
		
		for (int i = 0; i < indexes.size(); i++ ) {
			int index = indexes.get(i);
			if (index > maxSize) {
				invalidIndexes.add(index);
			} else {
				validIndexes.add(index);
			}
		}
		
		ParseIndexResult indexesResult = new ParseIndexResult();
		if (invalidIndexes.size() > 0) {
			indexesResult.setHasInvalid(true);
			indexesResult.setInvalidIndexes(invalidIndexes);
		}
		
		if (validIndexes.size() > 0) {
			indexesResult.setHasValid(true);
			indexesResult.setValidIndexes(validIndexes);
		}
		
		return indexesResult;
	}	
}
```
###### /src/main/parser/exceptions/InvalidLabelFormat.java
``` java

package main.parser.exceptions;

/**
 * This exception is thrown when there is nothing after a #.
 * Nothing can be extracted by the method getFirstWord() in CommandParser.
 */
@SuppressWarnings("serial")
public class InvalidLabelFormat extends Exception {
	public InvalidLabelFormat(String message) {
		super (message);	  		
	}
}
```
###### /src/main/parser/exceptions/InvalidTaskIndexFormat.java
``` java

package main.parser.exceptions;

/**
 * This exception is thrown when a task's index cannot be parsed.
 * This means that it is in a wrong format.
 */
@SuppressWarnings("serial")
public class InvalidTaskIndexFormat extends Exception {
	public InvalidTaskIndexFormat(String message) {
		super (message);
	}
}
```
###### /src/main/parser/exceptions/InvalidTitle.java
``` java

package main.parser.exceptions;
import main.data.Task;

/**
 * This exception is thrown when there is an invalid title in the user input.
 * An invalid title would be a input containing only date information.
 */
@SuppressWarnings("serial")
public class InvalidTitle extends Exception {
	Task task;
	
	public InvalidTitle(String message, Task task) {
		super (message);
		this.task = task;
	}
	
	public Task getTask() {
		return task;
	}
}
```
###### /src/test/TestCommandParser.java
``` java
package test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Ignore;
import org.junit.Test;

import main.data.ParseIndexResult;
import main.data.Task;
import main.parser.CommandParser;
import main.parser.exceptions.*;

public class TestCommandParser {
	/**
	 * Test detection of time in user input
	 * Method checkForTime has been updated to private.
	 * This is for reference only.
	 */
	/*
	public void testCheckTime() {
		CommandParser parser = new CommandParser();
		
		assertEquals(true, parser.checkForTime("1am"));
		assertEquals(true, parser.checkForTime("2PM"));
		assertEquals(true, parser.checkForTime("12:50pm"));
		
		assertEquals(false, parser.checkForTime("13am"));
		assertEquals(false, parser.checkForTime("112pm"));
		assertEquals(false, parser.checkForTime("12:60pm"));
		assertEquals(false, parser.checkForTime("12:592pm"));
	}
	*/
	
	/**
	 * Test detection of ranged time in user input.
	 * Method checkForRangeTime has been updated to private.
	 * This is for reference only.
	 * See testTaskWithTimeRange() for valid testing.
	 */
	/*
	public void testCheckRange() {
		CommandParser parser = new CommandParser();
		
		assertEquals(true, parser.checkForRangeTime("1am-4"));
		assertEquals(true, parser.checkForRangeTime("1-4am"));
		assertEquals(true, parser.checkForRangeTime("1am-4am"));
		
		assertEquals(true, parser.checkForRangeTime("10am-11"));
		assertEquals(true, parser.checkForRangeTime("10-11am"));
		assertEquals(true, parser.checkForRangeTime("10am-11am"));
		
		assertEquals(true, parser.checkForRangeTime("1:30am-4:30"));
		assertEquals(true, parser.checkForRangeTime("1:30-4:30am"));
		assertEquals(true, parser.checkForRangeTime("1:30am-4:30am"));
		
		assertEquals(true, parser.checkForRangeTime("10:30am-11:30"));
		assertEquals(true, parser.checkForRangeTime("10:30-11:30am"));
		assertEquals(true, parser.checkForRangeTime("10:30am-11:30am"));
	
		assertEquals(false, parser.checkForRangeTime("1-4"));
		
		assertEquals(false, parser.checkForRangeTime("1am-41"));
		assertEquals(false, parser.checkForRangeTime("1-41am"));
		assertEquals(false, parser.checkForRangeTime("1am-41am"));
		
		assertEquals(false, parser.checkForRangeTime("41am-1"));
		assertEquals(false, parser.checkForRangeTime("41-1am"));
		assertEquals(false, parser.checkForRangeTime("41am-1am"));
		
		assertEquals(false, parser.checkForRangeTime("1:60m-4:60"));
		assertEquals(false, parser.checkForRangeTime("1:60-4:60am"));
		assertEquals(false, parser.checkForRangeTime("1:60am-4:60am"));
		
		assertEquals(false, parser.checkForRangeTime("10:60am-11:60"));
		assertEquals(false, parser.checkForRangeTime("10:60-11:60am"));
		assertEquals(false, parser.checkForRangeTime("10:60am-11:60am"));		
	}
	*/
	
	/**
	 * Test detection of date in number format in user input.
	 * Method checkForDate has been updated to private.
	 * This is for reference only.
	 */
	/*
	public void testCheckDate() {
		CommandParser parser = new CommandParser();
		
		assertEquals(true, parser.checkForDate("1/5"));
		assertEquals(true, parser.checkForDate("1/12"));
		assertEquals(true, parser.checkForDate("30-5"));
		assertEquals(true, parser.checkForDate("31-5"));
		
		assertEquals(true, parser.checkForDate("from 1/5"));
		assertEquals(true, parser.checkForDate("after 1/12"));
		assertEquals(true, parser.checkForDate("at 30-5"));
		assertEquals(true, parser.checkForDate("on 31-5"));
		
		assertEquals(false, parser.checkForDate("1/13"));
		assertEquals(false, parser.checkForDate("33/5"));
		assertEquals(false, parser.checkForDate("33/50"));
	}
	 */
	
	/**
	 * Test detection of date in text format in user input.
	 * Method checkForDateText has been updated to private.
	 * This is for reference only.
	 */
	/*
	public void testCheckDateText() {
		CommandParser parser = new CommandParser();

		assertEquals(true, parser.checkForDateText("1 march"));
		assertEquals(true, parser.checkForDateText("31 april"));
		assertEquals(true, parser.checkForDateText("20 may"));
		
		assertEquals(true, parser.checkForDateText("1 mar"));
		assertEquals(true, parser.checkForDateText("31 apr"));
		assertEquals(true, parser.checkForDateText("20 jun"));
		
		assertEquals(true, parser.checkForDateText("from 1 march"));
		assertEquals(true, parser.checkForDateText("by 31 april"));
		assertEquals(true, parser.checkForDateText("on 20 may"));
		
		assertEquals(true, parser.checkForDateText("from 1 mar"));
		assertEquals(true, parser.checkForDateText("by 31 apr"));
		assertEquals(true, parser.checkForDateText("on 20 jun"));
		
		assertEquals(false, parser.checkForDateText("32 march"));
		assertEquals(false, parser.checkForDateText("55 june"));
		
		assertEquals(false, parser.checkForDateText("1 januaryy"));
		assertEquals(false, parser.checkForDateText("1 janu"));
		assertEquals(false, parser.checkForDateText("1 jjan"));
	}
	*/
	
	/**
	 * Test detection of days in text format in user input.
	 * Method checkForDay has been updated to private.
	 * This is for reference only.
	 */
	/*
	public void testCheckDayText() {
		CommandParser parser = new CommandParser();

		assertEquals(true, parser.checkForDay("monday"));
		assertEquals(true, parser.checkForDay("thur"));
		assertEquals(true, parser.checkForDay("thurs"));
		
		assertEquals(true, parser.checkForDay("from monday"));
		assertEquals(true, parser.checkForDay("on thur"));
		assertEquals(true, parser.checkForDay("at thurs"));
		
		
		assertEquals(false, parser.checkForDay("mondayy"));
		assertEquals(false, parser.checkForDay("mmon"));
		assertEquals(false, parser.checkForDay("monn"));
	}
	*/
	
	// =============================
	// Add's stuff
	// =============================
	
	/**
	 * Test for the detection of floating task.
	 * Even with prepositions, it should not be dated.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testDetectFloating() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();

		Task task = parser.parseAdd("Do assignment 1");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Undo task 3");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Fetch my brothers from school");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Send 100 emails from my computer");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Drive by the supermarket");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Attack enemy base on signal");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Send 100 email before I sleep");
		assertEquals(false, task.hasDate());

		task = parser.parseAdd("Watch \"day after tomorrow\" movie");
		assertEquals(false, task.hasDate());
	}

	/**
	 * Test to ensure floating task are added correctly.
	 * It should not be dated.
	 * The title should be the whole user input.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testAddFloating() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();

		Task task = parser.parseAdd("Cook dinner");
		assertEquals(false, task.hasDate());
		assertEquals("Cook dinner", task.getTitle());

		task = parser.parseAdd("Attack enemy base on signal");
		assertEquals(false, task.hasDate());
		assertEquals("Attack enemy base on signal", task.getTitle());
	}
	
	/**
	 * Test for valid label extraction.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testLabel() throws InvalidLabelFormat, InvalidTitle{
		CommandParser parser = new CommandParser();

		Task task = parser.parseAdd("Cook dinner #home");
		assertEquals("Cook dinner", task.getTitle());
		assertEquals("home", task.getLabel());

		task = parser.parseAdd("#home Cook dinner");
		assertEquals("Cook dinner", task.getTitle());
		assertEquals("home", task.getLabel());

		boolean thrown = false;
		try {
			task = parser.parseAdd("Cook dinner #");
		} catch (InvalidLabelFormat e) {
			thrown = true;
		}
		assertEquals(true, thrown);

		thrown = false;
		try {
			task = parser.parseAdd("  #  ");
		} catch (InvalidLabelFormat e) {
			thrown = true;
		}
		assertEquals(true, thrown);
	}
	
	/**
	 * Test priority toggling.
	 * There are only four levels of priority.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testTogglePriority() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task = parser.parseAdd("Cook dinner #home");
		assertEquals(0, task.getPriority());
		assertEquals(1, task.togglePriority(true));
		assertEquals(2, task.togglePriority(true));
		assertEquals(3, task.togglePriority(true));
		assertEquals(0, task.togglePriority(true));
	}

	/**
	 * Test completed status toggling.
	 * A status can either be done or undone.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testToggleDone() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task = parser.parseAdd("Do assignment");
		assertEquals(false, task.isDone());

		task.setIsCompleted();
		assertEquals(true, task.isDone());

		task.setNotCompleted();
		assertEquals(false, task.isDone());

		task.toggleDone();
		assertEquals(true, task.isDone());

		task.toggleDone();
		assertEquals(false, task.isDone());
	}

	/**
	 * Test for invalid title detection.
	 * This is mainly for dated task.
	 * Because if not dated, title is whole user input.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle
	 */
	@Test
	public void testInvalidTitle() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task;
		boolean thrown;
		
		thrown = false;
		try {
			task = parser.parseAdd("29 mar");
		} catch (InvalidTitle e) {
			thrown = true;
		}
		assertEquals(true, thrown);  
		
		thrown = false;
		try {
			task = parser.parseAdd("3pm");
		} catch (InvalidTitle e) {
			thrown = true;
		}
		assertEquals(true, thrown);  
		
		thrown = false;
		try {
			task = parser.parseAdd("29 mar 3pm");
		} catch (InvalidTitle e) {
			thrown = true;
		}
		assertEquals(true, thrown);  
		
		thrown = false;
		try {
			task = parser.parseAdd("29 mar 3pm-5pm");
		} catch (InvalidTitle e) {
			thrown = true;
		}
		assertEquals(true, thrown);
		
		thrown = false;
		try {
			task = parser.parseAdd("3");
		} catch (InvalidTitle e) {
			thrown = true;
		}
		assertEquals(false, thrown);  
		
		thrown = false;
		try {
			task = parser.parseAdd("29 march 3");
		} catch (InvalidTitle e) {
			thrown = true;
		}
		assertEquals(false, thrown);
	}
	
	/**
	 * Test for adding a task without preposition.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testNoPreposition() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task;
		
		task = parser.parseAdd("Buy apple 1 may 3pm");
		assertEquals("Buy apple on 1 May at 3pm", task.toString());
		
		task = parser.parseAdd("Buy apple 1 may");
		assertEquals("Buy apple on 1 May", task.toString());

		task = parser.parseAdd("Buy apple 11pm");
		assertEquals("Buy apple today at 11pm", task.toString());
		
		task = parser.parseAdd("Buy apple 11pm");
		assertEquals("Buy apple today at 11pm", task.toString());
		
		task = parser.parseAdd("Buy apple 9-10pm");
		assertEquals("Buy apple today at 9pm - 10pm", task.toString());
		
		task = parser.parseAdd("Buy apple 9pm-10pm");
		assertEquals("Buy apple today at 9pm - 10pm", task.toString());
	
		//if ending not specified, am
		task = parser.parseAdd("Buy apple 10pm-3");
		assertEquals("Buy apple from today 10pm - this Fri 3am", task.toString());	
	}
	
	/**
	 * Test for time detection without preposition if time is explicitly specified.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testHasTime() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task;

		task = parser.parseAdd("Dinner 8pm");
		assertEquals("Dinner today at 8pm", task.toString());

		task = parser.parseAdd("Dinner 8PM today");
		assertEquals("Dinner today at 8pm", task.toString());

		task = parser.parseAdd("Homework 8.15pm");
		assertEquals("Homework today at 8:15pm", task.toString());
		
		task = parser.parseAdd("Do tutorial by morning");
		assertEquals("Do tutorial by this Fri 8am", task.toString());
		
		task = parser.parseAdd("Do tutorial by afternoon");
		assertEquals("Do tutorial by this Fri 12pm", task.toString());
		
		task = parser.parseAdd("Do tutorial by evening");
		assertEquals("Do tutorial by today 7pm", task.toString());
		
		task = parser.parseAdd("Do tutorial midnight");
		assertEquals("Do tutorial on this Fri at 12am", task.toString());
		
		task = parser.parseAdd("Do tutorial afternoon 5pm");
		assertEquals("Do tutorial on this Fri at 5pm", task.toString());
	}
	
	/**
	 * Date should be relative to current time when being parsed.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testSmartDetectionOfTime() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task;

		task = parser.parseAdd("Do homework by 2");
		assertEquals("Do homework by this Fri 2am", task.toString());
		
		task = parser.parseAdd("Do homework by 11");
		assertEquals("Do homework by today 11pm", task.toString());

		task = parser.parseAdd("Do homework by 11pm");
		assertEquals("Do homework by today 11pm", task.toString());

		task = parser.parseAdd("Do homework by 11pm");
		assertEquals("Do homework by today 11pm", task.toString());  

		task = parser.parseAdd("Do homework by 10 mar 2pm");
		assertEquals("Do homework by 10 Mar 2pm", task.toString());
	}
	
	/**
	 * Test for start time detection when parsing.
	 * Feedback shown is relative to the current period.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testDetectStartTime() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task = parser.parseAdd("Attempt quiz from 5pm 20 apr");
		assertEquals("Attempt quiz", task.getTitle());
		assertEquals("Attempt quiz on 20 Apr at 5pm", task.toString());

		task = parser.parseAdd("Watch webcast after 3am on 20 APR");
		assertEquals("Watch webcast", task.getTitle());  	
		assertEquals("Watch webcast on 20 Apr at 3am", task.toString());

		task = parser.parseAdd("Watch movie at 11pm");
		assertEquals("Watch movie", task.getTitle());
		assertEquals("Watch movie today at 11pm", task.toString());

		task = parser.parseAdd("Watch movie on 20 Apr 7pm");
		assertEquals("Watch movie", task.getTitle());
		assertEquals("Watch movie on 20 Apr at 7pm", task.toString());
	}	
	
	/**
	 * Test for correct parsing of ranged time in user input.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testTaskWithTimeRange() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task = parser.parseAdd("Do homework on 20apr 2-4pm");
		assertEquals("Do homework 20 Apr from 2pm - 4pm", task.toString());
		
		task = parser.parseAdd("Do homework from 2pm-4 on 20apr");
		assertEquals("Do homework 20 Apr from 2pm - 4am", task.toString());

		task = parser.parseAdd("Do homework on 20apr 2pm-4pm");
		assertEquals("Do homework 20 Apr from 2pm - 4pm", task.toString());

		task = parser.parseAdd("Do homework on 21st apr 2pm-4pm");
		assertEquals("Do homework 21 Apr from 2pm - 4pm", task.toString());
		
		task = parser.parseAdd("Do homework on 20 apr 10-11pm");
		assertEquals("Do homework 20 Apr from 10pm - 11pm", task.toString());

		task = parser.parseAdd("Do homework from 10pm-11 on 20 apr");
		assertEquals("Do homework 20 Apr from 10pm - 11am", task.toString());

		task = parser.parseAdd("Do homework on 20 apr 10pm-11pm");
		assertEquals("Do homework 20 Apr from 10pm - 11pm", task.toString());

		task = parser.parseAdd("Do homework on 21st apr 10pm-11pm");
		assertEquals("Do homework 21 Apr from 10pm - 11pm", task.toString());
	}
	
	/**
	 * Test feedback shown when parsing tasks 
	 * Feedback shown is relative to the current period.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testTaskToString() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();

		Task task = parser.parseAdd("Cook dinner");
		assertEquals("Cook dinner", task.toString());

		task = parser.parseAdd("Cook dinner #home");
		assertEquals("Cook dinner #home", task.toString());
		
		task = parser.parseAdd("Cook dinner on 14/3 at 7pm #home");
		assertEquals("Cook dinner on 14 Mar at 7pm #home",task.toString());

		task = parser.parseAdd("Cook dinner on 15/3 7.15pm");
		assertEquals("Cook dinner on 15 Mar at 7:15pm",task.toString());

		task = parser.parseAdd("Cook dinner on 30/4 7:15pm");
		assertEquals("Cook dinner on 30 Apr at 7:15pm", task.toString());

		task = parser.parseAdd("Attend meeting on 26-4 7pm");
		assertEquals("Attend meeting on 26 Apr at 7pm", task.toString());

		task = parser.parseAdd("Attend meeting from 4 to 6pm on 25 Apr");
		assertEquals("Attend meeting 25 Apr from 4pm - 6pm", task.toString());

		task = parser.parseAdd("Attend meeting 4 to 6pm on 25 Apr");
		assertEquals("Attend meeting 25 Apr from 4pm - 6pm", task.toString());

		task = parser.parseAdd("Attend meeting on 1 Mar 9am");
		assertEquals("Attend meeting on 1 Mar at 9am", task.toString());

		task = parser.parseAdd("Go camp from 1-3 8am to 3-3 9pm");
		assertEquals("Go camp from 1 Mar 8am - 3 Mar 9pm", task.toString());
	}
	
	/**
	 * Test parsing of days.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle
	 */
	@Test
	public void testDays() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		//now is tues
		Task task = parser.parseAdd("Attend meeting on thurs");
		assertEquals("Attend meeting on next Thu", task.toString());
		
		//now is tues
		task = parser.parseAdd("Attend meeting from mon to weds");
		assertEquals("Attend meeting from next Mon - next Wed", task.toString());
		
		task = parser.parseAdd("Do homework from 1/2 to 2/2");
		assertEquals("Do homework from 1 Feb - 2 Feb", task.toString());
	}

	/**
	 * Test adding of dated task.
	 * Asserts title and time has been parsed correctly.
	 * 
	 * @throws ParseException for dateFormat.parse()
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testAdd() throws ParseException, InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task = parser.parseAdd("Cook dinner on 24 Mar 7pm #home");
		SimpleDateFormat dateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss Z yyyy");
		String startDate = "Thu Mar 24 19:00:00 SGT 2016";
		Date expectedStart = dateFormat.parse(startDate);

		assertEquals(true, task.hasDate());
		assertEquals(expectedStart, task.getStartDate());
		assertEquals("Cook dinner", task.getTitle());
	}

	/**
	 * Test for extraction of date information in title.
	 * 
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testDatedTaskTitle() throws InvalidLabelFormat, InvalidTitle{
		CommandParser parser = new CommandParser();
		Task task = parser.parseAdd("Attend meeting from Monday to Wednesday");
		assertEquals("Attend meeting", task.getTitle());

		task = parser.parseAdd("Attend meeting from 4 to 6");
		assertEquals("Attend meeting", task.getTitle());

		task = parser.parseAdd("Cook dinner at 7");
		assertEquals("Cook dinner", task.getTitle());

		task = parser.parseAdd("Attend meeting on this Wed");
		assertEquals("Attend meeting", task.getTitle());

		task = parser.parseAdd("Do homework by next Sunday");
		assertEquals("Do homework", task.getTitle());

		task = parser.parseAdd("Send 100 email before 8pm");
		assertEquals("Send 100 email", task.getTitle());

		task = parser.parseAdd("Meet at \"Taco Tuesday\" on Wednesday 5pm");
		assertEquals("Meet at \"Taco Tuesday\"", task.getTitle());

		task =  parser.parseAdd("Chase \"2pm\" Korean band on Saturday 7pm");
		assertEquals("Chase \"2pm\" Korean band", task.getTitle());

		task = parser.parseAdd("Attend meeting from Monday to Wednesday 6pm");
		assertEquals("Attend meeting", task.getTitle());

		task = parser.parseAdd("Cook dinner at 7pm at home");
		assertEquals("Cook dinner at home", task.getTitle());

		task = parser.parseAdd("Cook dinner on 24 Mar 7pm");
		assertEquals("Cook dinner", task.getTitle());

		task = parser.parseAdd("Do assignment by Sunday 8pm");
		assertEquals("Do assignment", task.getTitle());

		task = parser.parseAdd("Send 100 email before sunday 7pm");
		assertEquals("Send 100 email", task.getTitle());
	}
	
	/**
	 * Test for specifying priority level in command for adding or editing.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle
	 */
	@Test
	public void testPriorityInCommand() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();	
		Task task,task2;
		
		task = parser.parseAdd("eat brownie p1");
		assertEquals(1, task.getPriority());
		assertEquals("eat brownie P:1", task.toString());
		
		task = parser.parseAdd("eat brownie p 2");
		assertEquals(2, task.getPriority());
		assertEquals("eat brownie P:2", task.toString());
		
		task = parser.parseAdd("eat brownie priority3");
		assertEquals(3, task.getPriority());
		assertEquals("eat brownie P:3", task.toString());
		
		task = parser.parseAdd("eat brownie priority 3");
		assertEquals(3, task.getPriority());
		assertEquals("eat brownie P:3", task.toString());
		
		task = parser.parseAdd("eat brownie from 1/5 10pm to 11pm priority 3");
		assertEquals(3, task.getPriority());
		assertEquals("eat brownie 1 May from 10pm - 11pm P:3", task.toString());	
		
		//for editing
		task2 = parser.parseEdit(task, "priority 2");
		assertEquals("eat brownie 1 May from 10pm - 11pm P:2", task2.toString());	
	}
	
	/**
	 * Test for parsing date with year (and time).
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle
	 */
	@Test
	public void testAddEditWithYear() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();	
		Task task,task2;
		
		task = parser.parseAdd("Buy fountain pen on 30/4/2017");
		assertEquals("Buy fountain pen on 30 Apr 2017", task.toString());
		
		task = parser.parseAdd("Buy fountain pen on 30/4/17");
		assertEquals("Buy fountain pen on 30 Apr 2017", task.toString());
		
		task = parser.parseAdd("Buy fountain pen on 30/4/2017 8pm");
		assertEquals("Buy fountain pen on 30 Apr 2017 at 8pm", task.toString());
		
		task = parser.parseAdd("Buy fountain pen on 30/4/17 8pm");
		assertEquals("Buy fountain pen on 30 Apr 2017 at 8pm", task.toString());
		
		task = parser.parseAdd("Go Japan from 1/5/17 8am to 30/5/17 10pm");
		assertEquals("Go Japan from 1 May 2017 8am - 30 May 2017 10pm", task.toString());
		
		task = parser.parseAdd("Go Japan from 1/5/17 8am to 30/5/17 10pm");
		task2 = parser.parseEdit(task, "9-11pm");
		assertEquals("Go Japan from 1 May 2017 9pm - 30 May 2017 11pm", task2.toString());
		
		task = parser.parseAdd("Go Japan from 1/5/17 8am to 30/5/17 10pm");
		task2 = parser.parseEdit(task, "1/6");
		assertEquals("Go Japan on 1 Jun", task2.toString());
		
		task = parser.parseAdd("Go Japan from 1/5/17 8am to 30/5/17 10pm");
		task2 = parser.parseEdit(task, "1/6/17");
		assertEquals("Go Japan on 1 Jun 2017", task2.toString());
		
		task = parser.parseAdd("Buy fountain pen on 30 april 2017");
		assertEquals("Buy fountain pen on 30 Apr 2017", task.toString());
		
		task = parser.parseAdd("Buy fountain pen on 30 apr 17");
		assertEquals("Buy fountain pen on 30 Apr 2017", task.toString());
		
		task = parser.parseAdd("Buy fountain pen by 30 april 2017 8pm");
		assertEquals("Buy fountain pen by 30 Apr 2017 8pm", task.toString());
		
		task = parser.parseAdd("Buy fountain pen on 30 apr 17 9pm");
		assertEquals("Buy fountain pen on 30 Apr 2017 at 9pm", task.toString());
		
		task = parser.parseAdd("Go Japan from 1 may 2017 8am to 30 may 2017 10pm");
		assertEquals("Go Japan from 1 May 2017 8am - 30 May 2017 10pm", task.toString());
		
		task = parser.parseAdd("Go Japan from 1 may 17 8am to 30 may 17 10pm");
		assertEquals("Go Japan from 1 May 2017 8am - 30 May 2017 10pm", task.toString());
		
		task = parser.parseAdd("Go Japan from 1 may 17 8am to 30may 17 10pm");
		task2 = parser.parseEdit(task, "9-11pm");
		assertEquals("Go Japan from 1 May 2017 9pm - 30 May 2017 11pm", task2.toString());
		
		task = parser.parseAdd("Go Japan from 1may 17 8am to 30may 17 10pm");
		task2 = parser.parseEdit(task, "1jun");
		assertEquals("Go Japan on 1 Jun", task2.toString());
		
		task = parser.parseAdd("Go Japan from 1may 17 8am to 30may 17 10pm");
		task2 = parser.parseEdit(task, "1june 2017");
		assertEquals("Go Japan on 1 Jun 2017", task2.toString());		
	}
	
	/**
	 * Test method for comparing task.
	 * Tasks are compared by their creation date.
	 * Task with same title would not be equal.
	 * 
	 * @throws InterruptedException for Thread.sleep().
	 * Ensures that there are differences in time when creating task.
	 * @throws InvalidLabelFormat 
	 * @throws InvalidTitle 
	 */
	@Test
	public void testCompareTo() throws InterruptedException, InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task1, task2;

		task1 = parser.parseAdd("Cook dinner at 7pm");
		Thread.sleep(2000);
		task2 = parser.parseAdd("Cook dinner at 7pm");
		assertEquals(-1, task1.compareTo(task2));

		task1 = parser.parseAdd("Cook dinner at 8pm");
		Thread.sleep(2000);
		task2 = parser.parseAdd("Cook dinner at 9pm");
		assertEquals(-1, task1.compareTo(task2));

		task1 = parser.parseAdd("Attend meeting");
		Thread.sleep(2000);
		task2 = parser.parseAdd("Attend meeting #important");
		assertEquals(-1, task1.compareTo(task2));
	}
	
	// =============================
	// Edit's stuff
	// =============================
	
	/**
	 * Test extracting index for edit.
	 */
	@Test
	public void testGetIndexForEdit() {
		CommandParser parser = new CommandParser();
		int index;
		
		index = parser.getIndexForEdit("edit 1 23 march");
		assertEquals(1, index);
		
		index = parser.getIndexForEdit("edit 2 1 april 7pm");
		assertEquals(2, index);
		
		index = parser.getIndexForEdit("edit 3 1 april 7pm-8pm");
		assertEquals(3, index);
		
		index = parser.getIndexForEdit("edit 4 buy chocolate #party on 1 april");
		assertEquals(4, index);
		
		index = parser.getIndexForEdit("edit 1 april");
		assertEquals(-1, index);
	}
	
	/**
	 * Test if date is detected in string.
	 * If detected, Date object is returned.
	 * Else, null is returned.
	 * 
	 * Note that there are some special cases in the method getDateForSearch.
	 */
	@Test
	public void testGetDateForSearch() {
		CommandParser parser = new CommandParser();
		Date date;
		
		date = parser.getDateForSearch("1 march");
		assertNotNull(date);
		
		date = parser.getDateForSearch("1/3");
		assertNotNull(date);
		
		date = parser.getDateForSearch("today");
		assertNotNull(date);
		
		date = parser.getDateForSearch("tomorrow");
		assertNotNull(date);
		
		date = parser.getDateForSearch("meeting");
		assertNull(date);
		
		date = parser.getDateForSearch("finance proposal");
		assertNull(date);
	}
	
	/**
	 * Test editing of an existing task.
	 *
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testEditBasic() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task, task2;
		
    	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "Buy chocolate");
    	assertEquals("Buy chocolate", task2.toString());

    	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "Buy chocolate #party");
    	assertEquals("Buy chocolate #party", task2.toString());
    	
    	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "Buy chocolate by 11pm");
    	assertEquals("Buy chocolate by today 11pm", task2.toString());

     	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "Buy chocolate from 11pm");
    	assertEquals("Buy chocolate today at 11pm", task2.toString());
    	
    	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "Buy milk at discount from 10pm to 11pm");
    	assertEquals("Buy milk at discount today at 10pm - 11pm", task2.toString());
	}
	
	/**
	 * Test editing time of existing task.
	 * Old information should be retained.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testEditTimeOnly() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task, task2;
    	
     	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "by 11");
    	assertEquals("Buy milk by today 11pm", task2.toString());
    	
    	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "11pm");
    	assertEquals("Buy milk today at 11pm", task2.toString());

    	task = parser.parseAdd("Buy milk");
    	task2 = parser.parseEdit(task, "10pm to 11pm");
    	assertEquals("Buy milk today at 10pm - 11pm", task2.toString());
    	
    	task = parser.parseAdd("Buy milk at 10pm");
    	task2 = parser.parseEdit(task, "10pm to 11pm");
    	assertEquals("Buy milk today at 10pm - 11pm", task2.toString());
    	
    	task = parser.parseAdd("Buy milk from 9 to 10pm");
    	task2 = parser.parseEdit(task, "by 11:51pm");
    	assertEquals("Buy milk by today 11:51pm", task2.toString());
    	
    	task = parser.parseAdd("Buy milk from 7 to 8pm");
    	task2 = parser.parseEdit(task, "from 9 to 10pm");
    	assertEquals("Buy milk today at 9pm - 10pm", task2.toString());
	}
	
	@Test
	public void testEditTimeOnly2() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task, task2;
		
		task = parser.parseAdd("Buy milk on 1 may at 2pm #party");
		
		task2 = parser.parseEdit(task, "3am");
		assertEquals("Buy milk on 1 May at 3am #party", task2.toString());

		task2 = parser.parseEdit(task, "3pm");
		assertEquals("Buy milk on 1 May at 3pm #party", task2.toString());

		task2 = parser.parseEdit(task, "at 4");
		assertEquals("Buy milk on 1 May at 4am #party", task2.toString());

		task2 = parser.parseEdit(task, "at 4am");
		assertEquals("Buy milk on 1 May at 4am #party", task2.toString());

		task2 = parser.parseEdit(task, "at 4pm");
		assertEquals("Buy milk on 1 May at 4pm #party", task2.toString());

		task2 = parser.parseEdit(task, "3-4pm");
		assertEquals("Buy milk 1 May from 3pm - 4pm #party", task2.toString());

		task2 = parser.parseEdit(task, "3pm-4pm");
		assertEquals("Buy milk 1 May from 3pm - 4pm #party", task2.toString());

		task2 = parser.parseEdit(task, "3pm-4");
		assertEquals("Buy milk 1 May from 3pm - 4am #party", task2.toString());

		task2 = parser.parseEdit(task, "from 3-4pm");
		assertEquals("Buy milk 1 May from 3pm - 4pm #party", task2.toString());

		task2 = parser.parseEdit(task, "from 3pm-4pm");
		assertEquals("Buy milk 1 May from 3pm - 4pm #party", task2.toString());

		task2 = parser.parseEdit(task, "from 3pm-4");
		assertEquals("Buy milk 1 May from 3pm - 4am #party", task2.toString());
	}
	
	/**
	 * Test editing of task.
	 * If information is not specified, use the old task information.
	 * This allows updating of only the date or time.
	 * If only the date is specified, the time will not be retained.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle 
	 */
	@Test
	public void testOverallEdit() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task, task2;
		
		task = parser.parseAdd("Buy milk by 30 april 7pm");
		task2 = parser.parseEdit(task, "by 4pm");
		assertEquals("Buy milk by 30 Apr 4pm", task2.toString());
		assertEquals(0, task2.getPriority());
		
		task = parser.parseAdd("Buy milk by 30 april 7pm");
		task.togglePriority(true);
		task2 = parser.parseEdit(task, "from 1 to 3pm");
		assertEquals("Buy milk 30 Apr from 1pm - 3pm P:1", task2.toString());
		assertEquals(1, task2.getPriority());
		
		task = parser.parseAdd("Buy milk by 10 apr");
		task.togglePriority(true);
		task.togglePriority(true);
    	task2 = parser.parseEdit(task, "by 20 april 8pm");
    	assertEquals("Buy milk by 20 Apr 8pm P:2", task2.toString());
    	assertEquals(2, task2.getPriority());		
    	
		task = parser.parseAdd("Buy kitkat by 10 april 7pm");
		task.togglePriority(true);
		task.togglePriority(true);
		task.togglePriority(true);
		task.setPriority(3);
		task2 = parser.parseEdit(task, "by 30 april");
		assertEquals("Buy kitkat by 30 Apr P:3", task2.toString());
		assertEquals(3, task2.getPriority());
		
		task = parser.parseAdd("Buy kitkat by 10 april 7pm");
		task2 = parser.parseEdit(task, "FROM 25 APR TO 26 APRIL");
		assertEquals("Buy kitkat from 25 Apr - 26 Apr", task2.toString());	
	}
	
	@Test
	public void testOverallEdit2() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();
		Task task, task2;
		
		task = parser.parseAdd("Drink coffee from 1/6 to 3/6 8pm #overdose");
		task2 = parser.parseEdit(task, "1/7 to 3/7");
		assertEquals("Drink coffee from 1 Jul - 3 Jul #overdose", task2.toString());
		
		task2 = parser.parseEdit(task, "Drink hot chocolate");
		assertEquals("Drink hot chocolate from 1 Jun 8pm - 3 Jun 8pm #overdose", task2.toString());
		
		task2 = parser.parseEdit(task, "#beedohbeedoh");
		assertEquals("Drink coffee from 1 Jun 8pm - 3 Jun 8pm #beedohbeedoh", task2.toString());
		
		task2 = parser.parseEdit(task, "1 july");
		assertEquals("Drink coffee on 1 Jul #overdose", task2.toString());
		
		task2 = parser.parseEdit(task, "from 9 to 10pm");
		assertEquals("Drink coffee from 1 Jun 9pm - 3 Jun 10pm #overdose", task2.toString());
		
		task2 = parser.parseEdit(task, "by 1 may 2pm");
		assertEquals("Drink coffee by 1 May 2pm #overdose", task2.toString());
	}
	
	/**
	 * Tests for usage of common abbreviations of words.
	 * 
	 * @throws InvalidLabelFormat
	 * @throws InvalidTitle
	 */
	@Test
	public void testShortcut() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();	
		Task task,task2;
		
		task = parser.parseAdd("Supper tmr 11pm");
		assertEquals("Supper on this Fri at 11pm", task.toString());
		
		task = parser.parseAdd("Supper tml 11pm");
		assertEquals("Supper on this Fri at 11pm", task.toString());
		
		task = parser.parseAdd("Supper tmrw 11pm");
		assertEquals("Supper on this Fri at 11pm", task.toString());
		
		task = parser.parseAdd("Donate books");
		task2 = parser.parseEdit(task, "tmr 11pm");
		assertEquals("Donate books on this Fri at 11pm", task2.toString());
		
		task = parser.parseAdd("Supper today 8pm");
		assertEquals("Supper today at 8pm", task.toString());
		
		task = parser.parseAdd("Supper tdy 8pm");
		assertEquals("Supper today at 8pm", task.toString());
		
		task = parser.parseAdd("Donate books");
		task2 = parser.parseEdit(task, "tdy 11pm");
		assertEquals("Donate books today at 11pm", task2.toString());
	}
		
	// =============================
	// Test parsing indexes
	// =============================

	/**
	 * Test parsing of indexes.
	 * 
	 * @throws InvalidTaskIndexFormat
	 */
	@Test
	public void testIndexes() throws InvalidTaskIndexFormat {
		CommandParser parser = new CommandParser();
		ParseIndexResult indexes;
		indexes = parser.parseIndexes("delete 1", 2);

		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		expectedIndexes.add(1);
		assertEquals(expectedIndexes, indexes.getValidIndexes());

		indexes = parser.parseIndexes("del 1,3,5,7,9", 10);
		expectedIndexes.clear();
		expectedIndexes.add(1);
		expectedIndexes.add(3);
		expectedIndexes.add(5);
		expectedIndexes.add(7);
		expectedIndexes.add(9);
		assertEquals(expectedIndexes, indexes.getValidIndexes());

		indexes = parser.parseIndexes("done 1-10", 10);
		expectedIndexes.clear();
		expectedIndexes.add(1);
		expectedIndexes.add(2);
		expectedIndexes.add(3);
		expectedIndexes.add(4);
		expectedIndexes.add(5);
		expectedIndexes.add(6);
		expectedIndexes.add(7);
		expectedIndexes.add(8);
		expectedIndexes.add(9);
		expectedIndexes.add(10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());

		indexes = parser.parseIndexes("undone 1-3,4,5,6-9,10", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());
		
		indexes = parser.parseIndexes("done 1-10,5,6,7,8,9,10", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());
	}
	
	/**
	 * Test parsing of invalid indexes.
	 * 
	 * @throws InvalidTaskIndexFormat
	 */
	@Test
	public void testInvalidIndexes() throws InvalidTaskIndexFormat {
		CommandParser parser = new CommandParser();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		ParseIndexResult indexes;
		
		indexes = parser.parseIndexes("del 11", 10);
		expectedIndexes.add(11);
		assertEquals(true, indexes.hasInvalidIndex());
		assertEquals(expectedIndexes, indexes.getInvalidIndexes());
		
		indexes = parser.parseIndexes("del 11,12,13", 10);
		expectedIndexes.clear();
		expectedIndexes.add(11);
		expectedIndexes.add(12);
		expectedIndexes.add(13);
		assertEquals(true, indexes.hasInvalidIndex());
		assertEquals(expectedIndexes, indexes.getInvalidIndexes());
		
		indexes = parser.parseIndexes("del 11-13", 10);
		assertEquals(true, indexes.hasInvalidIndex());
		assertEquals(expectedIndexes, indexes.getInvalidIndexes());
	}
	
	/**
	 * Test parsing of indexes when user input does not follow the "usual" way.
	 * 
	 * @throws InvalidTaskIndexFormat
	 */
	@Test
	public void testUnconventionalIndexes() throws InvalidTaskIndexFormat {
		CommandParser parser = new CommandParser();

		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		expectedIndexes.add(1);
		expectedIndexes.add(2);
		expectedIndexes.add(3);
		expectedIndexes.add(4);
		expectedIndexes.add(5);
		expectedIndexes.add(6);
		expectedIndexes.add(7);
		expectedIndexes.add(8);
		expectedIndexes.add(9);
		expectedIndexes.add(10);

		ParseIndexResult indexes;
		indexes = parser.parseIndexes("del 1--10", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());

		indexes = parser.parseIndexes("del 1-----10", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());

		indexes = parser.parseIndexes("del 1-3-5-7-9-10", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());    	

		indexes = parser.parseIndexes("del 10-1", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());

		indexes = parser.parseIndexes("del 10-9-7-5-3-1", 10);
		assertEquals(expectedIndexes, indexes.getValidIndexes());
	}

	/**
	 * Test for invalid input for parsing indexes.
	 * Exceptions should be thrown.
	 * 
	 * @throws InvalidTaskIndexFormat
	 */
	@Test
	public void testInvalidDelete() throws InvalidTaskIndexFormat {
		boolean thrown;
		CommandParser parser = new CommandParser();
		ParseIndexResult indexes;

		thrown = false;
		try {
			indexes = parser.parseIndexes("del -1,-2", 10);
		} catch (InvalidTaskIndexFormat e) {
			thrown = true;
		}
		
		assertEquals(true, thrown);

		thrown = false;
		try {
			indexes = parser.parseIndexes("del 1-,10", 10);
		} catch (InvalidTaskIndexFormat e) {
			thrown = true;
		}
		assertEquals(true, thrown);        

		thrown = false;
		try {
			indexes = parser.parseIndexes("del abc,def", 10);
		} catch (InvalidTaskIndexFormat e) {
			thrown = true;
		}
		assertEquals(true, thrown);        
	}
	
	/**
	 * Test for getting valid and invalid indexes string.
	 * 
	 * @throws InvalidTaskIndexFormat
	 */
	@Test
	public void testIndexesString() throws InvalidTaskIndexFormat {
		CommandParser parser = new CommandParser();	
		ParseIndexResult indexes;
		
		indexes = parser.parseIndexes("del 1-10,12,13,14,15", 10);
		assertEquals("1-10", indexes.getValidIndexesString());
		assertEquals("12-15", indexes.getInvalidIndexesString());
		
		indexes = parser.parseIndexes("del 1-5,10-20, 31, 32, 33, 35", 10);
		assertEquals("1-5,10", indexes.getValidIndexesString());
		assertEquals("11-20,31-33,35", indexes.getInvalidIndexesString());	
	}

	// =============================
	// Latest stuff
	// =============================
	@Test
	public void testBuggyTheClown() throws InvalidLabelFormat, InvalidTitle {
		CommandParser parser = new CommandParser();	
		Task task,task2;
		
		//?!?!?!??! lol whut
		task = parser.parseAdd("cousin 10 may 7pm");
		System.out.println(task.toString());
		task = parser.parseAdd("apple 10 may 7pm");
		System.out.println(task.toString());

	}
}
```
