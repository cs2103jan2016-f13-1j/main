# A0126297X
###### /src/main/data/ParseIndexResult.java
``` java
package main.data;

import java.util.ArrayList;
import java.util.Collections;

public class ParseIndexResult {
    private boolean hasValid;
    private boolean hasInvalid;
    private ArrayList<Integer> validIndexes;
    private ArrayList<Integer> invalidIndexes;

    public ParseIndexResult() {
        hasValid = false;
        hasInvalid = false;
        validIndexes = null;
        invalidIndexes = null;
    }

    public boolean hasValidIndex() {
        return hasValid;
    }

    public void setHasValid(boolean hasValid) {
        this.hasValid = hasValid;
    }

    public boolean hasInvalidIndex() {
        return hasInvalid;
    }

    public void setHasInvalid(boolean hasInvalid) {
        this.hasInvalid = hasInvalid;
    }

    public ArrayList<Integer> getValidIndexes() {
        return validIndexes;
    }

    public void setValidIndexes(ArrayList<Integer> validIndexes) {
        this.validIndexes = validIndexes;
    }

    public ArrayList<Integer> getInvalidIndexes() {
        return invalidIndexes;
    }

    public void setInvalidIndexes(ArrayList<Integer> invalidIndexes) {
        this.invalidIndexes = invalidIndexes;
    }

    public String getValidIndexesString() {
        return convertIndexesToString(validIndexes);
    }

    public String getInvalidIndexesString() {
        return convertIndexesToString(invalidIndexes);
    }

    /**
     * This method converts an {@code ArrayList<Integer>} of indexes to {@code String}.
     * This method is used by the UI.
     * 
     * @param indexes
     *            {@code ArrayList<Integer>} to be converted
     * @return {@code String} of converted indexes
     */
    private String convertIndexesToString(ArrayList<Integer> indexes) {
        StringBuilder stringBuilder = new StringBuilder();
        boolean isRange = false;
        Collections.sort(indexes);
        
        int start = indexes.get(0);
        stringBuilder.append(start);

        for (int i = 1; i < indexes.size(); i++) {
            int next = indexes.get(i);

            if ((next - 1) == start) {
                isRange = true;
                start = next;
            } else {
                if (isRange) {
                    stringBuilder.append("-" + start);
                    isRange = false;
                } else {
                    stringBuilder.append("," + start);
                }
                start = next;
                stringBuilder.append("," + start);
            }
        }

        if (isRange) {
            // account for having a range at the end
            stringBuilder.append("-" + start);
        }

        return stringBuilder.toString();
    }
}
```
###### /src/main/data/Task.java
``` java
package main.data;

import java.text.DateFormatSymbols;
import java.text.SimpleDateFormat;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;

public class Task {
    private String title;
    private Date startDate;
    private Date endDate;
    private boolean isDatedOnly;
    private String label;
    private boolean done;
    private int priority;
    private Date createdDate;
    private Date completedDate;
    private boolean collideWithPrev;
    private boolean collideWithNext;

    public Task() {
    }
    
    public Task(String title) {
        this.title = title;
        startDate = null;
        endDate = null;
        isDatedOnly = false;
        label = null;
        done = false;
        priority = 0;
        createdDate = new Date();
        completedDate = null;
        collideWithPrev = false;
        collideWithNext = false;
    }

    public Task(String title, Date startDate, Date endDate, String label) {
        this.title = title;
        this.startDate = startDate;
        this.endDate = endDate;
        isDatedOnly = false;
        this.label = label;
        done = false;
        priority = 0;
        createdDate = new Date();
        completedDate = null;
        collideWithPrev = false;
        collideWithNext = false;
    }
    
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Date getStartDate() {
        return startDate;
    }

    public Date getEndDate() {
        return endDate;
    }

    public boolean getIsDatedOnly() {
        return isDatedOnly;
    }

    public void setIsDatedOnly(boolean isDatedOnly) {
        this.isDatedOnly = isDatedOnly;
    }

    public String getLabel() {
        return label;
    }

    public boolean hasLabel() {
        if (label == null) {
            return false;
        } else {
            return true;
        }
    }

    public boolean isDone() {
        return done;
    }

    public void toggleDone() {
        if (isDone()) {
            setNotCompleted();
        } else {
            setIsCompleted();
        }
    }

    public int getPriority() {
        return priority;
    }

    public void setPriority(int priority) {
        this.priority = priority;
    }

    public int togglePriority(boolean increase) {
        int limit = 3;
        if (increase) {
            priority++;
            if (priority > limit) {
                priority = 0;
            }
        } else {
            priority--;
            if (priority < 0) {
                priority = limit;
            }
        }
        return priority;
    }

    public Date getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }

    public Date getCompletedDate() {
        return completedDate;
    }

    public void setIsCompleted() {
        done = true;
        completedDate = new Date();
    }

    public void setNotCompleted() {
        done = false;
        completedDate = null;
    }

    public boolean getCollideWithPrev() {
        return collideWithPrev;
    }

    public void setCollideWithPrev(boolean collide) {
        collideWithPrev = collide;
    }

    public boolean getCollideWithNext() {
        return collideWithNext;
    }

    public void setCollideWithNext(boolean collide) {
        collideWithNext = collide;
    }

    public boolean hasDate() {
        return (startDate != null || endDate != null);
    }

    public boolean hasDateRange() {
        return (startDate != null && endDate != null);
    }

    public boolean hasStartDate() {
        if (startDate == null) {
            return false;
        } else {
            return true;
        }
    }

    public boolean hasEndDate() {
        if (endDate == null) {
            return false;
        } else {
            return true;
        }
    }

    public boolean hasSingleDate() {
        if (startDate == null && endDate != null) {
            return true;
        } else if (startDate != null & endDate == null) {
            return true;
        } else {
            return false;
        }
    }

    public Date getSingleDate() {
        if (startDate == null && endDate != null) {
            return endDate;
        } else {
            return startDate;
        }
    }

    public int compareTo(Task task) {
        if (!createdDate.equals(task.getCreatedDate())) {
            return -1;
        }
        return 0;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     * This method generates the task feedback for UI to display to user.
     */
    public String toString() {
        if (hasDate()) {
            if (hasDateRange()) {
                return getFeedbackForRange();
            } else if (hasStartDate()) {
                return getFeedbackForStart();
            } else if (hasEndDate()) {
                return getFeedbackForEnd();
            }
        }
        return getFeedbackForFloating();
    }

    private String getFeedbackForRange() {
        int indexTitle = 0;
        int indexStartDate = 1;
        int indexStartTime = 2;
        int indexStartYear = 3;
        int indexEndDate = 4;
        int indexEndTime = 5;
        int indexEndYear = 6;
        int indexIsDatedOnly = 9;

        ArrayList<String> fields = getTaskFields();
        String title = fields.get(indexTitle);
        String startDate = fields.get(indexStartDate);
        String startTime = fields.get(indexStartTime);
        String startYear = fields.get(indexStartYear);
        String endDate = fields.get(indexEndDate);
        String endTime = fields.get(indexEndTime);
        String endYear = fields.get(indexEndYear);
        String isDatedOnly = fields.get(indexIsDatedOnly);

        boolean isSameDay = startDate.equals(endDate) && startYear == null && endYear == null;
        boolean isToday = startDate.equals(endDate) && startDate.equals("today");

        StringBuilder stringBuilder = new StringBuilder(title);

        if (isSameDay) {
            stringBuilder.append(" " + startDate);
        } else {
            stringBuilder.append(" from " + startDate);
        }

        if (startYear != null) {
            stringBuilder.append(" " + startYear);
        }

        if (isToday) {
            stringBuilder.append(" at");
        } else if (isSameDay) {
            stringBuilder.append(" from");
        }

        if (!isDatedOnly.equals("true")) {
            stringBuilder.append(" " + startTime);
        }

        if (isSameDay) {
            stringBuilder.append(" - " + endTime);
        } else {
            stringBuilder.append(" - " + endDate);

            if (endYear != null) {
                stringBuilder.append(" " + endYear);
            }

            if (!isDatedOnly.equals("true")) {
                stringBuilder.append(" " + endTime);
            }
        }
        String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
        return feedback;
    }

    private String getFeedbackForStart() {
        int indexTitle = 0;
        int indexStartDate = 1;
        int indexStartTime = 2;
        int indexStartYear = 3;
        int indexIsDatedOnly = 9;

        ArrayList<String> fields = getTaskFields();
        String title = fields.get(indexTitle);
        String startDate = fields.get(indexStartDate);
        String startTime = fields.get(indexStartTime);
        String startYear = fields.get(indexStartYear);
        String isDatedOnly = fields.get(indexIsDatedOnly);

        boolean isToday = startDate.equals("today");

        StringBuilder stringBuilder = new StringBuilder(title);

        if (isToday) {
            stringBuilder.append(" " + startDate);
        } else {
            stringBuilder.append(" on " + startDate);
        }

        if (startYear != null) {
            stringBuilder.append(" " + startYear);
        }

        if (!isDatedOnly.equals("true")) {
            stringBuilder.append(" at " + startTime);
        }

        String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
        return feedback;
    }

    private String getFeedbackForEnd() {
        int indexTitle = 0;
        int indexEndDate = 4;
        int indexEndTime = 5;
        int indexEndYear = 6;
        int indexIsDatedOnly = 9;

        ArrayList<String> fields = getTaskFields();
        String title = fields.get(indexTitle);
        String endDate = fields.get(indexEndDate);
        String endTime = fields.get(indexEndTime);
        String endYear = fields.get(indexEndYear);
        String isDatedOnly = fields.get(indexIsDatedOnly);

        StringBuilder stringBuilder = new StringBuilder(title);

        stringBuilder.append(" by " + endDate);

        if (endYear != null) {
            stringBuilder.append(" " + endYear);
        }

        if (!isDatedOnly.equals("true")) {
            stringBuilder.append(" " + endTime);
        }

        String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
        return feedback;
    }

    private String getFeedbackForFloating() {
        int indexTitle = 0;
        ArrayList<String> fields = getTaskFields();
        String title = fields.get(indexTitle);

        StringBuilder stringBuilder = new StringBuilder(title);
        String feedback = getFeedbackForLabelAndPriority(stringBuilder.toString());
        return feedback;
    }

    private String getFeedbackForLabelAndPriority(String feedback) {
        int indexLabel = 7;
        int indexPriority = 8;
        ArrayList<String> fields = getTaskFields();
        String label = fields.get(indexLabel);
        String priority = fields.get(indexPriority);

        if (label != null) {
            feedback = feedback.concat(" #" + label);
        }

        if (!priority.equals("0")) {
            priority = getPriorityString(Integer.parseInt(priority));
            feedback = feedback.concat(" P:" + priority);
        }

        return feedback;
    }
    
    private String getPriorityString(int priority) {
        String level = null;
            switch (priority) {
                case 1 :
                    level = "low";
                    break;
                    
                case 2 :
                    level = "mid";
                    break;
        
                case 3:
                    level = "high";
                    break;
                    
                default :
                    break;
            }
        return level;
    }

    /**
     * Get attributes that is in task object to form feedback
     * 
     * In order:
     * 0 - Title
     * 1 - Start Date
     * 2 - Start Time
     * 3 - Start Year
     * 4 - End Date
     * 5 - End Time
     * 6 - End Year
     * 7 - Label
     * 8 - Priority
     * 9 - isDatedOnly
     * 
     * @return ArrayList<String> of size 10
     */
    private ArrayList<String> getTaskFields() {
        ArrayList<String> fields = new ArrayList<String>();

        fields.add(title);

        if (hasDate()) {
            if (hasStartDate()) {
                fields.add(convertDate(startDate));
                fields.add(convertTime(startDate));
                fields.add(convertYear(startDate));
            } else {
                fields.add(null);
                fields.add(null);
                fields.add(null);
            }

            if (hasEndDate()) {
                fields.add(convertDate(endDate));
                fields.add(convertTime(endDate));
                fields.add(convertYear(endDate));
            } else {
                fields.add(null);
                fields.add(null);
                fields.add(null);
            }
        } else {
            fields.add(null);
            fields.add(null);
            fields.add(null);
            fields.add(null);
            fields.add(null);
            fields.add(null);
        }

        if (hasLabel()) {
            fields.add(label);
        } else {
            fields.add(null);
        }

        fields.add(Integer.toString(getPriority()));
        fields.add(String.valueOf(isDatedOnly));
        return fields;
    }

    private String convertDate(Date date) {
        if (dateIsToday(date)) {
            return "today";
        }

        DayOfWeek day = getDay(date);
        String dayShort = getShortDay(day);

        if (dateIsThisWeek(date)) {
            return "this ".concat(dayShort);
        } else if (dateIsNextWeek(date)) {
            return "next ".concat(dayShort);
        } else {
            Month month = getMonth(date);
            String monthShort = getShortMonth(month);
            return getDate(date).concat(" ").concat(monthShort);
        }
    }

    public boolean dateIsToday(Date date) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("ddMMyyyy");
        String today = dateFormat.format(new Date());

        String dateString = dateFormat.format(date);
        if (today.equals(dateString)) {
            return true;
        } else {
            return false;
        }
    }

    private DayOfWeek getDay(Date date) {
        LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        DayOfWeek day = dateTime.getDayOfWeek();
        return day;
    }

    private String getShortDay(DayOfWeek day) {
        DateFormatSymbols symbols = new DateFormatSymbols();
        String[] days = symbols.getShortWeekdays();
        List<String> correctedDays = new ArrayList<String>(Arrays.asList(days));
        correctedDays.remove(0);
        correctedDays.remove(0);
        correctedDays.add("Sun");

        int value = day.getValue() - 1;
        return correctedDays.get(value);
    }

    private boolean dateIsThisWeek(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setFirstDayOfWeek(Calendar.MONDAY);

        int currentWeek = calendar.get(Calendar.WEEK_OF_YEAR);

        calendar.setTime(date);
        int dateWeek = calendar.get(Calendar.WEEK_OF_YEAR);

        if (dateWeek == currentWeek) {
            return true;
        } else {
            return false;
        }
    }

    private boolean dateIsNextWeek(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setFirstDayOfWeek(Calendar.MONDAY);

        int currentWeek = calendar.get(Calendar.WEEK_OF_YEAR);

        calendar.setTime(date);

        int dateWeek = calendar.get(Calendar.WEEK_OF_YEAR);
        int difference = dateWeek - currentWeek;

        if (difference == 1) {
            return true;
        } else {
            return false;
        }
    }

    private Month getMonth(Date date) {
        LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        Month month = dateTime.getMonth();
        return month;
    }

    private String getShortMonth(Month month) {
        DateFormatSymbols symbols = new DateFormatSymbols();
        String[] months = symbols.getShortMonths();
        int value = month.getValue() - 1;
        return months[value];
    }

    private String getDate(Date date) {
        LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        return Integer.toString(dateTime.getDayOfMonth());
    }

    private String convertTime(Date date) {
        SimpleDateFormat timeFormat = new SimpleDateFormat("mm");
        String minute = timeFormat.format(date);

        if (minute.equals("00")) {
            timeFormat = new SimpleDateFormat("ha");
        } else {
            timeFormat = new SimpleDateFormat("h:mma");
        }

        DateFormatSymbols symbols = new DateFormatSymbols(Locale.getDefault());
        symbols.setAmPmStrings(new String[] { "am", "pm" });
        timeFormat.setDateFormatSymbols(symbols);
        return timeFormat.format(date);
    }

    private String convertYear(Date date) {
        LocalDateTime now = LocalDateTime.now();
        String thisYear = Integer.toString(now.getYear());
        String year = getYear(date);

        if (thisYear.equals(year)) {
            return null;
        } else {
            return year;
        }
    }

    private String getYear(Date date) {
        LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        return Integer.toString(dateTime.getYear());
    }

    /**
     * This method formats the task's date for display purposes by the UI.
     * 
     * @return {@code String} of nicely formatted date
     */
    public String getSimpleDate() {
        Locale locale = Locale.getDefault();
        StringBuilder stringBuilder = new StringBuilder("");
        String start, end, startMonthString, endMonthString;
        start = end = startMonthString = endMonthString = "";

        LocalDateTime now = LocalDateTime.now();
        String thisYear = Integer.toString(now.getYear());

        if (startDate != null) {
            Month startMonth = getMonth(startDate);
            startMonthString = startMonth.getDisplayName(TextStyle.FULL, locale);
            start = getDate(startDate).concat(" ").concat(startMonthString);

            if (!getYear(startDate).equals(thisYear)) {
                start = start.concat(" ").concat(getYear(startDate));
            }
        }

        if (endDate != null) {
            Month endMonth = getMonth(endDate);
            endMonthString = endMonth.getDisplayName(TextStyle.FULL, locale);
            end = getDate(endDate).concat(" ").concat(endMonthString);

            if (!getYear(endDate).equals(thisYear)) {
                end = end.concat(" ").concat(getYear(endDate));
            }
        }

        if (hasDateRange()) {
            if (start.equals(end)) {
                stringBuilder.append(start);
            } else {
                stringBuilder.append(start + " - " + end);
            }
        } else if (hasStartDate()) {
            stringBuilder.append(start);
        } else if (hasEndDate()) {
            stringBuilder.append(end);
        }

        return stringBuilder.toString();
    }

    /**
     * This method formats the task's time for display purposes by the UI.
     * 
     * @return {@code String} nicely formatted time
     */
    public String getSimpleTime() {
        StringBuilder stringBuilder = new StringBuilder("");
        int indexStartTime = 2;
        int indexEndTime = 5;

        ArrayList<String> fields = getTaskFields();
        String startTime = fields.get(indexStartTime);
        String endTime = fields.get(indexEndTime);

        if (hasDateRange()) {
            stringBuilder.append(startTime + " - " + endTime);
        } else if (hasStartDate()) {
            stringBuilder.append(startTime);
        } else if (hasEndDate()) {
            stringBuilder.append("by " + endTime);
        } else {
            // floating task
            stringBuilder.append("-");
        }

        if (getIsDatedOnly()) {
            stringBuilder = new StringBuilder("-");
        }

        return stringBuilder.toString();
    }

    public boolean isOverdue() {
        if (hasDate()) {
            if (hasSingleDate()) {
                if (getSingleDate().before(new Date())) {
                    return true;
                } 
            } else {
                if (getEndDate().before(new Date())) {
                    return true;
                }
            }
        } else {
            return false;
        }
        return false;
    }
    
    /**
     * This method checks if a task is today.
     * If the task has a ranged time, it will always be today until it ends.
     * 
     * @return {@code boolean} true if is today
     */
    public boolean isToday() {
        if (hasDateRange()) {
            if (hasStarted()) {
                return true;
            } else {
                return false;
            }
        } else if (hasDate()) {
            return dateIsToday(getSingleDate());
        }

        return false;
    }

    public boolean hasStarted() {
        if (startDate == null) {
            return false;
        } else {
            return (startDate.compareTo(new Date()) < 0);
        }
    }

    /**
     * This method checks if a task is tomorrow.
     * 
     * If the task has a ranged time and it has started, check the end time.
     * If the end time is after tomorrow, then the task is tomorrow.
     * If the task has a ranged time and it has not started, check the start time.
     * If the start time is tomorrow, then the task is tomorrow.
     * 
     * @return {@code boolean} true if is tomorrow
     */
    public boolean isTomorrow() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, 1);

        SimpleDateFormat dateFormat = new SimpleDateFormat("ddMMyyyy");
        String tomorrow = dateFormat.format(cal.getTime());
        String starting = "";
        String ending = "";
        String single = "";
        Date tml = null, start = null, end = null, singleDate = null;

        try {
            tml = dateFormat.parse(tomorrow);
        } catch (Exception e) {
            return false;
        }

        if (hasDateRange()) {
            if (hasStarted()) {
                ending = dateFormat.format(endDate);

                try {
                    end = dateFormat.parse(ending);
                } catch (Exception e) {
                    return false;
                }

                if (end.after(tml)) {
                    return true;
                }
            } else {
                starting = dateFormat.format(startDate);

                try {
                    start = dateFormat.parse(starting);
                } catch (Exception e) {
                    return false;
                }

                if (start.equals(tml)) {
                    return true;
                }
            }
        } else if (hasDate()) {
            single = dateFormat.format(getSingleDate());

            try {
                singleDate = dateFormat.parse(single);
            } catch (Exception e) {
                return true;
            }

            if (singleDate.equals(tml)) {
                return true;
            }
        }
        return false;
    }

    /**
     * This methods check if a task is upcoming.
     * An upcoming task must be after today and tomorrow.
     * 
     * @return {@code boolean} true if upcoming
     */
    public boolean isUpcoming() {
        if (!isToday() && !isTomorrow()) {
            Date today = new Date();

            if (hasStartDate()) {
                if (today.before(startDate)) {
                    return true;
                }
            } else if (hasEndDate()) {
                if (today.before(endDate)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * This method checks if a task is without date.
     * Since tasks have no date, it it start/due someday.
     * 
     * @return {@code boolean} true if not dated
     */
    public boolean isSomeday() {
        if (hasDate()) {
            return false;
        } else {
            return true;
        }
    }
}
```
###### /src/main/parser/CommandParser.java
``` java
package main.parser;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.data.ParseIndexResult;
import main.data.Task;
import main.parser.exceptions.*;

public class CommandParser {
    private final String REGEX_PREPOSITION_ALL = "(?i)(\\b(from|after|at|on|by|before|to)\\b ?)";
    private final String REGEX_PREPOSITION_START = "(?i)\\b(from|after|at|on)\\b ?";
    private final String REGEX_DATE_NUM = "\\b((0?[1-9]|[12][0-9]|3[01])([/|-])(0?[1-9]|1[012]))\\b";
    private final String REGEX_DATE_NUM_YEAR = "\\b((0?[1-9]|[12][0-9]|3[01])([/|-])(0?[1-9]|1[012])([/|-])((19|20)?\\d\\d))\\b";
    private final String REGEX_DATE_TEXT = "\\b((0?[1-9]|[12][0-9]|3[01]) ?)";
    private final String REGEX_MONTH_TEXT = "((?i)(jan)(uary)?|" + "(feb)(ruary)?|" + "(mar)(ch)?|" + "(apr)(il)?|"
            + "(may)|" + "(jun)(e)?|" + "(jul)(y)?|" + "(aug)(ust)?|" + "(sep)(tember)?|" + "(oct)(ober)?|"
            + "(nov)(ember)?|" + "(dec)(ember)?)\\b";
    private final String REGEX_YEAR = "\\b ?((19|20)?\\d\\d)\\b";
    private final String REGEX_TIME_TWELVE = "((1[012]|0?[1-9])(([:|.][0-5][0-9])?))";
    private final String REGEX_TIME_PERIOD = "(?i)(am|pm)";
    private final String REGEX_DAYS = "\\b((?i)((mon)(day)?|(tue)(sday|s)?|"
            + "(wed)(nesday|s)?|(thu)(rsday|rs|r)?|(fri)(day)?|(sat)(urday)?|(sun)(day)?))\\b";
    private final String REGEX_WORD_DATED = "\\b(today|tdy|tonight|tomorrow|tmr|tml|tmrw)\\b";
    private final String REGEX_WORD_TIMED = "\\b(morning|afternoon|evening|midnight)\\b";
    private final String REGEX_PRIORITY = "\\b(?i)((priority) ?)(low|l|medium|m|mid|med|high|h)\\b";

    private final int DATE_INDEX = 0;
    private final int DATE_START = 0;
    private final int DATE_END = 1;
    private final int DATE_MAX_SIZE = 2;
    private final int DATE_FIELD_FULL = 3;

    private final String STRING_AM = "am";
    private final String STRING_PM = "pm";
    private final String STRING_TWELVE = "12";
    private final String STRING_NEXT_WEEK = "next week";

    private final int PRIORITY_LENGTH = 8;
    private final int PRIORITY_LOW = 1;
    private final int PRIORITY_MID = 2;
    private final int PRIORITY_HIGH = 3;

    private final int DOUBLE_DIGIT = 10;
    private final int LENGTH_OFFSET = 1;
    private final int INDEX_OFFSET = 1;

    private static final Logger logger = Logger.getLogger(CommandParser.class.getName());

    /**
     * This method builds a {@code Task} object.
     *
     * Tasks without date do not have any date/time specified. If a task has
     * only the date specified, the time is default set to 12am. Words with
     * prepositions might not be dated. Words without prepositions is dated if
     * time is explicitly specified.
     *
     * @param inputString
     *            {@code String} input to be processed
     * @return {@code Task} built
     * @throws InvalidLabelFormat
     */
    public Task parseAdd(String inputString) throws InvalidLabelFormat {
        assert (inputString != null);
        logger.log(Level.INFO, "Parsing for ADD command.");

        String title = null;
        String label = null;
        Date startDate = null;
        Date endDate = null;
        int priority = 0;

        boolean hasDay = false;
        boolean hasDate = false;
        boolean hasYear = false;
        boolean hasTime = false;
        boolean hasTimeRange = false;
        boolean hasPreposition = false;
        boolean hasTimeWithoutAmPm = false;
        boolean hasStartDate = false;
        boolean hasPriority = false;
        boolean hasLabel = false;
        boolean isDatedOnly = false;

        int numberOfDate = 0;
        List<Date> dates = new ArrayList<Date>();
        String regex = null;

        // check for day
        hasDay = checkForRegexMatch(getDayRegex(), inputString);

        // check for date with year in num format
        hasDate = checkForRegexMatch(getDateWithYearRegex(), inputString);
        if (hasDate) {
            hasYear = true;
        } else {
            // check for date in number format or text format
            hasDate = checkForRegexMatch(getDateRegex(), inputString)
                    || checkForRegexMatch(getDateTextRegex(), inputString);
        }

        // check for time with am/pm or check for word indicating time
        hasTime = checkForRegexMatch(getTimeRegex(), inputString) || checkForRegexMatch(REGEX_WORD_TIMED, inputString);
        hasTimeRange = checkForRegexMatch(getTimeRangeRegex(), inputString);

        // check for word indicating date
        if (checkForRegexMatch(REGEX_WORD_DATED, inputString)) {
            hasDate = true;
        }

        // check for preposition
        hasPreposition = checkForRegexMatch(REGEX_PREPOSITION_ALL, inputString);
        if (hasPreposition) {
            // check for time without am/pm
            hasTimeWithoutAmPm = checkForRegexMatch(getTimeWithoutAmPmRegex(), inputString);
            // check for start preposition only
            hasStartDate = checkForRegexMatch(REGEX_PREPOSITION_START, inputString);
        }

        inputString = correctUserInput(inputString);
        title = inputString;

        // check for priority
        hasPriority = checkForRegexMatch(REGEX_PRIORITY, inputString);
        if (hasPriority) {
            String priorityString = getPriorityString(inputString);
            priority = getPriority(priorityString);
            assert (priority > 0 && priority < 4);
            title = removeStringFromTitle(inputString, priorityString);
        }

        hasLabel = checkForLabel(inputString);
        if (hasLabel) {
            try {
                label = getLabel(inputString);
            } catch (Exception e) {
                logger.log(Level.WARNING, "Label cannot be parsed by parser.");
                logger.log(Level.WARNING, "InvalidLabelFormat exception thrown.");
                throw new InvalidLabelFormat("Invalid label input detected.");
            }

            if (!checkValidLabel(label)) {
                label = null;
                hasLabel = false;
            }

            if (hasLabel) {
                String labelString = "#".concat(label);
                title = removeStringFromTitle(title, labelString);
            }
        }

        inputString = title;
        inputString = correctDateNumFormat(inputString, hasYear);

        if (hasDate && hasTime) {
            dates = parseDateTime(inputString);
        } else if (hasDate) {
            dates = parseDateOnly(inputString);
            isDatedOnly = true;
        } else if (hasDay && hasTime) {
            dates = parseDateTime(inputString);
        } else if (hasDay) {
            dates = parseDayOnly(inputString);
            isDatedOnly = true;
        } else if (hasTime) {
            dates = parseTimeOnly(inputString);
        }

        if (inputString.contains(STRING_NEXT_WEEK)) {
            if (!hasTime) {
                isDatedOnly = true;
            }

            dates = correctNextWeek(dates);
            regex = getNextWeekRegex();
            title = removeRegex(regex, title);
        }

        if (hasPreposition && hasTimeWithoutAmPm) {
            dates = parseDateTime(inputString);
            dates = fixTimeForWithoutAmPm(dates);
        }

        numberOfDate = dates.size();
        if (numberOfDate > 0) {
            dates = assignDates(dates, hasPreposition, hasStartDate);
            startDate = dates.get(DATE_START);
            endDate = dates.get(DATE_END);

            if (hasDate) {
                regex = "\\b(the day after )" + REGEX_WORD_DATED;
                title = removeRegex(regex, title);
            }

            if (hasTime) {
                // remove timed word from title
                regex = REGEX_PREPOSITION_ALL + "?" + REGEX_WORD_TIMED;
                title = removeRegex(regex, title);

                if (hasTimeRange) {
                    // remove range from title
                    regex = "(" + REGEX_PREPOSITION_ALL + "?)(" + getTimeRangeRegex() + ")";
                    title = removeRegex(regex, title);
                }
            }

            if (hasDate) {
                if (hasYear) {
                    // remove date in num form with year from title
                    regex = getDateWithYearRegex();
                    title = removeRegex(regex, title);
                }

                // remove date in text form with year from title
                regex = getDateRegexTextWithYear();
                title = removeRegex(regex, title);

                // remove date in text form with corrected year due to shortform
                regex = "\\b ?'(\\d\\d)\\b";
                title = removeRegex(regex, title);

                // remove date in text form from title
                regex = getDateTextRegex();
                title = removeRegex(regex, title);
            }

            // remove remaining date information from title
            title = removeDateFromTitle(title, dates);
        }

        Task task = new Task(title, startDate, endDate, label);
        task.setPriority(priority);
        task.setIsDatedOnly(isDatedOnly);

        logger.log(Level.INFO, "Task object built.");

        if (title.length() == 0) {
            task.setTitle("<No title>");
            logger.log(Level.WARNING, "Title cannot be parsed by parser.");
            logger.log(Level.WARNING, "<No title> set for task's title.");
        }

        logger.log(Level.INFO, "Task object returned.");
        return task;
    }

    private boolean checkForRegexMatch(String regex, String inputString) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(inputString);
        return matcher.find();
    }

    private String getDayRegex() {
        return REGEX_PREPOSITION_ALL + "?" + REGEX_DAYS;
    }

    private String getDateWithYearRegex() {
        return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_NUM_YEAR;
    }

    private String getDateRegex() {
        return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_NUM;
    }

    private String getDateTextRegex() {
        return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_TEXT + REGEX_MONTH_TEXT;
    }

    private String getTimeRegex() {
        return "\\b" + REGEX_TIME_TWELVE + REGEX_TIME_PERIOD;
    }

    private String getTimeRangeRegex() {
        return "\\b" + REGEX_TIME_TWELVE + REGEX_TIME_PERIOD + "?" + "\\s?-\\s?" + "\\b" + REGEX_TIME_TWELVE
                + REGEX_TIME_PERIOD + "|" + "\\b" + REGEX_TIME_TWELVE + REGEX_TIME_PERIOD + "\\s?-\\s?" + "\\b"
                + REGEX_TIME_TWELVE + REGEX_TIME_PERIOD + "?\\b";
    }

    private String getTimeWithoutAmPmRegex() {
        return REGEX_PREPOSITION_ALL + "\\b " + REGEX_TIME_TWELVE + "\\b$";
    }

    private String correctUserInput(String inputString) {
        assert (inputString != null);
        boolean hasTimeRange = checkForRegexMatch(getTimeRangeRegex(), inputString);

        inputString = correctDateText(inputString);
        inputString = correctDateTextYear(inputString);
        inputString = correctDotTime(inputString);
        inputString = correctShorthand(inputString);

        if (hasTimeRange) {
            inputString = correctRangeTime(inputString);
        }

        inputString = removeExtraSpaces(inputString);
        return inputString;
    }

    /**
     * This method corrects date text in user input without spaces for date
     * parsing. Eg: 1apr -> 1 apr
     *
     * @param inputString
     *            {@code String} input to be corrected
     * @return {@code  String} with date text corrected
     */
    private String correctDateText(String inputString) {
        assert (inputString != null);
        String regex = REGEX_DATE_TEXT + REGEX_MONTH_TEXT;
        inputString = inputString.replaceAll(regex, "$1 $3");
        inputString = removeExtraSpaces(inputString);
        return inputString;
    }

    private String removeExtraSpaces(String inputString) {
        assert (inputString != null);
        return inputString.replaceAll("\\s+", " ").trim();
    }

    /**
     * This method corrects the date when the year is specified with only two
     * digits for parsing.
     *
     * @param inputString
     *            {@code String} containing date with year
     * @return {@code String} with corrected date year
     */
    private String correctDateTextYear(String inputString) {
        assert (inputString != null);
        String regex = getDateTextRegex() + "\\b ?(\\d\\d)(?:$|\\s)";
        inputString = inputString.replaceAll(regex, "$2 $4 $5 '$29 ");
        return inputString;
    }

    /**
     * This method corrects time separated with a dot for date parsing. Eg:
     * 5.30pm
     *
     * @param inputString
     *            {@code String} input to be corrected
     * @return {@code String} with time corrected
     */
    private String correctDotTime(String inputString) {
        assert (inputString != null);
        String regex = "\\b((1[012]|0?[1-9])(([:|.])([0-5][0-9])?))(?i)(am|pm)";
        inputString = inputString.replaceAll(regex, "$2:$5$6");
        return inputString;
    }

    /**
     * This method correct short forms used by the user for parsing.
     *
     * @param inputString
     *            {@code String} containing short forms
     * @return {@code String} with short forms corrected
     */
    private String correctShorthand(String inputString) {
        assert (inputString != null);
        String regex = "\\b(tmr|tml|tmrw)\\b";
        inputString = inputString.replaceAll(regex, "tomorrow");

        regex = "\\b(tdy)\\b";
        inputString = inputString.replaceAll(regex, "today");
        return inputString;
    }

    /**
     * This method corrects ranged time for date parsing.
     *
     * @param inputString
     *            {@code String} input to be corrected
     * @return {@code String} with time range corrected
     */
    private String correctRangeTime(String inputString) {
        assert (inputString != null);
        inputString = inputString.replaceAll("()-()", "$1 - $2");
        return inputString;
    }

    private String getPriorityString(String inputString) {
        assert (inputString != null);
        String regex = REGEX_PRIORITY;
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(inputString);
        boolean checkMatch = matcher.find();
        if (checkMatch) {
            return matcher.group();
        }
        return null;
    }

    private int getPriority(String inputString) {
        assert (inputString != null);
        String priority = inputString.substring(PRIORITY_LENGTH).trim();
        int level = assignLevel(priority);
        return level;
    }

    private int assignLevel(String priority) {
        assert (priority != null);
        priority = priority.toLowerCase();
        int level = 0;

        switch (priority) {
            case "l" :
                // Fallthrough
            case "low" :
                level = PRIORITY_LOW;
                break;

            case "m" :
                // Fallthrough
            case "mid" :
                // Fallthrough
            case "med" :
                // Fallthrough
            case "medium" :
                level = PRIORITY_MID;
                break;

            case "h" :
                // Fallthrough
            case "high" :
                level = PRIORITY_HIGH;
                break;

            default:
                break;
        }
        return level;
    }

    private String removeStringFromTitle(String title, String string) {
        assert (title != null && string != null);
        title = title.replace(string, "");
        title = removeExtraSpaces(title);
        return title;
    }

    /**
     * This method checks for indication of label through detection of '#'.
     *
     * @param inputString
     *            {@code String} input to be checked
     * @return {@code boolean} true if found
     */
    private boolean checkForLabel(String inputString) {
        assert (inputString != null);
        if (inputString.contains("#")) {
            return true;
        } else {
            return false;
        }
    }

    private String getLabel(String inputString) throws InvalidLabelFormat {
        assert (inputString != null);
        int index = inputString.indexOf("#");
        index = index + INDEX_OFFSET;
        String substring = inputString.substring(index);
        String label = substring.trim();
        label = getFirstWord(label);
        return label;
    }

    private String getFirstWord(String inputString) throws InvalidLabelFormat {
        assert (inputString != null);
        String word = "";
        try {
            word = inputString.split(" ")[0];
        } catch (Exception e) {
            logger.log(Level.WARNING, "Label cannot be parsed by parser.");
            logger.log(Level.WARNING, "InvalidLabelFormat exception thrown.");
            throw new InvalidLabelFormat("Invalid label input detected.");
        }

        if (word.length() == 0) {
            logger.log(Level.WARNING, "Label cannot be parsed by parser.");
            logger.log(Level.WARNING, "InvalidLabelFormat exception thrown.");
            throw new InvalidLabelFormat("Invalid label input detected.");
        }

        return word;
    }

    private boolean checkValidLabel(String inputString) {
        assert (inputString != null);
        if (inputString.contains("-")) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * This method corrects dd/mm into mm/dd for date parsing.
     *
     * @param inputString
     *            {@code String} input to be corrected
     * @return {@code String} with the date corrected
     */
    private String correctDateNumFormat(String inputString, boolean hasYear) {
        assert (inputString != null);
        boolean match = false;
        String swapped = "";

        // Preserve capitalization by not using toLowerCase
        List<String> words = new ArrayList<String>(Arrays.asList(inputString.split(" ")));

        for (int i = 0; i < words.size(); i++) {
            if (hasYear) {
                match = Pattern.matches(REGEX_DATE_NUM_YEAR, words.get(i));
            } else {
                match = Pattern.matches(REGEX_DATE_NUM, words.get(i));
            }

            if (match) {
                if (words.get(i).contains("/")) {
                    List<String> date = new ArrayList<String>(Arrays.asList(words.get(i).split("/")));
                    swapped = date.get(1).concat("/").concat(date.get(0));
                    if (date.size() == DATE_FIELD_FULL) {
                        swapped = swapped.concat("/").concat(date.get(2));
                    }
                } else if (words.get(i).contains("-")) {
                    List<String> date = new ArrayList<String>(Arrays.asList(words.get(i).split("-")));
                    swapped = date.get(1).concat("-").concat(date.get(0));
                    if (date.size() == DATE_FIELD_FULL) {
                        swapped = swapped.concat("-").concat(date.get(2));
                    }
                }
                words.set(i, swapped);
            }
        }

        return String.join(" ", words);
    }

    /**
     * This method uses PrettyTimeParser to generate dates from {@code String}
     * inputString.
     *
     * @param inputString
     *            {@code String} input to be parsed
     * @return {@code List<Date>} of dates generated if possible
     */
    private List<Date> parseDateTime(String inputString) {
        assert (inputString != null);
        PrettyTimeParser parser = new PrettyTimeParser(TimeZone.getDefault());
        List<Date> dates = parser.parse(inputString);
        return dates;
    }

    /**
     * This method parses the date only. Since time is not specified, it is set
     * to 12am.
     *
     * @param inputString
     *            {@code String} input to be parsed
     * @return {@code List<Date>} of dates
     */
    private List<Date> parseDateOnly(String inputString) {
        assert (inputString != null);
        List<Date> dates = parseDateTime(inputString);
        int size = dates.size();
        for (int i = 0; i < size; i++) {
            dates.add(setTimeToZero(dates.get(i)));
        }

        if (size != 0) {
            dates.remove(0);
        }

        if (size == DATE_MAX_SIZE) {
            dates.remove(0);
        }

        return dates;
    }

    private Date setTimeToZero(Date date) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        return cal.getTime();
    }

    private List<Date> parseDayOnly(String inputString) {
        assert (inputString != null);
        List<Date> dates = parseDateOnly(inputString);
        dates = fixDayRange(dates);
        return dates;
    }

    /**
     * This method ensures that range are sequential. Corrects date parsed by
     * PrettyTime. The end will come after the start.
     *
     * @param dates
     *            {@code List<Date>>} to be corrected
     * @return {@code List<Date>} corrected dates
     */
    private List<Date> fixDayRange(List<Date> dates) {
        if (dates.size() == DATE_MAX_SIZE) {
            Date start = dates.get(DATE_START);
            Date end = dates.get(DATE_END);

            if (start.after(end)) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(end);
                cal.add(Calendar.WEEK_OF_YEAR, 1);
                dates.set(DATE_END, cal.getTime());
            }
        }
        return dates;
    }

    private List<Date> parseTimeOnly(String inputString) {
        assert (inputString != null);
        List<Date> dates = parseDateTime(inputString);
        dates = fixTimeToNearest(dates, false);
        dates = fixTimeForRange(dates);
        return dates;
    }

    /**
     * This method sets the time if it has past and if no date is specified. It
     * will always take the next nearest time.
     *
     * Eg: If now is 1pm, and if either 12am or 12pm is specified, it will be
     * 12am or 12pm of the next day.
     *
     * @param dates
     *            {@code List<Date>} dates to be parsed
     * @param hasDate
     *            {@code boolean} indicating if date is specified
     * @return {@code List<Date>} of dates
     */
    private List<Date> fixTimeToNearest(List<Date> dates, boolean hasDate) {
        Date now = new Date();
        Calendar currentDate = Calendar.getInstance();
        currentDate.setTime(now);

        Calendar date = Calendar.getInstance();
        if (!hasDate) {
            for (int i = 0; i < dates.size(); i++) {
                if (dates.get(i).before(now)) {
                    // date has past, get the next nearest
                    date.setTime(dates.get(i));
                    date.add(Calendar.DATE, 1);
                    dates.set(i, date.getTime());
                }

                if (dates.size() == 2) {
                    // update to start
                    now = dates.get(i);
                }
            }
        }
        return dates;
    }

    /**
     * This method ensures that range are sequential. Corrects date parsed by
     * PrettyTime. The end will come after the start.
     *
     * Eg: If now is 11pm, 10pm - 2am will be today 10pm to the next day 2am.
     *
     * @param dates
     *            {@code List<Date>} to be corrected
     * @return {@code List<Date>} corrected dates
     */
    private List<Date> fixTimeForRange(List<Date> dates) {
        if (dates.size() == DATE_MAX_SIZE) {
            Date start = dates.get(DATE_START);
            Date end = dates.get(DATE_END);

            if (end.before(start)) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(end);
                cal.add(Calendar.DAY_OF_MONTH, 1);
                dates.set(DATE_END, cal.getTime());
            }
        }
        return dates;
    }

    /**
     * This method corrects the next week that is parsed by PrettyTime. When
     * next week is specified in the user input, it will always be corrected to
     * the Monday of next week. The week starts on Monday.
     *
     * @param dates
     *            {@code List<Date>} to be corrected
     * @return {@code List<Date>} corrected to Monday of next week
     */
    private List<Date> correctNextWeek(List<Date> dates) {
        Calendar cal = Calendar.getInstance();
        cal.setFirstDayOfWeek(Calendar.MONDAY);

        if (dates.size() == 0) {
            // if there is no date parsed by PrettyTime, set to next Monday
            cal.setTime(new Date());
            int week = cal.get(Calendar.WEEK_OF_YEAR) + 1;
            cal.set(Calendar.WEEK_OF_YEAR, week);
            cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
            cal.setTime(setTimeToZero(cal.getTime()));
            dates.add(cal.getTime());
        } else {
            // correct to next Monday for range time
            for (int i = 0; i < dates.size(); i++) {
                cal.setTime(dates.get(i));
                cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
                dates.set(i, cal.getTime());
            }
        }
        return dates;
    }

    private String getNextWeekRegex() {
        return "\\b" + STRING_NEXT_WEEK + "\\b";
    }

    /**
     * This method sets the time for time specified without am/pm due to the
     * presence of preposition. It will take the next possible time since am/pm
     * is not specified.
     *
     * Eg: If now is 1pm, and 10 is specified, it will be parsed as 10pm today.
     *
     * If now is 10pm, and 1 is specified, it will be parsed as 1am tomorrow.
     *
     * @param dates
     *            {@code List<Date>} dates to be parsed
     * @param hasDate
     *            {@code boolean} indicating if date is specified
     * @return {@code List<Date>} of dates
     */
    private List<Date> fixTimeForWithoutAmPm(List<Date> dates) {
        Date now = new Date();
        Calendar currentDate = Calendar.getInstance();
        currentDate.setTime(now);

        Calendar date = Calendar.getInstance();

        for (int i = 0; i < dates.size(); i++) {
            if (dates.get(i).before(now)) {
                // time has past, need to check next nearest
                date.setTime(dates.get(i));
                date.add(Calendar.HOUR_OF_DAY, 12);

                // if time is after current, still within the day
                if (date.after(currentDate)) {
                    dates.set(i, date.getTime());
                } else {
                    // time is before current, time has past
                    // plus 12 hours to get to next nearest
                    date.add(Calendar.HOUR_OF_DAY, 12);
                    dates.set(i, date.getTime());
                }
            }

            if (dates.size() == 2) {
                // if time is ranged, check against the fixed start date
                now = dates.get(i);
            }
        }
        return dates;
    }

    /**
     * This method determines the start and end date for a task.
     *
     * @param dates
     *            {@code List<Date} dates obtained from parsing
     * @param hasPreposition
     *            {@code boolean} indicate if preposition is detected
     * @param hasStartDate
     *            {@code boolean} indicate if start date is detected through
     *            detection of preposition
     * @return {@code List<Date>} of determined dates
     */
    private List<Date> assignDates(List<Date> dates, boolean hasPreposition, boolean hasStartDate) {
        List<Date> assigned = new ArrayList<Date>();
        int numberOfDate = dates.size();

        if (numberOfDate == DATE_MAX_SIZE) {
            assigned.add(DATE_START, getDate(dates, DATE_START));
            assigned.add(DATE_END, getDate(dates, DATE_END));
        } else {
            if (hasPreposition) {
                if (hasStartDate) {
                    assigned.add(DATE_START, getDate(dates, DATE_INDEX));
                    assigned.add(DATE_END, null);
                } else {
                    assigned.add(DATE_START, null);
                    assigned.add(DATE_END, getDate(dates, DATE_INDEX));
                }
            } else {
                // no preposition
                // one date/time only
                // assume start
                assigned.add(DATE_START, getDate(dates, DATE_INDEX));
                assigned.add(DATE_END, null);
            }
        }
        return assigned;
    }

    private Date getDate(List<Date> dates, int index) {
        return dates.get(index);
    }

    private String getDateRegexTextWithYear() {
        return REGEX_PREPOSITION_ALL + "?" + REGEX_DATE_TEXT + REGEX_MONTH_TEXT + REGEX_YEAR;
    }

    /**
     * This method removes date information from the {@code String} taken in.
     *
     * @param title
     *            {@code String} containing date information
     * @param startDate
     *            {@code Date} start date
     * @param endDate
     *            {@code Date} end date
     * @return {@code String} without date information
     */
    private String removeDateFromTitle(String title, List<Date> datesList) {
        assert (title != null);
        LocalDateTime dateTime;

        Date startDate = datesList.get(DATE_START);
        Date endDate = datesList.get(DATE_END);

        if (startDate != null) {
            dateTime = startDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        } else {
            dateTime = endDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        }

        for (int i = 0; i < DATE_MAX_SIZE; i++) {
            ArrayList<String> dates = getPossibleDates(dateTime);
            ArrayList<String> months = getPossibleMonths(dateTime);
            ArrayList<String> days = getPossibleDays(dateTime);
            ArrayList<String> timings = getPossibleTimes(dateTime);

            title = checkAndRemove(title, dates);
            title = checkAndRemove(title, months);
            title = checkAndRemove(title, days);
            title = checkAndRemove(title, timings);

            if (startDate != null && endDate != null) {
                dateTime = endDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
            } else {
                break;
            }
        }
        return title;
    }

    /**
     * This method generates an {@code ArrayList<String} of possible date
     * formats from {@code LocalDateTime}.
     *
     * @param dateTime
     *            {@code LocalDateTime} to generate different date formats
     * @return {@code ArrayList<String} of possible date formats
     */
    private ArrayList<String> getPossibleDates(LocalDateTime dateTime) {
        ArrayList<String> dates = new ArrayList<String>();
        String date = Integer.toString(dateTime.getDayOfMonth());
        dates.add(date);
        dates.add(date.concat("st"));
        dates.add(date.concat("nd"));
        dates.add(date.concat("rd"));
        dates.add(date.concat("th"));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("d/M")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("d/MM")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd/M")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd/MM")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("d-M")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("d-MM")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd-M")));
        dates.add(dateTime.format(DateTimeFormatter.ofPattern("dd-MM")));
        return dates;
    }

    /**
     * This method generates an {@code ArrayList<String} of possible month
     * formats from {@code LocalDateTime}.
     *
     * @param dateTime
     *            {@code LocalDateTime} to generate different month formats
     * @return {@code ArrayList<String} of possible month formats
     */
    private ArrayList<String> getPossibleMonths(LocalDateTime dateTime) {
        Locale locale = Locale.getDefault();
        ArrayList<String> months = new ArrayList<String>();
        Month month = dateTime.getMonth();
        months.add(month.toString().toLowerCase());
        months.add(month.getDisplayName(TextStyle.SHORT, locale).toLowerCase());
        return months;
    }

    /**
     * This method generates an {@code ArrayList<String} of possible day formats
     * from {@code LocalDateTime}.
     *
     * @param dateTime
     *            {@code LocalDateTime} to generate different day formats
     * @return {@code ArrayList<String} of possible day formats
     */
    private ArrayList<String> getPossibleDays(LocalDateTime dateTime) {
        Locale locale = Locale.getDefault();
        DayOfWeek day = dateTime.getDayOfWeek();
        ArrayList<String> days = new ArrayList<String>();
        days.add(day.toString().toLowerCase());
        days.add(day.getDisplayName(TextStyle.SHORT, locale).toLowerCase());
        days = getDaysShorthand(days, day.toString().toLowerCase());

        int date = dateTime.getDayOfMonth();
        int month = dateTime.getMonthValue();
        LocalDateTime today = LocalDateTime.now();
        if (month == today.getMonthValue()) {
            if (date == today.getDayOfMonth()) {
                days.add("today");
                days.add("tdy");
                days.add("tonight");
            } else if (date == (today.getDayOfMonth() + 1)) {
                days.add("tomorrow");
                days.add("tmr");
                days.add("tml");
                days.add("tmrw");
            }
        }
        return days;
    }

    private ArrayList<String> getDaysShorthand(ArrayList<String> days, String day) {
        switch (day) {
            case "tuesday" :
                days.add("tues");
                break;

            case "wednesday" :
                days.add("weds");
                break;

            case "thursday" :
                days.add("thur");
                days.add("thurs");
                break;

            default:
                break;
        }
        return days;
    }

    /**
     * This method generates an {@code ArrayList<String} of possible time
     * formats from {@code LocalDateTime}.
     *
     * @param dateTime
     *            {@code LocalDateTime} to generate different time formats
     * @return {@code ArrayList<String} of possible time formats
     */
    private ArrayList<String> getPossibleTimes(LocalDateTime dateTime) {
        ArrayList<String> timings = new ArrayList<String>();
        int hour = dateTime.getHour();
        int min = dateTime.getMinute();

        assert (hour >= 0);
        assert (min >= 0);

        String colon = ":";
        String dot = ".";
        if (min < DOUBLE_DIGIT) {
            colon = colon.concat("0");
            dot = dot.concat("0");
        }

        colon = colon.concat(Integer.toString(dateTime.getMinute()));
        dot = dot.concat(Integer.toString(dateTime.getMinute()));

        timings.add(Integer.toString(hour));
        timings.add(Integer.toString(hour).concat(colon));
        timings.add(Integer.toString(hour).concat(dot));
        if (hour < 12) {
            if (hour == 0) {
                String temp = STRING_TWELVE;
                timings.add(temp.concat(STRING_AM));
                timings.add(temp.concat(colon));
                timings.add(temp.concat(dot));
                timings.add(temp.concat(colon).concat(STRING_AM));
                timings.add(temp.concat(dot).concat(STRING_AM));
            } else {
                timings.add(Integer.toString(hour).concat(STRING_AM));
                timings.add(Integer.toString(hour).concat(colon));
                timings.add(Integer.toString(hour).concat(dot));
                timings.add(Integer.toString(hour).concat(colon).concat(STRING_AM));
                timings.add(Integer.toString(hour).concat(dot).concat(STRING_AM));
            }
        } else if (hour >= 12) {
            hour = hour - 12;
            if (hour == 0) {
                String temp = STRING_TWELVE;
                timings.add(temp.concat(STRING_PM));
                timings.add(temp.concat(colon));
                timings.add(temp.concat(dot));
                timings.add(temp.concat(colon).concat(STRING_PM));
                timings.add(temp.concat(dot).concat(STRING_PM));
            } else {
                timings.add(Integer.toString(hour));
                timings.add(Integer.toString(hour).concat(STRING_PM));
                timings.add(Integer.toString(hour).concat(colon));
                timings.add(Integer.toString(hour).concat(dot));
                timings.add(Integer.toString(hour).concat(colon).concat(STRING_PM));
                timings.add(Integer.toString(hour).concat(dot).concat(STRING_PM));
            }
        }
        return timings;
    }

    /**
     * This method checks for and removes {@code ArrayList<String>} of targeted
     * word from {@code String}.
     *
     * If word to be removed is found, it checks if the word before it is a
     * preposition. If preposition found, both are removed. Else, only the
     * matching word is removed.
     *
     * @param title
     *            {@code String} to be checked
     * @param toBeRemoved
     *            {@code ArrayList<String>} of words to be removed
     * @return {@code String} with targeted words removed
     */
    private String checkAndRemove(String title, ArrayList<String> toBeRemoved) {
        assert (title != null);
        int index = 0;
        boolean isPreposition = false;

        for (int i = 0; i < toBeRemoved.size(); i++) {
            String toBeReplaced = "";
            List<String> words = new ArrayList<String>(Arrays.asList(title.toLowerCase().split(" ")));

            if (words.contains(toBeRemoved.get(i))) {
                toBeReplaced = toBeReplaced.concat(toBeRemoved.get(i));

                index = words.indexOf(toBeRemoved.get(i));
                String word = "";
                if (index != 0) {
                    index = index - INDEX_OFFSET;
                    word = getWord(title, index);
                }

                if (word.equals("this") || word.equals("next")) {
                    toBeReplaced = word.concat(" ").concat(toBeReplaced);
                    if (index != 0) {
                        index = index - INDEX_OFFSET;
                        word = getWord(title, index);
                    }
                }

                isPreposition = checkForRegexMatch(REGEX_PREPOSITION_ALL, word);
                if (isPreposition) {
                    toBeReplaced = word.concat(" ").concat(toBeReplaced);
                }
            }

            toBeReplaced = "(?i)".concat(toBeReplaced);
            title = title.replaceAll(toBeReplaced, "");
        }
        title = removeExtraSpaces(title);
        return title;
    }

    /**
     * This method gets a word from {@code String} string base on {@code int}
     * index.
     *
     * @param title
     *            {@code String} input to obtain word from
     * @param index
     *            {@code int} index of word to be obtained
     * @return {@code String} word obtained
     */
    private String getWord(String title, int index) {
        assert (title != null);
        List<String> words = new ArrayList<String>(Arrays.asList(title.toLowerCase().split(" ")));
        String word = words.get(index);
        return word;
    }

    // =============================
    // Edit's stuff
    // =============================

    /**
     * This method parses {@code String} for date.
     *
     * @param inputString
     *            {@code String} input to be parsed
     * @return {@code Date} if date found, {@code null} if date is not found
     */
    public Date getDateForSearch(String inputString) {
        assert (inputString != null);
        if (isSpecialCase(inputString)) {
            return null;
        }

        inputString = correctShorthand(inputString);
        List<Date> dates = parseDateTime(inputString);

        if (dates.size() == 0) {
            return null;
        } else {
            if (inputString.length() == 1) {
                dates = setDate(dates, inputString);
            }
            return dates.get(DATE_INDEX);
        }
    }

    /**
     * This method escapes date parsing if it is a special string.
     *
     * @param inputString
     *            {@code String} input string
     * @return {@code boolean} true if special case detected
     */
    private boolean isSpecialCase(String inputString) {
        assert (inputString != null);
        if (inputString.equalsIgnoreCase("this week") || inputString.equalsIgnoreCase("next week")) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * This method uses the {@code String} to replace the date in
     * {@code List<Date}
     *
     * @param dates
     *            {@code List<Date>} date to be replaced
     * @param inputString
     *            {@code String} containing the date
     * @return {@code List<Date>} of corrected date.
     */
    private List<Date> setDate(List<Date> dates, String inputString) {
        assert (inputString != null);
        int date = Integer.parseInt(inputString);
        Calendar cal = Calendar.getInstance();
        cal.setTime(dates.get(DATE_INDEX));
        cal.set(Calendar.DATE, date);
        dates.add(DATE_INDEX, cal.getTime());
        return dates;
    }

    /**
     * This method detects if index is present in edit command.
     *
     * @param inputString
     *            {@code String} input for index to be obtained
     * @return {@code int} index if found, {@code int} -1 if index is not found
     */
    public int getIndexForEdit(String inputString) {
        assert (inputString != null);
        ArrayList<String> index = new ArrayList<String>();
        inputString = removeDateTime(inputString);

        Collections.addAll(index, inputString.split(" "));

        if (index.size() == 1) {
            return -1;
        } else {
            try {
                return (Integer.parseInt(index.get(1)));
            } catch (Exception e) {
                return -1;
            }
        }
    }

    /**
     * This method removes date and time information from {@code String}.
     *
     * @param inputString
     *            {@code String} input for information to be removed
     * @return {@code String} without date and time information
     */
    private String removeDateTime(String inputString) {
        assert (inputString != null);
        boolean hasTime = false;
        boolean hasTimeRange = false;
        boolean hasDate = false;
        String regex = "";

        hasTime = checkForRegexMatch(getTimeRegex(), inputString);

        if (hasTime) {
            hasTimeRange = checkForRegexMatch(getTimeRangeRegex(), inputString);

            if (hasTimeRange) {
                regex = "(" + REGEX_PREPOSITION_ALL + "?)(" + getTimeRangeRegex() + ")";
                inputString = removeRegex(regex, inputString);
            }

            regex = getTimeRegex();
            inputString = removeRegex(regex, inputString);
        }

        hasDate = checkForRegexMatch(getDateRegex(), inputString);
        if (hasDate) {
            regex = getDateRegex();
            inputString = removeRegex(regex, inputString);
            hasDate = false;
        }

        hasDate = checkForRegexMatch(getDateTextRegex(), inputString);
        if (hasDate) {
            regex = getDateTextRegex();
            inputString = removeRegex(regex, inputString);
        }

        return inputString;
    }

    /**
     * This method takes in {@code String} regex and removes if from
     * {@code String} input.
     *
     * @param regex
     *            {@code String} expressions to be removed
     * @param inputString
     *            {@code String} input for expression to be removed
     * @return {@code String} without expression
     */
    private String removeRegex(String regex, String inputString) {
        assert (regex != null && inputString != null);
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(inputString);

        while (matcher.find()) {
            String match = matcher.group();
            inputString = inputString.replaceAll(match, "");
        }

        inputString = removeExtraSpaces(inputString);
        return inputString;
    }

    /**
     * This method allows for editing of existing tasks.
     *
     * @param oldTask
     *            {@code Task} to be edited
     * @param inputString
     *            {@code String} of new information
     * @return {@code Task} edited task
     * @throws InvalidLabelFormat
     */
    public Task parseEdit(Task oldTask, String inputString) throws InvalidLabelFormat {
        assert (inputString != null);
        logger.log(Level.INFO, "Parsing for EDIT command.");

        String newTitle = oldTask.getTitle();
        String newLabel = oldTask.getLabel();
        Date newStart = oldTask.getStartDate();
        Date newEnd = oldTask.getEndDate();
        Date createdDate = oldTask.getCreatedDate();
        int priority = oldTask.getPriority();
        boolean isDatedOnly = oldTask.getIsDatedOnly();

        Task editedTask = parseAdd(inputString);

        if (editedTask.getTitle().length() != 0 && !editedTask.getTitle().equals("<No title>")) {
            newTitle = editedTask.getTitle();
        }

        if (editedTask.getLabel() != null) {
            newLabel = editedTask.getLabel();
        }

        boolean hasPriority = checkForRegexMatch(REGEX_PRIORITY, inputString);
        if (hasPriority) {
            priority = editedTask.getPriority();
        }

        boolean hasTime = false;
        boolean hasDate = false;
        boolean hasPreposition = false;
        boolean hasTimeWithoutAmPm = false;
        List<Date> dates = new ArrayList<Date>();

        hasDate = checkForRegexMatch(getDateRegex(), inputString)
                || checkForRegexMatch(getDateTextRegex(), inputString);
        hasTime = checkForRegexMatch(getTimeRegex(), inputString) || checkForRegexMatch(REGEX_WORD_TIMED, inputString);

        if (!hasTime) {
            hasPreposition = checkForRegexMatch(REGEX_PREPOSITION_ALL, inputString);
            if (hasPreposition) {
                hasTimeWithoutAmPm = checkForRegexMatch(getTimeWithoutAmPmRegex(), inputString);
                if (hasTimeWithoutAmPm) {
                    hasTime = true;
                }
            }
        }

        // check for word indicating date
        if (checkForRegexMatch(REGEX_WORD_DATED, inputString)) {
            hasDate = true;
        }

        if (editedTask.hasDate()) {
            if (hasDate && !hasTime) {
                // only date
                dates.add(editedTask.getStartDate());
                dates.add(editedTask.getEndDate());
                isDatedOnly = true;
            } else if (!hasDate && hasTime) {
                // only time, reuse date
                dates = reuseDate(editedTask, oldTask);
                isDatedOnly = false;
            } else {
                // have both
                // update by overwriting
                dates.add(editedTask.getStartDate());
                dates.add(editedTask.getEndDate());
                isDatedOnly = false;
            }

            newStart = dates.get(DATE_START);
            newEnd = dates.get(DATE_END);
        }

        Task newTask = new Task(newTitle, newStart, newEnd, newLabel);
        newTask.setCreatedDate(createdDate);
        newTask.setPriority(priority);
        newTask.setIsDatedOnly(isDatedOnly);
        logger.log(Level.INFO, "Edited task object returned.");
        return newTask;
    }

    /**
     * This method duplicates the date information in {@code Task} oldTask to
     * {@code Task} editedTask.
     *
     * @param editedTask
     *            {@code Task} edited task that needs the old date information
     * @param oldTask
     *            {@code Task} with the old date information
     * @return {@code List<Date>} of updated dates
     */
    private List<Date> reuseDate(Task editedTask, Task oldTask) {
        List<Date> dates = new ArrayList<Date>();
        Calendar reuse = Calendar.getInstance();
        Calendar latest = Calendar.getInstance();

        Date startDate = editedTask.getStartDate();
        Date endDate = editedTask.getEndDate();
        Date oldStart = oldTask.getStartDate();
        Date oldEnd = oldTask.getEndDate();

        if (startDate != null) {
            if (oldStart != null) {
                reuse.setTime(oldStart);
            } else if (oldEnd != null) {
                reuse.setTime(oldEnd);
            }

            latest = setDayMonthYear(reuse, latest, startDate);
            oldStart = latest.getTime();
        }

        if (endDate != null) {
            if (oldEnd != null) {
                reuse.setTime(oldEnd);
            } else if (oldStart != null) {
                reuse.setTime(oldStart);
            }

            latest = setDayMonthYear(reuse, latest, endDate);
            oldEnd = latest.getTime();
        }

        if (!oldTask.hasDate()) {
            // floating task
            oldStart = startDate;
            oldEnd = endDate;
        }

        if (startDate == null) {
            oldStart = null;
        }

        if (endDate == null) {
            oldEnd = null;
        }

        dates.add(oldStart);
        dates.add(oldEnd);
        return dates;
    }

    /**
     * This method gets the day and month from {@code Calendar} reuse and sets
     * it in {@code Calendar} latest.
     *
     * @param reuse
     *            {@code Calendar} for day and month to be obtained
     * @param latest
     *            {@code Calendar} for day and month to be set
     * @param date
     *            {@code Date} date to be set for {@code Calendar} latest
     * @return {@code Calendar} with updated day and month
     */
    private Calendar setDayMonthYear(Calendar reuse, Calendar latest, Date date) {
        int day = reuse.get(Calendar.DAY_OF_MONTH);
        int month = reuse.get(Calendar.MONTH);
        int year = reuse.get(Calendar.YEAR);

        latest.setTime(date);
        latest.set(Calendar.DAY_OF_MONTH, day);
        latest.set(Calendar.MONTH, month);
        latest.set(Calendar.YEAR, year);

        return latest;
    }

    // =============================
    // Parsing Indexes
    // =============================

    /**
     * This method detects the types of indexes and processes them.
     *
     * @param inputString
     *            {@code String} input to be processed
     * @return {@code ArrayList<Integer>} of index(es)
     * @throws InvalidTaskIndexFormat
     *             if format is invalid
     */
    public ParseIndexResult parseIndexes(String inputString, int maxSize) throws InvalidTaskIndexFormat {
        assert (maxSize > 0);
        logger.log(Level.INFO, "Parsing indexes.");

        try {
            String indexString = getStringWithoutCommand(inputString);
            indexString = removeWhiteSpace(indexString);
            ArrayList<Integer> indexes = new ArrayList<Integer>();
            indexes = getIndex(indexString);
            ParseIndexResult indexResult = validateIndexes(indexes, maxSize);
            logger.log(Level.INFO, "Indexes retrieved.");
            return indexResult;
        } catch (Exception e) {
            logger.log(Level.WARNING, "NumberFormatException: Indexes cannot be parsed by parser.");
            logger.log(Level.WARNING, "InvalidTaskIndexFormat exception thrown.");
            throw new InvalidTaskIndexFormat("Invalid indexes input detected.");
        }
    }

    private String getStringWithoutCommand(String commandString) throws InvalidLabelFormat {
        int index = 0;
        String command = getFirstWord(commandString);
        index = command.length() + LENGTH_OFFSET;
        String indexString = commandString.substring(index, commandString.length());
        assert (!indexString.isEmpty());
        return indexString;
    }

    private String removeWhiteSpace(String string) {
        string = string.replaceAll("\\s", "");
        assert (!string.isEmpty());
        return string;
    }

    /**
     * This method obtains all numbers based on {@code String} taken in.
     *
     * @param index
     *            {@code String} to be processed
     * @return {@code ArrayList<Integer>} of index(es)
     * @throws InvalidTaskIndexFormat
     */
    private ArrayList<Integer> getIndex(String index) throws InvalidTaskIndexFormat {
        assert (index != null);
        ArrayList<String> indexes = new ArrayList<String>();
        ArrayList<String> tempRangedIndexes = new ArrayList<String>();
        ArrayList<Integer> multipleIndexes = new ArrayList<Integer>();
        ArrayList<Integer> rangedIndexes = new ArrayList<Integer>();

        Collections.addAll(indexes, index.split(","));

        for (int i = 0; i < indexes.size(); i++) {
            if (indexes.get(i).contains("-")) {
                Collections.addAll(tempRangedIndexes, indexes.get(i).split("-"));

                // remove all empty after splitting
                // else will cause parseInt to fail
                tempRangedIndexes = removeEmpty(tempRangedIndexes);
                rangedIndexes = getRangedIndexes(tempRangedIndexes);

                if (rangedIndexes.size() == 1) {
                    logger.log(Level.WARNING, "NumberFormatException: Indexes cannot be parsed by parser.");
                    logger.log(Level.WARNING, "InvalidTaskIndexFormat exception thrown.");
                    throw new InvalidTaskIndexFormat("Invalid indexes input detected.");
                }

                multipleIndexes.addAll(getMultipleIndexes(rangedIndexes));

                tempRangedIndexes.clear();
                rangedIndexes.clear();
            } else {
                int indexToAdd = Integer.parseInt(indexes.get(i));
                if (!multipleIndexes.contains(indexToAdd)) {
                    multipleIndexes.add(indexToAdd);
                }
            }
        }

        return multipleIndexes;
    }

    private ArrayList<String> removeEmpty(ArrayList<String> arrayStrings) {
        assert (arrayStrings != null);
        ArrayList<String> empty = new ArrayList<String>();
        empty.add("");
        arrayStrings.removeAll(empty);
        return arrayStrings;
    }

    /**
     * This method gets the range of indexes.
     *
     * @param arrayStrings
     *            {@code ArrayList<String>} to be processed
     * @return {@code ArrayList<Integer>} of index(es) range
     */
    private ArrayList<Integer> getRangedIndexes(ArrayList<String> arrayStrings) {
        assert (arrayStrings != null);
        ArrayList<Integer> ranged = new ArrayList<Integer>();

        for (int i = 0; i < arrayStrings.size(); i++) {
            ranged.add(Integer.parseInt(arrayStrings.get(i)));
        }

        return ranged;
    }

    /**
     * This method gets multiple indexes.
     *
     * @param arrayIntegers
     *            {@code ArrayList<Integer>} to be processed
     * @return {@code ArrayList<Integer>} of indexes
     */
    private ArrayList<Integer> getMultipleIndexes(ArrayList<Integer> arrayIntegers) {
        assert (arrayIntegers != null);
        ArrayList<Integer> multiple = new ArrayList<Integer>();
        int start, end;
        int possibleRange = arrayIntegers.size() - 1;

        for (int i = 0; i < possibleRange; i++) {
            start = arrayIntegers.get(i);
            end = arrayIntegers.get(i + 1);
            if (start < end) {
                for (int j = start; j <= end; j++) {
                    if (!multiple.contains(j)) {
                        multiple.add(j);
                    }
                }
            } else {
                for (int j = start; j >= end; j--) {
                    if (!multiple.contains(j)) {
                        multiple.add(j);
                    }
                }
            }
        }

        return multiple;
    }

    private ParseIndexResult validateIndexes(ArrayList<Integer> indexes, int maxSize) {
        assert (indexes != null);
        ArrayList<Integer> validIndexes = new ArrayList<Integer>();
        ArrayList<Integer> invalidIndexes = new ArrayList<Integer>();

        for (int i = 0; i < indexes.size(); i++) {
            int index = indexes.get(i);
            if (index > maxSize) {
                invalidIndexes.add(index);
            } else {
                validIndexes.add(index);
            }
        }

        ParseIndexResult indexesResult = new ParseIndexResult();
        if (invalidIndexes.size() > 0) {
            indexesResult.setHasInvalid(true);
            indexesResult.setInvalidIndexes(invalidIndexes);
        }

        if (validIndexes.size() > 0) {
            indexesResult.setHasValid(true);
            indexesResult.setValidIndexes(validIndexes);
        }

        return indexesResult;
    }
}
```
###### /src/main/parser/exceptions/InvalidLabelFormat.java
``` java

package main.parser.exceptions;

/**
 * This exception is thrown when there is nothing after a #.
 * Nothing can be extracted by the method getFirstWord() in CommandParser.
 */
@SuppressWarnings("serial")
public class InvalidLabelFormat extends Exception {
    public InvalidLabelFormat(String message) {
        super(message);
    }
}
```
###### /src/main/parser/exceptions/InvalidTaskIndexFormat.java
``` java

package main.parser.exceptions;

/**
 * This exception is thrown when a task's index cannot be parsed.
 * This means that it is in a wrong format.
 */
@SuppressWarnings("serial")
public class InvalidTaskIndexFormat extends Exception {
    public InvalidTaskIndexFormat(String message) {
        super(message);
    }
}
```
###### /src/test/TestCommandParser.java
``` java
package test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;

import org.junit.Test;

import main.data.ParseIndexResult;
import main.data.Task;
import main.parser.CommandParser;
import main.parser.exceptions.*;

public class TestCommandParser {
    /**
     * Test detection of time in user input
     * Method checkForTime has been updated to private.
     * This is for reference only.
     */
    /*
     * public void testCheckTime() {
     * CommandParser parser = new CommandParser();
     *
     * assertEquals(true, parser.checkForTime("1am"));
     * assertEquals(true, parser.checkForTime("2PM"));
     * assertEquals(true, parser.checkForTime("12:50pm"));
     *
     * assertEquals(false, parser.checkForTime("13am"));
     * assertEquals(false, parser.checkForTime("112pm"));
     * assertEquals(false, parser.checkForTime("12:60pm"));
     * assertEquals(false, parser.checkForTime("12:592pm"));
     * }
     */

    /**
     * Test detection of ranged time in user input.
     * Method checkForRangeTime has been updated to private.
     * This is for reference only.
     * See testTaskWithTimeRange() for valid testing.
     */
    /*
     * public void testCheckRange() {
     * CommandParser parser = new CommandParser();
     *
     * assertEquals(true, parser.checkForRangeTime("1am-4"));
     * assertEquals(true, parser.checkForRangeTime("1-4am"));
     * assertEquals(true, parser.checkForRangeTime("1am-4am"));
     *
     * assertEquals(true, parser.checkForRangeTime("10am-11"));
     * assertEquals(true, parser.checkForRangeTime("10-11am"));
     * assertEquals(true, parser.checkForRangeTime("10am-11am"));
     *
     * assertEquals(true, parser.checkForRangeTime("1:30am-4:30"));
     * assertEquals(true, parser.checkForRangeTime("1:30-4:30am"));
     * assertEquals(true, parser.checkForRangeTime("1:30am-4:30am"));
     *
     * assertEquals(true, parser.checkForRangeTime("10:30am-11:30"));
     * assertEquals(true, parser.checkForRangeTime("10:30-11:30am"));
     * assertEquals(true, parser.checkForRangeTime("10:30am-11:30am"));
     *
     * assertEquals(false, parser.checkForRangeTime("1-4"));
     *
     * assertEquals(false, parser.checkForRangeTime("1am-41"));
     * assertEquals(false, parser.checkForRangeTime("1-41am"));
     * assertEquals(false, parser.checkForRangeTime("1am-41am"));
     *
     * assertEquals(false, parser.checkForRangeTime("41am-1"));
     * assertEquals(false, parser.checkForRangeTime("41-1am"));
     * assertEquals(false, parser.checkForRangeTime("41am-1am"));
     *
     * assertEquals(false, parser.checkForRangeTime("1:60m-4:60"));
     * assertEquals(false, parser.checkForRangeTime("1:60-4:60am"));
     * assertEquals(false, parser.checkForRangeTime("1:60am-4:60am"));
     *
     * assertEquals(false, parser.checkForRangeTime("10:60am-11:60"));
     * assertEquals(false, parser.checkForRangeTime("10:60-11:60am"));
     * assertEquals(false, parser.checkForRangeTime("10:60am-11:60am"));
     * }
     */

    /**
     * Test detection of date in number format in user input.
     * Method checkForDate has been updated to private.
     * This is for reference only.
     */
    /*
     * public void testCheckDate() {
     * CommandParser parser = new CommandParser();
     *
     * assertEquals(true, parser.checkForDate("1/5"));
     * assertEquals(true, parser.checkForDate("1/12"));
     * assertEquals(true, parser.checkForDate("30-5"));
     * assertEquals(true, parser.checkForDate("31-5"));
     *
     * assertEquals(true, parser.checkForDate("from 1/5"));
     * assertEquals(true, parser.checkForDate("after 1/12"));
     * assertEquals(true, parser.checkForDate("at 30-5"));
     * assertEquals(true, parser.checkForDate("on 31-5"));
     *
     * assertEquals(false, parser.checkForDate("1/13"));
     * assertEquals(false, parser.checkForDate("33/5"));
     * assertEquals(false, parser.checkForDate("33/50"));
     * }
     */

    /**
     * Test detection of date in text format in user input.
     * Method checkForDateText has been updated to private.
     * This is for reference only.
     */
    /*
     * public void testCheckDateText() {
     * CommandParser parser = new CommandParser();
     *
     * assertEquals(true, parser.checkForDateText("1 march"));
     * assertEquals(true, parser.checkForDateText("31 april"));
     * assertEquals(true, parser.checkForDateText("20 may"));
     *
     * assertEquals(true, parser.checkForDateText("1 mar"));
     * assertEquals(true, parser.checkForDateText("31 apr"));
     * assertEquals(true, parser.checkForDateText("20 jun"));
     *
     * assertEquals(true, parser.checkForDateText("from 1 march"));
     * assertEquals(true, parser.checkForDateText("by 31 april"));
     * assertEquals(true, parser.checkForDateText("on 20 may"));
     *
     * assertEquals(true, parser.checkForDateText("from 1 mar"));
     * assertEquals(true, parser.checkForDateText("by 31 apr"));
     * assertEquals(true, parser.checkForDateText("on 20 jun"));
     *
     * assertEquals(false, parser.checkForDateText("32 march"));
     * assertEquals(false, parser.checkForDateText("55 june"));
     *
     * assertEquals(false, parser.checkForDateText("1 januaryy"));
     * assertEquals(false, parser.checkForDateText("1 janu"));
     * assertEquals(false, parser.checkForDateText("1 jjan"));
     * }
     */

    /**
     * Test detection of days in text format in user input.
     * Method checkForDay has been updated to private.
     * This is for reference only.
     */
    /*
     * public void testCheckDayText() {
     * CommandParser parser = new CommandParser();
     *
     * assertEquals(true, parser.checkForDay("monday"));
     * assertEquals(true, parser.checkForDay("thur"));
     * assertEquals(true, parser.checkForDay("thurs"));
     *
     * assertEquals(true, parser.checkForDay("from monday"));
     * assertEquals(true, parser.checkForDay("on thur"));
     * assertEquals(true, parser.checkForDay("at thurs"));
     *
     *
     * assertEquals(false, parser.checkForDay("mondayy"));
     * assertEquals(false, parser.checkForDay("mmon"));
     * assertEquals(false, parser.checkForDay("monn"));
     * }
     */

    // =============================
    // Add's stuff
    // =============================

    /**
     * Test for the detection of floating task.
     * Even with prepositions, it should not be dated.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testDetectFloating() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();

        Task task = parser.parseAdd("Do assignment 1");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Undo task 3");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Fetch my brothers from school");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Send 100 emails from my computer");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Drive by the supermarket");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Attack enemy base on signal");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Send 100 email before I sleep");
        assertEquals(false, task.hasDate());

        task = parser.parseAdd("Watch \"day after tomorrow\" movie");
        assertEquals(false, task.hasDate());
    }

    /**
     * Test to ensure floating task are added correctly.
     * It should not be dated.
     * The title should be the whole user input.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testAddFloating() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();

        Task task = parser.parseAdd("Cook dinner");
        assertEquals(false, task.hasDate());
        assertEquals("Cook dinner", task.getTitle());

        task = parser.parseAdd("Attack enemy base on signal");
        assertEquals(false, task.hasDate());
        assertEquals("Attack enemy base on signal", task.getTitle());
    }

    /**
     * Test for valid label extraction.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testLabel() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();

        Task task = parser.parseAdd("Cook dinner #home");
        assertEquals("Cook dinner", task.getTitle());
        assertEquals("home", task.getLabel());

        task = parser.parseAdd("#home Cook dinner");
        assertEquals("Cook dinner", task.getTitle());
        assertEquals("home", task.getLabel());

        boolean thrown = false;
        try {
            task = parser.parseAdd("Cook dinner #");
        } catch (InvalidLabelFormat e) {
            thrown = true;
        }
        assertEquals(true, thrown);

        thrown = false;
        try {
            task = parser.parseAdd("  #  ");
        } catch (InvalidLabelFormat e) {
            thrown = true;
        }
        assertEquals(true, thrown);
    }

    /**
     * Test priority toggling.
     * There are only four levels of priority.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testTogglePriority() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task = parser.parseAdd("Cook dinner #home");
        assertEquals(0, task.getPriority());
        assertEquals(1, task.togglePriority(true));
        assertEquals(2, task.togglePriority(true));
        assertEquals(3, task.togglePriority(true));
        assertEquals(0, task.togglePriority(true));
    }

    /**
     * Test completed status toggling.
     * A status can either be done or undone.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testToggleDone() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task = parser.parseAdd("Do assignment");
        assertEquals(false, task.isDone());

        task.setIsCompleted();
        assertEquals(true, task.isDone());

        task.setNotCompleted();
        assertEquals(false, task.isDone());
    }

    /**
     * Test for adding a task without preposition.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testNoPreposition() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task;

        task = parser.parseAdd("Buy apple 1 Aug 3pm");
        assertEquals("Buy apple on 1 Aug at 3pm", task.toString());

        task = parser.parseAdd("Buy apple 1 Aug");
        assertEquals("Buy apple on 1 Aug", task.toString());

        task = parser.parseAdd("Buy apple 11.50pm");
        assertEquals("Buy apple today at 11:50pm", task.toString());

        task = parser.parseAdd("Buy apple 11.50pm");
        assertEquals("Buy apple today at 11:50pm", task.toString());

        task = parser.parseAdd("Buy apple 11:49-11:50pm");
        assertEquals("Buy apple today at 11:49pm - 11:50pm", task.toString());

        task = parser.parseAdd("Buy apple 11:49pm-11:50pm");
        assertEquals("Buy apple today at 11:49pm - 11:50pm", task.toString());

        // if ending not specified, am
        // task = parser.parseAdd("Buy apple 10pm-3");
        //assertEquals("Buy apple from today 10pm - this Sun 3am", task.toString());
    }

    /**
     * Test for time detection without preposition if time is explicitly
     * specified.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testHasTime() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task;

        task = parser.parseAdd("Dinner 11.50pm");
        assertEquals("Dinner today at 11:50pm", task.toString());

        task = parser.parseAdd("Dinner 11.50PM today");
        assertEquals("Dinner today at 11:50pm", task.toString());

        task = parser.parseAdd("Homework 11.50pm");
        assertEquals("Homework today at 11:50pm", task.toString());
        /*
        task = parser.parseAdd("Do tutorial by morning");
        assertEquals("Do tutorial by this Sun 8am", task.toString());

        task = parser.parseAdd("Do tutorial by afternoon");
        assertEquals("Do tutorial by this Sun 12pm", task.toString());

        task = parser.parseAdd("Do tutorial by evening");
        assertEquals("Do tutorial by this Sun 7pm", task.toString());

        task = parser.parseAdd("Do tutorial midnight");
        assertEquals("Do tutorial on this Sun at 12am", task.toString());

        task = parser.parseAdd("Do tutorial afternoon 5pm");
        assertEquals("Do tutorial on this Sun at 5pm", task.toString());
        */
    }

    /**
     * Date should be relative to current time when being parsed.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testSmartDetectionOfTime() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task;

        /*
        task = parser.parseAdd("Do homework by 11.50");
        assertEquals("Do homework by today 11:50pm", task.toString());
        */

        task = parser.parseAdd("Do homework by 11:50pm");
        assertEquals("Do homework by today 11:50pm", task.toString());

        task = parser.parseAdd("Do homework by 1 Aug 2pm");
        assertEquals("Do homework by 1 Aug 2pm", task.toString());
    }

    /**
     * Test for start time detection when parsing.
     * Feedback shown is relative to the current period.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testDetectStartTime() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task = parser.parseAdd("Attempt quiz from 5pm 1 Aug");
        assertEquals("Attempt quiz", task.getTitle());
        assertEquals("Attempt quiz on 1 Aug at 5pm", task.toString());

        task = parser.parseAdd("Watch webcast after 3am on 1 AUG");
        assertEquals("Watch webcast", task.getTitle());
        assertEquals("Watch webcast on 1 Aug at 3am", task.toString());

        task = parser.parseAdd("Watch movie at 11:50pm");
        assertEquals("Watch movie", task.getTitle());
        assertEquals("Watch movie today at 11:50pm", task.toString());

        task = parser.parseAdd("Watch movie on 1 Aug 7pm");
        assertEquals("Watch movie", task.getTitle());
        assertEquals("Watch movie on 1 Aug at 7pm", task.toString());
    }

    /**
     * Test for correct parsing of ranged time in user input.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testTaskWithTimeRange() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task = parser.parseAdd("Do homework on 1Aug 2-4pm");
        assertEquals("Do homework 1 Aug from 2pm - 4pm", task.toString());

        task = parser.parseAdd("Do homework from 2pm-4 on 1aug");
        assertEquals("Do homework 1 Aug from 2pm - 4am", task.toString());

        task = parser.parseAdd("Do homework on 1aug 2pm-4pm");
        assertEquals("Do homework 1 Aug from 2pm - 4pm", task.toString());

        task = parser.parseAdd("Do homework on 1st aug 2pm-4pm");
        assertEquals("Do homework 1 Aug from 2pm - 4pm", task.toString());

        task = parser.parseAdd("Do homework on 1 aug 10-11pm");
        assertEquals("Do homework 1 Aug from 10pm - 11pm", task.toString());

        task = parser.parseAdd("Do homework from 10pm-11 on 1 Aug");
        assertEquals("Do homework 1 Aug from 10pm - 11am", task.toString());

        task = parser.parseAdd("Do homework on 1 Aug 10pm-11pm");
        assertEquals("Do homework 1 Aug from 10pm - 11pm", task.toString());

        task = parser.parseAdd("Do homework on 1st aug 10pm-11pm");
        assertEquals("Do homework 1 Aug from 10pm - 11pm", task.toString());
    }

    /**
     * Test feedback shown when parsing tasks
     * Feedback shown is relative to the current period.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testTaskToString() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();

        Task task = parser.parseAdd("Cook dinner");
        assertEquals("Cook dinner", task.toString());

        task = parser.parseAdd("Cook dinner #home");
        assertEquals("Cook dinner #home", task.toString());

        task = parser.parseAdd("Cook dinner on 14/3 at 7pm #home");
        assertEquals("Cook dinner on 14 Mar at 7pm #home", task.toString());

        task = parser.parseAdd("Cook dinner on 15/3 7.15pm");
        assertEquals("Cook dinner on 15 Mar at 7:15pm", task.toString());

        task = parser.parseAdd("Cook dinner on 30/3 7:15pm");
        assertEquals("Cook dinner on 30 Mar at 7:15pm", task.toString());

        task = parser.parseAdd("Attend meeting on 26-3 7pm");
        assertEquals("Attend meeting on 26 Mar at 7pm", task.toString());

        task = parser.parseAdd("Attend meeting from 4 to 6pm on 25 Mar");
        assertEquals("Attend meeting 25 Mar from 4pm - 6pm", task.toString());

        task = parser.parseAdd("Attend meeting 4 to 6pm on 25 Mar");
        assertEquals("Attend meeting 25 Mar from 4pm - 6pm", task.toString());

        task = parser.parseAdd("Attend meeting on 1 Mar 9am");
        assertEquals("Attend meeting on 1 Mar at 9am", task.toString());

        task = parser.parseAdd("Go camp from 1-3 8am to 3-3 9pm");
        assertEquals("Go camp from 1 Mar 8am - 3 Mar 9pm", task.toString());
    }

    /**
     * Test parsing of days.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testDays() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task;
        /*
        // now is tues
        task = parser.parseAdd("Attend meeting on thurs");
        assertEquals("Attend meeting on next Thu", task.toString());

        // now is tues
        task = parser.parseAdd("Attend meeting from mon to weds");
        assertEquals("Attend meeting from next Mon - next Wed", task.toString());
        */

        task = parser.parseAdd("Do homework from 1/2 to 2/2");
        assertEquals("Do homework from 1 Feb - 2 Feb", task.toString());
    }

    /**
     * Test adding of dated task.
     * Asserts title and time has been parsed correctly.
     *
     * @throws ParseException
     *             for dateFormat.parse()
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testAdd() throws ParseException, InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task = parser.parseAdd("Cook dinner on 24 Mar 7pm #home");
        SimpleDateFormat dateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss Z yyyy");
        String startDate = "Thu Mar 24 19:00:00 SGT 2016";
        Date expectedStart = dateFormat.parse(startDate);

        assertEquals(true, task.hasDate());
        assertEquals(expectedStart, task.getStartDate());
        assertEquals("Cook dinner", task.getTitle());
    }

    /**
     * Test for extraction of date information in title.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testDatedTaskTitle() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task = parser.parseAdd("Attend meeting from Monday to Wednesday");
        assertEquals("Attend meeting", task.getTitle());

        task = parser.parseAdd("Attend meeting from 4 to 6");
        assertEquals("Attend meeting", task.getTitle());

        task = parser.parseAdd("Cook dinner at 7");
        assertEquals("Cook dinner", task.getTitle());

        task = parser.parseAdd("Attend meeting on this Wed");
        assertEquals("Attend meeting", task.getTitle());

        task = parser.parseAdd("Do homework by next Sunday");
        assertEquals("Do homework", task.getTitle());

        task = parser.parseAdd("Send 100 email before 8pm");
        assertEquals("Send 100 email", task.getTitle());

        task = parser.parseAdd("Meet at \"Taco Tuesday\" on Wednesday 5pm");
        assertEquals("Meet at \"Taco Tuesday\"", task.getTitle());

        task = parser.parseAdd("Chase \"2pm\" Korean band on Saturday 7pm");
        assertEquals("Chase \"2pm\" Korean band", task.getTitle());

        task = parser.parseAdd("Attend meeting from Monday to Wednesday 6pm");
        assertEquals("Attend meeting", task.getTitle());

        task = parser.parseAdd("Cook dinner at 7pm at home");
        assertEquals("Cook dinner at home", task.getTitle());

        task = parser.parseAdd("Cook dinner on 24 Mar 7pm");
        assertEquals("Cook dinner", task.getTitle());

        task = parser.parseAdd("Do assignment by Sunday 8pm");
        assertEquals("Do assignment", task.getTitle());

        task = parser.parseAdd("Send 100 email before sunday 7pm");
        assertEquals("Send 100 email", task.getTitle());
    }

    /**
     * Test for specifying priority level in command for adding or editing.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testPriorityInCommand() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        task = parser.parseAdd("eat brownie priority low");
        assertEquals(1, task.getPriority());
        assertEquals("eat brownie P:low", task.toString());

        task = parser.parseAdd("eat brownie priority mid");
        assertEquals(2, task.getPriority());
        assertEquals("eat brownie P:mid", task.toString());

        task = parser.parseAdd("eat brownie priority high");
        assertEquals(3, task.getPriority());
        assertEquals("eat brownie P:high", task.toString());

        task = parser.parseAdd("eat brownie priority HIGH");
        assertEquals(3, task.getPriority());
        assertEquals("eat brownie P:high", task.toString());

        task = parser.parseAdd("eat brownie from 1/8 10pm to 11pm priority h");
        assertEquals(3, task.getPriority());
        assertEquals("eat brownie 1 Aug from 10pm - 11pm P:high", task.toString());

        // for editing
        task2 = parser.parseEdit(task, "priority m");
        assertEquals("eat brownie 1 Aug from 10pm - 11pm P:mid", task2.toString());
    }

    /**
     * Test for parsing date with year (and time).
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testAddEditWithYear() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        task = parser.parseAdd("Buy fountain pen on 30/8/2020");
        assertEquals("Buy fountain pen on 30 Aug 2020", task.toString());

        task = parser.parseAdd("Buy fountain pen on 30/8/20");
        assertEquals("Buy fountain pen on 30 Aug 2020", task.toString());

        task = parser.parseAdd("Buy fountain pen on 30/8/2020 8pm");
        assertEquals("Buy fountain pen on 30 Aug 2020 at 8pm", task.toString());

        task = parser.parseAdd("Buy fountain pen on 30/8/20 8pm");
        assertEquals("Buy fountain pen on 30 Aug 2020 at 8pm", task.toString());

        task = parser.parseAdd("Go Japan from 1/8/20 8am to 30/8/20 10pm");
        assertEquals("Go Japan from 1 Aug 2020 8am - 30 Aug 2020 10pm", task.toString());

        task = parser.parseAdd("Go Japan from 1/8/20 8am to 30/8/20 10pm");
        task2 = parser.parseEdit(task, "9-11pm");
        assertEquals("Go Japan from 1 Aug 2020 9pm - 30 Aug 2020 11pm", task2.toString());

        task = parser.parseAdd("Go Japan from 1/8/20 8am to 30/8/20 10pm");
        task2 = parser.parseEdit(task, "1/9");
        assertEquals("Go Japan on 1 Sep", task2.toString());

        task = parser.parseAdd("Go Japan from 1/8/20 8am to 30/8/20 10pm");
        task2 = parser.parseEdit(task, "1/9/21");
        assertEquals("Go Japan on 1 Sep 2021", task2.toString());

        task = parser.parseAdd("Buy fountain pen on 30 aug 2020");
        assertEquals("Buy fountain pen on 30 Aug 2020", task.toString());

        task = parser.parseAdd("Buy fountain pen on 30 aug 20");
        assertEquals("Buy fountain pen on 30 Aug 2020", task.toString());

        task = parser.parseAdd("Buy fountain pen by 30 august 2020 8pm");
        assertEquals("Buy fountain pen by 30 Aug 2020 8pm", task.toString());

        task = parser.parseAdd("Buy fountain pen on 30 august 20 9pm");
        assertEquals("Buy fountain pen on 30 Aug 2020 at 9pm", task.toString());

        task = parser.parseAdd("Go Japan from 1 Aug 2020 8am to 30 aug 2020 10pm");
        assertEquals("Go Japan from 1 Aug 2020 8am - 30 Aug 2020 10pm", task.toString());

        task = parser.parseAdd("Go Japan from 1 Aug 20 8am to 30 aug 20 10pm");
        assertEquals("Go Japan from 1 Aug 2020 8am - 30 Aug 2020 10pm", task.toString());

        task = parser.parseAdd("Go Japan from 1 Aug 20 8am to 30aug 20 10pm");
        task2 = parser.parseEdit(task, "9-11pm");
        assertEquals("Go Japan from 1 Aug 2020 9pm - 30 Aug 2020 11pm", task2.toString());

        task = parser.parseAdd("Go Japan from 1aug 20 8am to 30aug 20 10pm");
        task2 = parser.parseEdit(task, "1sep");
        assertEquals("Go Japan on 1 Sep", task2.toString());

        task = parser.parseAdd("Go Japan from 1aug 20 8am to 30aug 20 10pm");
        task2 = parser.parseEdit(task, "1sep 2021");
        assertEquals("Go Japan on 1 Sep 2021", task2.toString());
    }

    /**
     * Test method for comparing task.
     * Tasks are compared by their creation date.
     * Task with same title would not be equal.
     *
     * @throws InterruptedException
     *             for Thread.sleep().
     *             Ensures that there are differences in time when creating
     *             task.
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testCompareTo() throws InterruptedException, InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task1, task2;

        task1 = parser.parseAdd("Cook dinner at 7pm");
        Thread.sleep(2000);
        task2 = parser.parseAdd("Cook dinner at 7pm");
        assertEquals(-1, task1.compareTo(task2));

        task1 = parser.parseAdd("Cook dinner at 8pm");
        Thread.sleep(2000);
        task2 = parser.parseAdd("Cook dinner at 9pm");
        assertEquals(-1, task1.compareTo(task2));

        task1 = parser.parseAdd("Attend meeting");
        Thread.sleep(2000);
        task2 = parser.parseAdd("Attend meeting #important");
        assertEquals(-1, task1.compareTo(task2));
    }

    // =============================
    // Edit's stuff
    // =============================

    /**
     * Test extracting index for edit.
     */
    @Test
    public void testGetIndexForEdit() {
        CommandParser parser = new CommandParser();
        int index;

        index = parser.getIndexForEdit("edit 1 23 march");
        assertEquals(1, index);

        index = parser.getIndexForEdit("edit 2 1 april 7pm");
        assertEquals(2, index);

        index = parser.getIndexForEdit("edit 3 1 april 7pm-8pm");
        assertEquals(3, index);

        index = parser.getIndexForEdit("edit 4 buy chocolate #party on 1 april");
        assertEquals(4, index);

        index = parser.getIndexForEdit("edit 1 april");
        assertEquals(-1, index);
    }

    /**
     * Test if date is detected in string.
     * If detected, Date object is returned.
     * Else, null is returned.
     *
     * Note that there are some special cases in the method getDateForSearch.
     */
    @Test
    public void testGetDateForSearch() {
        CommandParser parser = new CommandParser();
        Date date;

        date = parser.getDateForSearch("1 march");
        assertNotNull(date);

        date = parser.getDateForSearch("1/3");
        assertNotNull(date);

        date = parser.getDateForSearch("today");
        assertNotNull(date);

        date = parser.getDateForSearch("tomorrow");
        assertNotNull(date);

        date = parser.getDateForSearch("meeting");
        assertNull(date);

        date = parser.getDateForSearch("finance proposal");
        assertNull(date);
    }

    /**
     * Test editing of an existing task.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testEditBasic() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "Buy chocolate");
        assertEquals("Buy chocolate", task2.toString());

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "Buy chocolate #party");
        assertEquals("Buy chocolate #party", task2.toString());

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "Buy chocolate by 11.50pm");
        assertEquals("Buy chocolate by today 11:50pm", task2.toString());

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "Buy chocolate from 11:50pm");
        assertEquals("Buy chocolate today at 11:50pm", task2.toString());

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "Buy milk at discount from 11:49pm to 11:50pm");
        assertEquals("Buy milk at discount today at 11:49pm - 11:50pm", task2.toString());
    }

    /**
     * Test editing time of existing task.
     * Old information should be retained.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testEditTimeOnly() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        /*
        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "by 11:50");
        assertEquals("Buy milk by today 11:50pm", task2.toString());
        */

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "11:50pm");
        assertEquals("Buy milk today at 11:50pm", task2.toString());

        task = parser.parseAdd("Buy milk");
        task2 = parser.parseEdit(task, "11:49pm to 11:50pm");
        assertEquals("Buy milk today at 11:49pm - 11:50pm", task2.toString());

        task = parser.parseAdd("Buy milk at 11:48pm");
        task2 = parser.parseEdit(task, "11:49pm to 11:50pm");
        assertEquals("Buy milk today at 11:49pm - 11:50pm", task2.toString());

        task = parser.parseAdd("Buy milk from 11:48 to 11:49pm");
        task2 = parser.parseEdit(task, "by 11:50pm");
        assertEquals("Buy milk by today 11:50pm", task2.toString());

        task = parser.parseAdd("Buy milk from 11:48 to 11:49pm");
        task2 = parser.parseEdit(task, "from 11:50 to 11:51pm");
        assertEquals("Buy milk today at 11:50pm - 11:51pm", task2.toString());
    }

    @Test
    public void testEditTimeOnly2() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        task = parser.parseAdd("Buy milk on 1 Aug at 2pm #party");

        task2 = parser.parseEdit(task, "3am");
        assertEquals("Buy milk on 1 Aug at 3am #party", task2.toString());

        task2 = parser.parseEdit(task, "3pm");
        assertEquals("Buy milk on 1 Aug at 3pm #party", task2.toString());

        //task2 = parser.parseEdit(task, "at 4");
        //assertEquals("Buy milk on 1 Aug at 4am #party", task2.toString());

        task2 = parser.parseEdit(task, "at 4am");
        assertEquals("Buy milk on 1 Aug at 4am #party", task2.toString());

        task2 = parser.parseEdit(task, "at 4pm");
        assertEquals("Buy milk on 1 Aug at 4pm #party", task2.toString());

        task2 = parser.parseEdit(task, "3-4pm");
        assertEquals("Buy milk 1 Aug from 3pm - 4pm #party", task2.toString());

        task2 = parser.parseEdit(task, "3pm-4pm");
        assertEquals("Buy milk 1 Aug from 3pm - 4pm #party", task2.toString());

        task2 = parser.parseEdit(task, "3pm-4");
        assertEquals("Buy milk 1 Aug from 3pm - 4am #party", task2.toString());

        task2 = parser.parseEdit(task, "from 3-4pm");
        assertEquals("Buy milk 1 Aug from 3pm - 4pm #party", task2.toString());

        task2 = parser.parseEdit(task, "from 3pm-4pm");
        assertEquals("Buy milk 1 Aug from 3pm - 4pm #party", task2.toString());

        task2 = parser.parseEdit(task, "from 3pm-4");
        assertEquals("Buy milk 1 Aug from 3pm - 4am #party", task2.toString());
    }

    /**
     * Test editing of task.
     * If information is not specified, use the old task information.
     * This allows updating of only the date or time.
     * If only the date is specified, the time will not be retained.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testOverallEdit() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        task = parser.parseAdd("Buy milk by 30 august 7pm");
        task2 = parser.parseEdit(task, "by 4pm");
        assertEquals("Buy milk by 30 Aug 4pm", task2.toString());
        assertEquals(0, task2.getPriority());

        task = parser.parseAdd("Buy milk by 30 aug 7pm");
        task.togglePriority(true);
        task2 = parser.parseEdit(task, "from 1 to 3pm");
        assertEquals("Buy milk 30 Aug from 1pm - 3pm P:low", task2.toString());
        assertEquals(1, task2.getPriority());

        task = parser.parseAdd("Buy milk by 10 aug");
        task.togglePriority(true);
        task.togglePriority(true);
        task2 = parser.parseEdit(task, "by 20 aug 8pm");
        assertEquals("Buy milk by 20 Aug 8pm P:mid", task2.toString());
        assertEquals(2, task2.getPriority());

        task = parser.parseAdd("Buy kitkat by 10 aug 7pm");
        task.togglePriority(true);
        task.togglePriority(true);
        task.togglePriority(true);
        task.setPriority(3);
        task2 = parser.parseEdit(task, "by 30 aug");
        assertEquals("Buy kitkat by 30 Aug P:high", task2.toString());
        assertEquals(3, task2.getPriority());

        task = parser.parseAdd("Buy kitkat by 10 aug 7pm");
        task2 = parser.parseEdit(task, "FROM 25 Aug TO 26 AUGUST");
        assertEquals("Buy kitkat from 25 Aug - 26 Aug", task2.toString());
    }

    @Test
    public void testOverallEdit2() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;

        task = parser.parseAdd("Drink coffee from 1/8 to 3/8 8pm #overdose");

        task2 = parser.parseEdit(task, "1/9 to 3/9");
        assertEquals("Drink coffee from 1 Sep - 3 Sep #overdose", task2.toString());

        task2 = parser.parseEdit(task, "Drink hot chocolate");
        assertEquals("Drink hot chocolate from 1 Aug 8pm - 3 Aug 8pm #overdose", task2.toString());

        task2 = parser.parseEdit(task, "#beedohbeedoh");
        assertEquals("Drink coffee from 1 Aug 8pm - 3 Aug 8pm #beedohbeedoh", task2.toString());

        task2 = parser.parseEdit(task, "1 Sep");
        assertEquals("Drink coffee on 1 Sep #overdose", task2.toString());

        task2 = parser.parseEdit(task, "from 9 to 10pm");
        assertEquals("Drink coffee from 1 Aug 9pm - 3 Aug 10pm #overdose", task2.toString());

        task2 = parser.parseEdit(task, "by 1 Aug 2pm");
        assertEquals("Drink coffee by 1 Aug 2pm #overdose", task2.toString());
    }

    /**
     * Tests for usage of common abbreviations of words.
     *
     * @throws InvalidLabelFormat
     * @throws InvalidTitle
     */
    @Test
    public void testShortcut() throws InvalidLabelFormat {
        CommandParser parser = new CommandParser();
        Task task, task2;
        /*
        task = parser.parseAdd("Supper tmr 11pm");
        assertEquals("Supper on this Sun at 11pm", task.toString());

        task = parser.parseAdd("Supper tml 11pm");
        assertEquals("Supper on this Sun at 11pm", task.toString());

        task = parser.parseAdd("Supper tmrw 11pm");
        assertEquals("Supper on this Sun at 11pm", task.toString());

        task = parser.parseAdd("Donate books");
        task2 = parser.parseEdit(task, "tmr 11pm");
        assertEquals("Donate books on this Sun at 11pm", task2.toString());
        */

        task = parser.parseAdd("Supper today 11:50pm");
        assertEquals("Supper today at 11:50pm", task.toString());

        task = parser.parseAdd("Supper tdy 11.50pm");
        assertEquals("Supper today at 11:50pm", task.toString());

        task = parser.parseAdd("Donate books");
        task2 = parser.parseEdit(task, "tdy 11:50pm");
        assertEquals("Donate books today at 11:50pm", task2.toString());
    }

    // =============================
    // Test parsing indexes
    // =============================

    /**
     * Test parsing of indexes.
     *
     * @throws InvalidTaskIndexFormat
     */
    @Test
    public void testIndexes() throws InvalidTaskIndexFormat {
        CommandParser parser = new CommandParser();
        ParseIndexResult indexes;
        indexes = parser.parseIndexes("delete 1", 2);

        ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
        expectedIndexes.add(1);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("del 1,3,5,7,9", 10);
        expectedIndexes.clear();
        expectedIndexes.add(1);
        expectedIndexes.add(3);
        expectedIndexes.add(5);
        expectedIndexes.add(7);
        expectedIndexes.add(9);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("done 1-10", 10);
        expectedIndexes.clear();
        expectedIndexes.add(1);
        expectedIndexes.add(2);
        expectedIndexes.add(3);
        expectedIndexes.add(4);
        expectedIndexes.add(5);
        expectedIndexes.add(6);
        expectedIndexes.add(7);
        expectedIndexes.add(8);
        expectedIndexes.add(9);
        expectedIndexes.add(10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("undone 1-3,4,5,6-9,10", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("done 1-10,5,6,7,8,9,10", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());
    }

    /**
     * Test parsing of invalid indexes.
     *
     * @throws InvalidTaskIndexFormat
     */
    @Test
    public void testInvalidIndexes() throws InvalidTaskIndexFormat {
        CommandParser parser = new CommandParser();
        ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
        ParseIndexResult indexes;

        indexes = parser.parseIndexes("del 11", 10);
        expectedIndexes.add(11);
        assertEquals(true, indexes.hasInvalidIndex());
        assertEquals(expectedIndexes, indexes.getInvalidIndexes());

        indexes = parser.parseIndexes("del 11,12,13", 10);
        expectedIndexes.clear();
        expectedIndexes.add(11);
        expectedIndexes.add(12);
        expectedIndexes.add(13);
        assertEquals(true, indexes.hasInvalidIndex());
        assertEquals(expectedIndexes, indexes.getInvalidIndexes());

        indexes = parser.parseIndexes("del 11-13", 10);
        assertEquals(true, indexes.hasInvalidIndex());
        assertEquals(expectedIndexes, indexes.getInvalidIndexes());
    }

    /**
     * Test parsing of indexes when user input does not follow the "usual" way.
     *
     * @throws InvalidTaskIndexFormat
     */
    @Test
    public void testUnconventionalIndexes() throws InvalidTaskIndexFormat {
        CommandParser parser = new CommandParser();

        ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
        expectedIndexes.add(1);
        expectedIndexes.add(2);
        expectedIndexes.add(3);
        expectedIndexes.add(4);
        expectedIndexes.add(5);
        expectedIndexes.add(6);
        expectedIndexes.add(7);
        expectedIndexes.add(8);
        expectedIndexes.add(9);
        expectedIndexes.add(10);

        ParseIndexResult indexes;
        indexes = parser.parseIndexes("del 1--10", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("del 1-----10", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("del 1-3-5-7-9-10", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        Collections.sort(expectedIndexes, Collections.reverseOrder());
        indexes = parser.parseIndexes("del 10-1", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());

        indexes = parser.parseIndexes("del 10-9-7-5-3-1", 10);
        assertEquals(expectedIndexes, indexes.getValidIndexes());
    }

    /**
     * Test for invalid input for parsing indexes.
     * Exceptions should be thrown.
     *
     * @throws InvalidTaskIndexFormat
     */
    @Test
    public void testInvalidDelete() throws InvalidTaskIndexFormat {
        boolean thrown;
        CommandParser parser = new CommandParser();
        ParseIndexResult indexes;

        thrown = false;
        try {
            indexes = parser.parseIndexes("del -1,-2", 10);
        } catch (InvalidTaskIndexFormat e) {
            thrown = true;
        }

        assertEquals(true, thrown);

        thrown = false;
        try {
            indexes = parser.parseIndexes("del 1-,10", 10);
        } catch (InvalidTaskIndexFormat e) {
            thrown = true;
        }
        assertEquals(true, thrown);

        thrown = false;
        try {
            indexes = parser.parseIndexes("del abc,def", 10);
        } catch (InvalidTaskIndexFormat e) {
            thrown = true;
        }
        assertEquals(true, thrown);
    }

    /**
     * Test for getting valid and invalid indexes string.
     *
     * @throws InvalidTaskIndexFormat
     */
    @Test
    public void testIndexesString() throws InvalidTaskIndexFormat {
        CommandParser parser = new CommandParser();
        ParseIndexResult indexes;

        indexes = parser.parseIndexes("del 1-10,12,13,14,15", 10);
        assertEquals(true, indexes.hasValidIndex());
        assertEquals(true, indexes.hasInvalidIndex());
        assertEquals("1-10", indexes.getValidIndexesString());
        assertEquals("12-15", indexes.getInvalidIndexesString());

        indexes = parser.parseIndexes("del 1-5,10-20, 31, 32, 33, 35", 10);
        assertEquals(true, indexes.hasValidIndex());
        assertEquals(true, indexes.hasInvalidIndex());
        assertEquals("1-5,10", indexes.getValidIndexesString());
        assertEquals("11-20,31-33,35", indexes.getInvalidIndexesString());
    }
}
```
